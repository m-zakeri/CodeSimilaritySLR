"Document Title",Authors,"Author Affiliations","Publication Title",Date Added To Xplore,"Publication Year","Volume","Issue","Start Page","End Page","Abstract","ISSN",ISBNs,"DOI",Funding Information,PDF Link,"Author Keywords","IEEE Terms","INSPEC Controlled Terms","INSPEC Non-Controlled Terms","Mesh_Terms",Article Citation Count,Patent Citation Count,"Reference Count","License",Online Date,Issue Date,"Meeting Date","Publisher",Document Identifier
"Tool Support for Continuous Quality Assessment","F. Deissenboeck; M. Pizka; T. Seifert","Software & Systems Engineering, Technische Universität München, Garching, Germany; Software & Systems Engineering, Technische Universität München, Garching, Germany; Software & Systems Engineering, Technische Universität München, Garching, Germany","13th IEEE International Workshop on Software Technology and Engineering Practice (STEP'05)","11 Sep 2006","2005","","","127","136","Maintenance costs make up the bulk of the total life cycle costs of a software system. Besides organizational issues such as knowledge management and turnover, the long-term maintenance costs are largely predetermined by various quality attributes of the software system itself such as redundancy and adequate documentation. Unfortunately, many quality defects can hardly be corrected retrospectively after they have penetrated the system. A much more promising approach than correction is to avoid decay and to preserve a constant high level of quality through a continuous real-time quality controlling process. To reduce the costs for the required frequent quality assessments, adequate tool support is indispensable. This paper proposes to integrate measurement tools into a flexible and extensible yet high performance quality assessment tool. We present the design and implementation of this tool and report on our experiences made with it in a medium-sized academical project. Among the positive effects are improved software product quality and reduced efforts for manual quality assessments as well as increased awareness for quality issues","","0-7695-2639-X","10.1109/STEP.2005.31","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1691640","","Quality assessment;Costs;Software systems;Software maintenance;Process control;Software quality;ISO standards;Systems engineering and theory;Knowledge management;Documentation","quality management;software maintenance;software quality;software tools;system documentation","tool support;continuous quality assessment;software maintenance;software system;knowledge management;software quality;redundancy;software documentation;quality control","","9","","19","IEEE","11 Sep 2006","","","IEEE","IEEE Conferences"
"Workshop on Empirical Studies in Reverse Engineering","P. Tonella","ITC IRST, Trento, Italy","13th IEEE International Workshop on Software Technology and Engineering Practice (STEP'05)","11 Sep 2006","2005","","","61","64","The field of reverse engineering, originally tied to the analysis and restructuring of legacy systems, proved to be equally effective in supporting the evolution of modern software systems (e.g., OO code, Web applications, etc.). Correspondingly, a high number of techniques and tools have been developed to address the program comprehension needs of the programmers facing maintenance tasks on any kind of software. So far, the validation of the proposed approaches consisted mainly of proofs of concepts and limited case studies. The aim of this workshop was to assess the role of the empirical studies in the future developments of reverse engineering. Knowledge on the actual effectiveness of the available techniques and tools can be gained only through controlled experimentation. In this workshop, the scope of investigation of such studies was considered, and a (provisional) reference taxonomy of tools and techniques was discussed. Then, the main features of the empirical studies specifically designed to validate reverse engineering tools or techniques have been thoroughly examined","","0-7695-2639-X","10.1109/STEP.2005.36","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1691632","","","reverse engineering;software maintenance","reverse engineering;software system evolution;program comprehension;software maintenance;provisional reference taxonomy","","","","1","IEEE","11 Sep 2006","","","IEEE","IEEE Conferences"
"Improving agile software development using extreme AOCE and aspect-oriented CVS","Santokh Singh; H. . -C. Chen; O. Hunter; J. Grundy; J. Hosking","Computer Science Department, University of Auckland, Auckland, New Zealand; Computer Science Department, University of Auckland, Auckland, New Zealand; Computer Science Department, University of Auckland, Auckland, New Zealand; Computer Science Department, University of Auckland, Auckland, New Zealand; Computer Science Department, University of Auckland, Auckland, New Zealand","12th Asia-Pacific Software Engineering Conference (APSEC'05)","20 Mar 2006","2005","","","8 pp.","","Currently there are no concurrent versioning systems (CVS) designed to properly support agile software development. The existing CVS lacks user friendliness and it requires users to be fully experienced with the system before they can adequately use it. Also its asynchronous style of merging often leads to code loss. In this paper, we describe a novel CVS system, called the aspect-oriented CVS (AOCVS) and our newly derived agile software development methodology, extreme aspect-oriented component engineering (extreme AOCE). Unlike the general CVS which is used for a vast variety of projects, AOCVS was designed and developed specifically for extreme AOCE. Our CVS tool merges the changes in a synchronous/real time fashion; this in turn removes the hassle for the developers on having to resolve merging conflicts. We also describe how our implemented AOCVS can be used to provide functionalities that can assist developers to produce and distribute reusable code and to communicate and manage aspect-oriented agile projects more efficiently and effectively. Our novel agile approach and tool allows software developers to use the rich cross-cutting systemic concerns, their behaviour and properties in aspect-oriented components to refactor, maintain, add functionalities and test complex software systems more easily, rapidly and accurately.","1530-1362","0-7695-2465-6","10.1109/APSEC.2005.71","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1607218","","Programming;Software maintenance;Collaborative work;Merging;Software tools;Software systems;Computer science;Human computer interaction;Project management;Software testing","object-oriented programming;configuration management;software maintenance;software reusability","agile software development;extreme aspect-oriented component engineering;aspect-oriented concurrent versioning system;software system","","1","1","22","IEEE","20 Mar 2006","","","IEEE","IEEE Conferences"
"Archeology of code duplication: recovering duplication chains from small duplication fragments","R. Wettel; R. Marinescu","LOOSE Research Group, Institute e-Austria, Romania; LOOSE Research Group, Institute e-Austria, Romania","Seventh International Symposium on Symbolic and Numeric Algorithms for Scientific Computing (SYNASC'05)","21 Feb 2006","2005","","","8 pp.","","Code duplication is a common problem, and a well-known sign of bad design. As a result of that, in the last decade, the issue of detecting code duplication led to various solutions and tools that can automatically find duplicated blocks of code. However, duplicated fragments rarely remain identical after they are copied; they are oftentimes modified here and there. This adaptation usually ""scatters"" the duplicated code block into a large amount of small ""islands"" of duplication, which detected and analyzed separately hide the real magnitude and impact of the duplicated block. In this paper we propose a novel, automated approach for recovering duplication blocks, by composing small isolated fragments of duplication into larger and more relevant duplication chains. We validate both the efficiency and the scalability of the approach by applying it on several well known open-source case-studies and discussing some relevant findings. By recovering such duplication chains, the maintenance engineer is provided with additional cases of duplication that can lead to relevant refactorings, and which are usually missed by other detection methods.","","0-7695-2453-2","10.1109/SYNASC.2005.20","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1595830","code duplication;design flaws;quality assurance","Power system reliability;Light scattering;Scalability;Open source software;Quality assurance;Computer industry;Software systems;Image analysis;Cloning;Filtering","program compilers;software maintenance;automatic programming;program diagnostics","code duplication;duplication chains;duplication fragments;duplication blocks;design flaw;quality assurance","","35","","15","IEEE","21 Feb 2006","","","IEEE","IEEE Conferences"
"Design patterns automation with template library","S. Dascalu; Ning Hao; N. Debnath","Department of Computer Science and Engineering, University of Nevada,슠Reno, Reno, NV, USA; Department of Computer Science and Engineering, University of Nevada,슠Reno, Reno, NV, USA; Winona State University, Winona, MN, USA","Proceedings of the Fifth IEEE International Symposium on Signal Processing and Information Technology, 2005.","23 Jan 2006","2005","","","699","705","Design patterns offer reusable solutions to particular software design problems. Design patterns automation is an approach that applies design patterns at the implementation stage of the software development life cycle. Inspired by two commonly used template libraries, Active Template Library and Standard Template Library, and one of the most popular generic programming technologies, C++ templates, this paper introduces a new method for achieving design patterns automation. This method differs from the currently available UML-based and wizard-based design patterns automation techniques and provides support for increased flexibility, expandability and compatibility in developing software using design patterns. Seven of the patterns proposed by Gamma et al. have been implemented using C++ templates, namely singleton, factory method, visitor, memento, strategy, iterator, and decorator. To illustrate the method proposed, details of singleton and decorator implementations are provided and a larger ""check"" example developed using the decorator template is presented. The paper also includes a comparison with similar approaches and presents several directions of future work","2162-7843","0-7803-9313-9","10.1109/ISSPIT.2005.1577183","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1577183","","Design automation;Software libraries;Software design;Computer science;Manufacturing automation;Unified modeling language;Books;Design engineering;Automatic programming;Design methodology","C++ language;software development management;software libraries;Unified Modeling Language","software design patterns automation;software development life cycle;Active Template Library;Standard Template Library;C++ templates;UML-based design patterns automation technique;wizard-based design patterns automation technique;singleton pattern;factory method pattern;visitor pattern;memento pattern;strategy pattern;iterator pattern;decorator pattern","","4","","23","IEEE","23 Jan 2006","","","IEEE","IEEE Conferences"
"Supporting Web application evolution by dynamic analysis","G. A. Di Lucca; M. Di Penta; A. R. Fasolino; P. Tramontana","RCOST-Research Centre on Software Technology, University of Sannio, Benevento, Italy; RCOST-Research Centre on Software Technology, University of Sannio, Benevento, Italy; Dipartimento di Informatica e Sistemistica, Università di Napoli Federico II, Napoli, Italy; Dipartimento di Informatica e Sistemistica, Università di Napoli Federico II, Napoli, Italy","Eighth International Workshop on Principles of Software Evolution (IWPSE'05)","10 Jan 2006","2005","","","175","184","The evolution of Web applications needs to be supported by the availability of proper analysis and design documents. UML use case diagrams are certainly useful to identify features to evolve, as well as to study the Web application evolution in terms of features added/removed or changed. Unfortunately, very often the only source of documentation available is constituted by the Web application source code. This paper proposes an approach to abstract use case diagrams from execution traces of a Web application. The approach is mainly based on the analysis of a graph modelling the transitions between the pages navigated along user sessions and the clustering of the navigated pages. A case study carried out to validate the proposed approach and showing its feasibility is reported in the paper.","2332-5682","0-7695-2349-8","10.1109/IWPSE.2005.29","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1572324","","Documentation;Unified modeling language;Reverse engineering;Performance analysis;Application software;Navigation;Production;US Department of Transportation;Availability;Text analysis","system monitoring;Unified Modeling Language;software prototyping;reverse engineering;software maintenance","Web application evolution;dynamic analysis;design document;UML;use case diagrams;Web application source code;execution traces;graph model;page navigation;reverse engineering","","6","","18","IEEE","10 Jan 2006","","","IEEE","IEEE Conferences"
"The LAN-simulation: a refactoring teaching example","S. Demeyer; F. Van Rysselberghe; T. Girba; J. Ratzinger; R. Marinescu; T. Mens; B. Du Bois; D. Janssens; S. Ducasse; M. Lanza; M. Rieger; H. Gall; M. El-Ramly",NA; NA; NA; NA; NA; NA; NA; NA; NA; NA; NA; NA; NA,"Eighth International Workshop on Principles of Software Evolution (IWPSE'05)","10 Jan 2006","2005","","","123","131","The notion of refactoring - transforming the source-code of an object-oriented program without changing its external behaviour - has been studied intensively within the last decade. This diversity has created a plethora of toy-examples, cases and code snippets, which make it hard to assess the current state-of-the-art. Moreover, due to this diversity, there is currently no accepted way of teaching good refactoring practices, despite the acknowledgment in the software engineering body of knowledge. Therefore, this paper presents a common example - the LAN simulation - which has been used by a number of European Universities for both research and teaching purposes.","2332-5682","0-7695-2349-8","10.1109/IWPSE.2005.30","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1572316","","Education;Software engineering;Software systems;Prototypes;Local area networks;Object oriented modeling;Educational institutions;Software maintenance;Large-scale systems;Costs","object-oriented programming;local area networks;computer science education;teaching;digital simulation","object-oriented program;software engineering;LAN simulation;refactoring teaching example","","19","","21","IEEE","10 Jan 2006","","","IEEE","IEEE Conferences"
"Enriching reverse engineering with semantic clustering","A. Kuhn; S. Ducasse; T. Girba","Software Composition Group, University of Bern, Switzerland; Software Composition Group, University of Bern, Switzerland; Software Composition Group, University of Bern, Switzerland","12th Working Conference on Reverse Engineering (WCRE'05)","3 Jan 2006","2005","","","10 pp.","142","Understanding a software system by just analyzing the structure of the system reveals only half of the picture, since the structure tells us only how the code is working but not what the code is about. What the code is about can be found in the semantics of the source code: names of identifiers, comments etc. In this paper, we analyze how these terms are spread over the source artifacts using latent semantic indexing, an information retrieval technique. We use the assumption that parts of the system that use similar terms are related. We cluster artifacts that use similar terms, and we reveal the most relevant terms for the computed clusters. Our approach works at the level of the source code which makes it language independent. Nevertheless, we correlated the semantics with structural information and we applied it at different levels of abstraction (e.g. classes, methods). We applied our approach on three large case studies and we report the results we obtained.","2375-5369","0-7695-2474-5","10.1109/WCRE.2005.16","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1566153","semantic analysis;clustering;concept location;reverse engineering","Reverse engineering;Large scale integration;Information retrieval;Software systems;Information analysis;Indexing;Vocabulary;Web server;Computational modeling;Computer simulation","formal specification;reverse engineering;programming language semantics;structured programming;indexing;information retrieval;program diagnostics","reverse engineering;semantic clustering;software system;system structure;source code semantic;latent semantic indexing;information retrieval;artifacts clustering","","51","","23","IEEE","3 Jan 2006","","","IEEE","IEEE Conferences"
"Diagnosing design problems in object oriented systems","A. Trifu; R. Marinescu","FZI Forschungszentrum Informatik, Karlsruhe, Germany; LOOSE Research Group, Politehnica University, Timisoara, Romania","12th Working Conference on Reverse Engineering (WCRE'05)","3 Jan 2006","2005","","","10 pp.","164","Software decay is a phenomenon that plagues aging software systems. While in recent years, there has been significant progress in the area of automatic detection of ""code smells"" on one hand, and code refactorings on the other hand, we claim that existing restructuring practices are seriously hampered by their symptomatic and informal (non-repeatable) nature. This paper makes a clear distinction between structural problems and structural symptoms (also known as code smells), and presents a novel, causal approach to restructuring object oriented systems. Our approach is based on two innovations: the encapsulation of correlations of symptoms and additional contextual information into higher-level design problems, and the univocal, explicit mapping of problems to unique refactoring solutions. Due to its explicit, repeatable nature, the approach shows high potential for increased levels of automation in the restructuring process, and consequently a decrease in maintenance costs.","2375-5369","0-7695-2474-5","10.1109/WCRE.2005.15","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1566155","","Medical diagnostic imaging;Software systems;Diseases;Costs;Switches;Aging;Technological innovation;Encapsulation;Automation;Software maintenance","object-oriented programming;software maintenance;program diagnostics","object-oriented system design;object-oriented system diagnosis;object-oriented system restructuring;software decay;aging software system;automatic code smell detection;code refactoring solution;structural symptom encapsulation;contextual information;explicit mapping","","28","","26","IEEE","3 Jan 2006","","","IEEE","IEEE Conferences"
"When functions change their names: automatic detection of origin relationships","Sunghun Kim; Kai Pan; E. J. Whitehead","Department of Computer Science, University of California, Santa Cruz, Santa Cruz, CA, USA; Department of Computer Science, University of California, Santa Cruz, Santa Cruz, CA, USA; Department of Computer Science, University of California, Santa Cruz, Santa Cruz, CA, USA","12th Working Conference on Reverse Engineering (WCRE'05)","3 Jan 2006","2005","","","10 pp.","152","It is a common understanding that identifying the same entity such as module, file, and function between revisions is important for software evolution related analysis. Most software evolution researchers use entity names, such as file names and function names, as entity identifiers based on the assumption that each entity is uniquely identifiable by its name. Unfortunately names change over time. In this paper, we propose an automated algorithm that identifies entity mapping at the function level across revisions even when an entity's name changes in the new revision. This algorithm is based on computing function similarities. We introduce eight similarity factors to determine if a function is renamed from a function. To find out which similarity factors are dominant, a significance analysis is performed on each factor. To validate our algorithm and for factor significance analysis, ten human judges manually identified renamed entities across revisions for two open source projects: Subversion and Apache2. Using the manually identified result set we trained weights for each similarity factor and measured the accuracy of our algorithm. We computed the accuracies among human judges. We found our algorithm's accuracy is better than the average accuracy among human judges. We also show that trained weights for similarity factors from one period in one project are reusable for other periods and/or other projects. Finally we combined all possible factor combinations and computed the accuracy of each combination. We found that adding more factors does not necessarily improve the accuracy of origin detection.","2375-5369","0-7695-2474-5","10.1109/WCRE.2005.33","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1566154","","Humans;Computer science;Performance analysis;Algorithm design and analysis;History;Project management","entity-relationship modelling;functional programming;public domain software;software maintenance","function name;origin relationship automatic detection;software evolution;entity names;file names;entity identifiers;entity mapping;computing function similarities;open source projects;Subversion;Apache2","","19","3","22","IEEE","3 Jan 2006","","","IEEE","IEEE Conferences"
"Keynote speakers","",,"12th Working Conference on Reverse Engineering (WCRE'05)","3 Jan 2006","2005","","","xv","xvii","Provides an abstract for each of the keynote presentations and may include a brief professional biography of each","2375-5369","0-7695-2474-5","10.1109/WCRE.2005.20","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1566140","","","","","","","","","IEEE","3 Jan 2006","","","IEEE","IEEE Conferences"
"Beyond templates: a study of clones in the STL and some general implications","H. A. Basit; D. C. Rajapakse; S. Jarzabek","Department of Computer Science, National University of Singapore; Department of Computer Science, National University of Singapore, Singapore; Department of Computer Science, National University of Singapore, Singapore","Proceedings. 27th International Conference on Software Engineering, 2005. ICSE 2005.","19 Dec 2005","2005","","","451","459","Templates (or generics) help us write compact, generic code, which aids both reuse and maintenance. The STL is a powerful example of how templates help achieve these goals. Still, our study of the STL revealed substantial, and in our opinion, counter-productive repetitions (so-called clones) across groups of similar class or function templates. Clones occurred, as variations across these similar program structures were irregular and could not be unified by suitable template parameters in a natural way. We encountered similar problems in other class libraries as well as in application programs, written in a range of programming languages. In the paper, we present quantitative and qualitative results from our study. We argue that the difficulties we encountered affect programs in general. We present a solution that can treat such template-unfriendly cases of redundancies at the meta-level, complementing and extending the power of language features, such as templates, in areas of generic programming.","1558-1225","1-59593-963-2","10.1109/ICSE.2005.1553588","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1553588","","Cloning;Java;Software maintenance;Computer science;Software engineering;Software libraries;Software design;Permission;Computer languages;Software reusability","software maintenance;software reusability;software libraries","STL;software maintenance;program clones;meta-programming","","2","","30","","19 Dec 2005","","","IEEE","IEEE Conferences"
"Using structural context to recommend source code examples","R. Holmes; G. C. Murphy","Department of Computer Science, University of British Columbia, Vancouver, BC, Canada; Department of Computer Science, University of British Columbia, Vancouver, BC, Canada","Proceedings. 27th International Conference on Software Engineering, 2005. ICSE 2005.","19 Dec 2005","2005","","","117","125","When coding to a framework, developers often become stuck, unsure of which class to subclass, which objects to instantiate and which methods to call. Example code that demonstrates the use of the framework can help developers make progress on their task. In this paper, we describe an approach for locating relevant code in an example repository that is based on heuristically matching the structure of the code under development to the example code. Our tool improves on existing approaches in two ways. First, the structural context needed to query the repository is extracted automatically from the code, freeing the developer from learning a query language or from writing their code in a particular style. Second, the repository can be generated easily from existing applications. We demonstrate the utility of this approach by reporting on a case study involving two subjects completing four programming tasks within the Eclipse integrated development environment framework.","1558-1225","1-59593-963-2","10.1109/ICSE.2005.1553554","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1553554","","Database languages;Writing;Permission;Computer science;Utility programs;Programming environments;Programming profession;Software tools;Application software;Protocols","software tools;object-oriented programming","structural context;source code example recommendation;example repository;development environment framework","","48","16","14","","19 Dec 2005","","","IEEE","IEEE Conferences"
"Cloning by accident: an empirical study of source code cloning across software systems","R. Al-Ekram; C. Kapser; R. Holt; M. Godfrey","Software Architecture Group (SWAG), School of Computer Science, University of Waterloo, Canada; Software Architecture Group (SWAG), School of Computer Science, University of Waterloo, Canada; Software Architecture Group (SWAG), School of Computer Science, University of Waterloo, Canada; Software Architecture Group (SWAG), School of Computer Science, University of Waterloo, Canada","2005 International Symposium on Empirical Software Engineering, 2005.","5 Dec 2005","2005","","","10 pp.","","One of the key goals of open source development is the sharing of knowledge, experience, and solutions that pertain to a software system and its problem domain. Source code cloning is one way in which expertise can be reused across systems; cloning is known to have been used in several open source projects, such as the SCSI drivers of the Linux kernel. In this paper, we discuss two case studies in which we performed clone detection on several open source systems within the same domain. In the first case study we examined nine text editors written in C, and in the second study we examined eight X-Windows window managers written in C and C++. To our surprise, we found little evidence of ""true"" cloning activity, but we did notice a significant number of ""accidental"" clones - that is, code fragments that are similar due to the precise protocols they must use when interacting with a given API or set of libraries. We further discuss the nature of ""true"" versus ""accidental"" clones, as well as the details of our case studies.","","0-7803-9507-7","10.1109/ISESE.2005.1541846","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1541846","","Cloning;Accidents;Software systems;Open source software;Linux;Cascading style sheets;Knowledge transfer;Software measurement;Software architecture;Computer science","software reusability;public domain software;text editing;user interfaces","source code cloning;open source development;software system;text editors;X-Windows window manager;accidental clones","","40","","20","IEEE","5 Dec 2005","","","IEEE","IEEE Conferences"
"Improving region selection in dynamic optimization systems","D. Hiniker; K. Hazelwood; M. D. Smith","Microsoft Corporation, USA; University of Virginia, USA; Harvard University, USA","38th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO'05)","5 Dec 2005","2005","","","11 pp.","154","The performance of a dynamic optimization system depends heavily on the code it selects to optimize. Many current systems follow the design of HP Dynamo and select a single interprocedural path, or trace, as the unit of code optimization and code caching. Though this approach to region selection has worked well in practice, we show that it is possible to adapt this basic approach to produce regions with greater locality, less needless code duplication, and fewer profiling counters. In particular, we propose two new region-selection algorithms and evaluate them against Dynamo's selection mechanism, next-executing tail (NET). Our first algorithm, last-executed iteration (LEI), identifies cyclic paths of execution better than NET, improving locality of execution while reducing the size of the code cache. Our second algorithm allows overlapping traces of similar execution frequency to be combined into a single large region. This second technique can be applied to both NET and LEI, and we find that it significantly improves metrics of locality and memory overhead for each.","2379-3155","0-7695-2440-0","10.1109/MICRO.2005.22","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1540955","","Magnetohydrodynamic power generation;Design optimization;Runtime;Tail;Program processors;Counting circuits;Frequency;Virtual machining;Optimizing compilers;Design methodology","cache storage;optimising compilers;program diagnostics","dynamic optimization systems;HP Dynamo;code optimization;code caching;selection mechanism;next-executing tail;last-executed iteration","","24","4","20","IEEE","5 Dec 2005","","","IEEE","IEEE Conferences"
"Reducing instruction fetch cost by packing instructions into register windows","S. Hines; G. Tyson; D. Whalley","Computer Science Department, Florida State University, Tallahassee, FL, USA; Computer Science Department, Florida State University, Tallahassee, FL, USA; Computer Science Department, Florida State University, Tallahassee, FL, USA","38th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO'05)","5 Dec 2005","2005","","","11 pp.","29","Instruction packing is a combination compiler/architectural approach that allows for decreased code size, reduced power consumption and improved performance. The packing is obtained by placing frequently occurring instructions into an instruction register file (IRF). Multiple IRF entries can then be accessed using special packed instructions. Previous IRF efforts focused on using a single 32-entry register file for the duration of an application. This paper presents software and hardware extensions to the IRF supporting multiple instruction register windows to allow a greater number of relevant instructions to be available for packing in each function. Windows are shared among similar functions to reduce the overall costs involved in such an approach. The results indicate that significant improvements in instruction fetch cost can be obtained by using this simple architectural enhancement. We also show that using an IRF with a loop cache, which is also used to reduce energy consumption, results in much less energy consumption than using either feature in isolation.","2379-3155","0-7695-2440-0","10.1109/MICRO.2005.27","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1540945","","Energy consumption;Microarchitecture;Cost function;Logic;Computer science;Registers;Application software;Hardware;Embedded system;Batteries","program compilers;computer architecture;instruction sets;logic circuits;cache storage","instruction fetch cost reduction;register windows;instruction packing;compiler-architectural approach;instruction register file;loop cache","","4","","24","IEEE","5 Dec 2005","","","IEEE","IEEE Conferences"
"Evolving assembly programs: how games help microprocessor validation","F. Corno; E. Sanchez; G. Squillero","Politecnico di Torino, Torino, Italy; Politecnico di Torino, Torino, Italy; Politecnico di Torino, Torino, Italy","IEEE Transactions on Evolutionary Computation","5 Dec 2005","2005","9","6","695","706","Core War is a game where two or more programs, called warriors, are executed in the same memory area by a time-sharing processor. The final goal of each warrior is to crash the others by overwriting them with illegal instructions. The game was popularized by A. K. Dewdney in his Scientific American column in the mid-1980s. In order to automatically devise strong warriors, /spl mu/GP, a test program generation algorithm, was extended with the ability to assimilate existing code and to detect clones; furthermore, a new selection mechanism for promoting diversity independent from fitness calculations was added. The evolved warriors are the first machine-written programs ever able to become King of the Hill (champion) in all four main international Tiny Hills. This paper shows how playing Core War may help generate effective test programs for validation and test of microprocessors. Tackling a more mundane problem, the described techniques are currently being exploited for the automatic completion and refinement of existing test programs. Preliminary experimental results are reported.","1941-0026","","10.1109/TEVC.2005.856207","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1545944","Automatic programming;Core War;evolutionary program generation;games;microprocessor testing","Assembly;Microprocessors;Automatic testing;Circuit testing;Costs;Computer architecture;Silicon;Clocks;Buildings;System-on-a-chip","program assemblers;microcomputers;time-sharing programs;program testing;computer games","evolving assembly programs;microprocessor validation;Core War;time-sharing processor;test program generation algorithm;machine written program","","31","","32","IEEE","5 Dec 2005","","","IEEE","IEEE Journals"
"Refactor conditionals into polymorphism: what's the performance cost of introducing virtual calls?","S. Demeyer","Lab on REengineering (LORE), University of Antwerp, Belgium","21st IEEE International Conference on Software Maintenance (ICSM'05)","21 Nov 2005","2005","","","627","630","The notion of refactoring - transforming the source-code of an object-oriented program without changing its external behavior - has been embraced by many object-oriented software developers as a way to accommodate changing requirements. If applied well, refactoring improves the maintainability of the software. However, it is believed that it does so at the sake of performance. Especially in a C++ context, the introduction of virtual function calls is often blamed for performance reduction because it introduces an extra indirection via the so-called virtual function table. To investigate the performance trade-off involved when introducing virtual functions, we compared the execution time of four benchmark programs which contain large conditionals against refactored versions where the conditionals were replaced by virtual function calls. Depending on the compiler and compiler optimizations being used, we discovered that C++ programs refactored this way often perform faster than their non-refactored counterparts, hence advise programmers not to obfuscate their programs with conditional logic in order to obtain good performance.","1063-6773","0-7695-2368-4","10.1109/ICSM.2005.74","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1510160","","Costs;Software maintenance;Program processors;Logic;Programming profession;Software performance;Optimizing compilers;Software systems;Software reusability;Power generation","object-oriented programming;software maintenance;C++ language;software performance evaluation","conditional refactoring;polymorphism;software performance cost;virtual function call;source-code transformation;object-oriented program;object-oriented software development;software maintainability;C++ program refactoring;virtual function table;compiler optimization","","6","","7","IEEE","21 Nov 2005","","","IEEE","IEEE Conferences"
"Towards experience-based mentoring of evolutionary development","Z. Xing; E. Stroulia","Computing Science Department, University of Alberta, Edmonton, AB, Canada; Computing Science Department, University of Alberta, Edmonton, AB, Canada","21st IEEE International Conference on Software Maintenance (ICSM'05)","21 Nov 2005","2005","","","621","624","Object-oriented software is usually developed through evolutionary processes. To consistently evolve a system, developers have to understand the rationale behind its current design and the evolution trajectory that has led to it. In this paper, we present a method for analyzing the design evolution of object-oriented software systems, for the purpose of providing relevant advice to developers. This method relies on UMLDiff, a heuristic UML-structure differencing algorithm, which, given a sequence of UML class models corresponding to the logical design of a sequence of system code versions, produces a sequence of ""change trees"" that describe the design-level structural changes between subsequent system versions. A set of design-evolution patterns are then analyzed to understand the rationale underlying design decisions that may affect the software system. We demonstrate how the recovered knowledge provides the basis for mentoring the developers on future maintenance activities.","1063-6773","0-7695-2368-4","10.1109/ICSM.2005.95","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1510159","","Employee welfare;Software systems;Unified modeling language;Object oriented modeling;History;Algorithm design and analysis;Documentation;XML;Heuristic algorithms;Pattern analysis","object-oriented programming;object-oriented methods;Unified Modeling Language;software prototyping;software maintenance","experience-based mentoring;evolutionary development;object-oriented software;object-oriented software system design evolution;UMLDiff;UML-structure differencing algorithm;UML class model sequence;design-evolution pattern;software maintenance","","6","","17","IEEE","21 Nov 2005","","","IEEE","IEEE Conferences"
"A case study in refactoring a legacy component for reuse in a product line","R. Kolb; D. Muthig; T. Patzke; K. Yamauchi","Fraunhofer Institute of Experimental Software Engineering (IESE), Kaiserslautern, Germany; Fraunhofer Institute of Experimental Software Engineering (IESE), Kaiserslautern, Germany; Fraunhofer Institute of Experimental Software Engineering (IESE), Kaiserslautern, Germany; Ricoh Company Limited, Minato, Tokyo, Japan","21st IEEE International Conference on Software Maintenance (ICSM'05)","21 Nov 2005","2005","","","369","378","This paper describes activities performed to systematically improve the design and implementation of an existing software component in order to reuse it in a software product line. The activities are embedded in the application of Fraunhofer's PuLSE/spl trade/-DSSA approach for defining the architecture of a new product line. The component under investigation is the so called image memory handler (IMH) which is used in Ricoh's current products of office appliances such as copier machines, printers, and multi-functional peripherals. It is responsible for controlling memory usage and compressing and decompressing image data. Both the improvement of the component's design and implementation are based on a systematic analysis and focused on increasing maintainability and reusability and hence suitability for use in a product line.","1063-6773","0-7695-2368-4","10.1109/ICSM.2005.5","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1510132","","Computer aided software engineering;Software engineering;Computer architecture;Software maintenance;Software reusability;Software performance;Costs;Maintenance engineering;Application software;Home appliances","software reusability;software maintenance;object-oriented programming","legacy component refactoring;software product line;software component;PuLSE/spl trade/-DSSA approach;image memory handler;software reuse","","30","","18","IEEE","21 Nov 2005","","","IEEE","IEEE Conferences"
"The role of refactorings in API evolution","D. Dig; R. Johnson","University of Illinois, Urbana-Champaign, Urbana, IL, USA; University of Illinois, Urbana-Champaign, Urbana, IL, USA","21st IEEE International Conference on Software Maintenance (ICSM'05)","21 Nov 2005","2005","","","389","398","Frameworks and libraries change their APIs. Migrating an application to the new API is tedious and disrupts the development process. Although some tools and ideas have been proposed to solve the evolution of APIs, most updates are done manually. To better understand the requirements for migration tools we studied the API changes of three frameworks and one library. We discovered that the changes that break existing applications are not random, but they tend to fall into particular categories. Over 80% of these changes are refactorings. This suggests that refactoring-based migration tools should be used to update applications.","1063-6773","0-7695-2368-4","10.1109/ICSM.2005.90","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1510134","","Application software;Software libraries;Software maintenance;Programming profession;Computer science;Software systems;Costs;Computer languages;Operating systems","application program interfaces;software prototyping;software libraries;software tools;software maintenance","API evolution;refactoring-based migration tools","","74","","28","IEEE","21 Nov 2005","","","IEEE","IEEE Conferences"
"Improved tool support for the investigation of duplication in software","C. Kapser; M. W. Godfrey","Software Architecture Group (SWAG), School of Computer Science, University of Waterloo, Canada; Software Architecture Group (SWAG), School of Computer Science, University of Waterloo, Canada","21st IEEE International Conference on Software Maintenance (ICSM'05)","21 Nov 2005","2005","","","305","314","Code duplication is a well documented problem in software systems. There has been considerable research into techniques for detecting duplication in software, and there are several effective tools to perform this task. However, a common problem with such tools is that the result set returned can be too large to handle without complementary tool support. The goal of this paper is to describe the criteria for a complete tool that is designed to aid in the comprehension of cloning within a software system. Furthermore, we present a prototype of such a tool and demonstrate the value of its features through a case study on the Apache httpd Web server. For example, in our study we found that a single subsystem comprising only 17% of the system code contained 38.8% of the clones.","1063-6773","0-7695-2368-4","10.1109/ICSM.2005.52","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1510126","","Software tools;Cloning;Software systems;Software prototyping;Filtering;Navigation;Software architecture;Computer science;Software performance;Prototypes","software tools;software maintenance","software duplication;code duplication;software systems cloning;Apache httpd Web server;software tool support","","28","","25","IEEE","21 Nov 2005","","","IEEE","IEEE Conferences"
"A category-theoretic approach to syntactic software merging","N. Niu; S. Easterbrook; M. Sabetzadeh","Department of Computer Science, University of Toronto, Toronto, ONT, Canada; Department of Computer Science, University of Toronto, Toronto, ONT, Canada; Department of Computer Science, University of Toronto, Toronto, ONT, Canada","21st IEEE International Conference on Software Maintenance (ICSM'05)","21 Nov 2005","2005","","","197","206","Software merging is a common and essential activity during the lifespan of large-scale software systems. Traditional textual merge techniques are inadequate for detecting syntactic merge conflicts. In this paper, we propose a domain-independent approach for syntactic software merging that exploits the graph-based structure(s) of programs. We use morphisms between fuzzy graphs to capture the relationships between the structural elements of the programs to be merged, and apply a truth ordering lattice to express inconsistencies and evolutionary properties as we compute the merge. We demonstrate the approach with a three-way consolidation merge in a commercial software system; in particular, we show how analyzing merged call structures can help developers gain a better understanding and control of software evolution.","1063-6773","0-7695-2368-4","10.1109/ICSM.2005.6","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1510116","","Merging;Software systems;Software maintenance;Reverse engineering;Large-scale systems;Lattices;Fuzzy sets;Application software;Computer science;Control systems","configuration management;category theory;software maintenance;graph theory;fuzzy set theory","category-theoretic approach;syntactic software merging;large-scale software system;textual merge techniques;domain-independent approach;graph-based structure;fuzzy graph","","12","3","22","IEEE","21 Nov 2005","","","IEEE","IEEE Conferences"
"The conceptual cohesion of classes","A. Marcus; D. Poshyvanyk","Department of Computer Science, Wayne State University, Detroit, MI, USA; Department of Computer Science, Wayne State University, Detroit, MI, USA","21st IEEE International Conference on Software Maintenance (ICSM'05)","21 Nov 2005","2005","","","133","142","While often defined in informal ways, software cohesion reflects important properties of modules in a software system. Cohesion measurement has been used for quality assessment, fault proneness prediction, software modularization, etc. Existing approaches to cohesion measurement in object-oriented software are largely based on the structural information of the source code, such as attribute references in methods. These measures reflect particular interpretations of cohesion and try to capture different aspects of cohesion and no single cohesion metric or suite is accepted as standard measurement for cohesion. The paper proposes a new set of measures for the cohesion of individual classes within an OO software system, based on the analysis of the semantic information embedded in the source code, such as comments and identifiers. A case study on open source software is presented, which compares the new measures with an extensive set of existing metrics. The differences and similarities among the approaches and results are discussed and analyzed.","1063-6773","0-7695-2368-4","10.1109/ICSM.2005.89","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1510110","","Software measurement;Software quality;Open source software;Software systems;Particle measurements;Software reusability;Computer science;Quality assessment;Measurement standards;Information analysis","object-oriented programming;software libraries;software metrics","conceptual cohesion;software quality assessment;fault proneness prediction;software modularization;object-oriented software cohesion measurement;OO software system classes;open source software","","73","1","36","IEEE","21 Nov 2005","","","IEEE","IEEE Conferences"
"Automated refactoring of object oriented code into aspects","D. Binkley; M. Ceccato; M. Harman; F. Ricca; P. Tonella","Loyola College, MD, USA; ITC IRST, Trento, Italy; King''s College Hospital Medical School, London, UK; ITC IRST, Trento, Italy; ITC IRST, Trento, Italy","21st IEEE International Conference on Software Maintenance (ICSM'05)","21 Nov 2005","2005","","","27","36","This paper presents a human-guided automated approach to refactoring object oriented programs to the aspect oriented paradigm. The approach is based upon the iterative application of four steps: discovery, enabling, selection, and refactoring. After discovering potentially applicable refactorings, the enabling step transforms the code to improve refactorability. During the selection phase the particular refactorings to apply are chosen. Finally, the refactoring phase transforms the code by moving the selected code to a new aspect. This paper presents the results of an evaluation in which one of the crosscutting concerns of a 40,000 LoC program (JHotDraw) is refactored.","1063-6773","0-7695-2368-4","10.1109/ICSM.2005.27","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1510100","","Lab-on-a-chip;Java;Automation;Educational institutions;Functional programming;Application software;Software maintenance;Costs;Humans;Prototypes","object-oriented programming;systems re-engineering","object oriented program;aspect oriented paradigm;iterative method;automated refactoring","","25","1","27","IEEE","21 Nov 2005","","","IEEE","IEEE Conferences"
"Pointer analysis for source-to-source transformations","M. Buss; S. A. Edwards; Bin Yao; D. Waddington","Department of Computer Science, Columbia University, New York, NY, USA; Department of Computer Science, Columbia University, New York, NY, USA; Network Platforms Research Group, Lucent Technologies, Bell Laboratories, Holmdel, NJ, USA; Network Platforms Research Group, Lucent Technologies, Bell Laboratories, Holmdel, NJ, USA","Fifth IEEE International Workshop on Source Code Analysis and Manipulation (SCAM'05)","21 Nov 2005","2005","","","139","148","We present a pointer analysis algorithm designed for source-to-source transformations. Existing techniques for pointer analysis apply a collection of inference rules to a dismantled intermediate form of the source program, making them difficult to apply to source-to-source tools that generally work on abstract syntax trees to preserve details of the source program. Our pointer analysis algorithm operates directly on the abstract syntax tree of a C program and uses a form of standard dataflow analysis to compute the desired points-to information. We have implemented our algorithm in a source-to-source translation framework and experimental results show that it is practical on real-world examples.","","0-7695-2292-0","10.1109/SCAM.2005.20","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1541166","","Algorithm design and analysis;Inference algorithms;Information analysis;Resource management;Computer science;Data analysis;Application software;Runtime;Scheduling;Target tracking","program interpreters;C language;reverse engineering;program diagnostics","pointer analysis;source-to-source transformations;inference rules;abstract syntax trees;C program;dataflow analysis;source-to-source translation","","4","","19","IEEE","21 Nov 2005","","","IEEE","IEEE Conferences"
"Transforming embedded Java code into custom tags","S. Xu; T. Dean","Queen''s University, Kingston, Canada; Queen''s University, Kingston, Canada","Fifth IEEE International Workshop on Source Code Analysis and Manipulation (SCAM'05)","21 Nov 2005","2005","","","173","182","When a new technology is introduced, the migration of existing applications to the new technology must be carefully considered. Automation can make some migrations feasible that otherwise may be too risky or expensive to be worth the advantages of the new technology. In this paper we describe a technique for migrating Web applications using embedded Java code into a custom tag implementation. The technique uses source code transformation techniques to analyze and separate the Java from the Web pages. The code is then automatically transformed to custom Java classes which are invoked from the modified Web pages containing custom tags. The result is a Web application with identical function and appearance, but where the business logic (the Java code) has been separated from the presentation (the Web pages).","","0-7695-2292-0","10.1109/SCAM.2005.27","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1541169","","Java;Technical Activities Guide -TAG;HTML;Web pages;Logic;Application software;Automation;Costs;Software prototyping;Prototypes","program interpreters;Internet;Java","embedded Java code transformation;custom tags;Web applications;source code transformation;Web pages","","3","","15","IEEE","21 Nov 2005","","","IEEE","IEEE Conferences"
"Control flow graph reconstruction for assembly language programs with delayed instructions","N. Bermudo; A. Krall; N. Horspool","Christian Doppler Laboratory, Institut für Computersprachen, Technische Universität Wien, Austria; Christian Doppler Laboratory, Institut für Computersprachen, Technische Universität Wien, Austria; Department of Computer Science, University of Victoria, Canada","Fifth IEEE International Workshop on Source Code Analysis and Manipulation (SCAM'05)","21 Nov 2005","2005","","","107","116","Most software for embedded systems, including digital signal processing systems, is coded in assembly language. For both understanding the software and for reverse compiling it to a higher level language, we need to construct a control flow graph (CFG). However CFG construction is complicated by architectural features which include VLIW parallelism, predicated instructions and branches with delay slots. We describe an efficient algorithm for the construction of a CFG, where the parallelism has been eliminated, instructions are reordered and delay slots have been eliminated. The algorithm's effectiveness has been demonstrated by its use in a reverse compiler for the Texas Instruments C60 series of digital signal processors.","","0-7695-2292-0","10.1109/SCAM.2005.6","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1541163","","Flow graphs;Delay;Signal processing algorithms;Embedded software;Software systems;Embedded system;Digital signal processing;Assembly systems;VLIW;Instruments","program control structures;assembly language;instruction sets;delays;reverse engineering;program compilers;flow graphs","control flow graph reconstruction;assembly language programs;delayed instructions;software understanding;reverse compiling;VLIW parallelism;Texas Instruments C60 series;digital signal processors","","4","4","15","IEEE","21 Nov 2005","","","IEEE","IEEE Conferences"
"Extending dynamic aspect mining with static information","S. Breu","University of Passau, Passau, Germany","Fifth IEEE International Workshop on Source Code Analysis and Manipulation (SCAM'05)","21 Nov 2005","2005","","","57","65","Aspect mining tries to identify crosscutting concerns in legacy systems and thus supports the refactoring into an aspect-oriented design. We briefly introduce DynAMiT, a dynamic aspect mining tool that detects crosscutting concerns based on tracing method executions. While the approach is generally fairly precise, further analysis revealed that some false positives were systematically caused by dynamic binding. Furthermore, some aspect candidates were blurred or not detected due to not-sufficient tracing mechanisms of method executions when using AspectJ's execution pointcuts for the trace generation. We enhanced the mining capabilities of DynAMiT by taking additional static type information into account and generating the traces using call pointcuts instead. In an initial case study with AnChoVis, a 1300 LOC Java program, the number of mined aspect candidates increased by a factor of three, while the number of false positives remained zero.","","0-7695-2292-0","10.1109/SCAM.2005.9","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1541158","","Software systems;Java;Runtime;Electronic mail;Lab-on-a-chip;Buildings;Conferences","software maintenance;data mining;object-oriented programming","legacy systems;aspect-oriented design;DynAMiT;dynamic aspect mining tool;method execution tracing;call pointcuts;AnChoVis","","6","","20","IEEE","21 Nov 2005","","","IEEE","IEEE Conferences"
"On the use of clone detection for identifying crosscutting concern code","M. Bruntink; A. van Deursen; R. van Engelen; T. Tourwe","Department of Software Engineering, Amsterdam, SJ, The Netherlands; Department of Software Engineering, Amsterdam, SJ, The Netherlands; Software Systems Development, Veldhoven, DR, The Netherlands; Department of Software Engineering, Amsterdam, SJ, The Netherlands","IEEE Transactions on Software Engineering","21 Nov 2005","2005","31","10","804","818","In systems developed without aspect-oriented programming, code implementing a crosscutting concern may be spread over many different parts of a system. Identifying such code automatically could be of great help during maintenance of the system. First of all, it allows a developer to more easily find the places in the code that must be changed when the concern changes and, thus, makes such changes less time consuming and less prone to errors. Second, it allows the code to be refactored to an aspect-oriented solution, thereby improving its modularity. In this paper, we evaluate the suitability of clone detection as a technique for the identification of crosscutting concerns. To that end, we manually identify five specific crosscutting concerns in an industrial C system and analyze to what extent clone detection is capable of finding them. We consider our results as a stepping stone toward an automated ""aspect miner"" based on clone detection.","1939-3520","","10.1109/TSE.2005.114","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1542064","Index Terms- Clone detection;reverse engineering;aspect-oriented programming;crosscutting concerns;aspect mining.","Cloning;Scattering;Computer languages;Computer Society;Reverse engineering;Software systems;Programming;Automation;Application software","object-oriented programming;object-oriented methods;software maintenance;reverse engineering","clone detection;crosscutting concern code;system maintenance;aspect-oriented solution;industrial C system;aspect miner","","74","","38","IEEE","21 Nov 2005","","","IEEE","IEEE Journals"
"Analyzing the evolutionary history of the logical design of object-oriented software","Z. Xing; E. Stroulia","Computing Science Department, University of Alberta, Edmonton, AB, Canada; Computing Science Department, University of Alberta, Edmonton, AB, Canada","IEEE Transactions on Software Engineering","21 Nov 2005","2005","31","10","850","868","Today, most object-oriented software systems are developed using an evolutionary process model. Therefore, understanding the phases that the system's logical design has gone through and the style of their evolution can provide valuable insights in support of consistently maintaining and evolving the system, without compromising the integrity and stability of its architecture. In this paper, we present a method for analyzing the evolution of object-oriented software systems from the point of view of their logical design. This method relies on UMLDiff, a UML-structure differencing algorithm, which, given a sequence of UML class models corresponding to the logical design of a sequence of system code releases, produces a sequence of ""change records"" that describe the design-level changes between subsequent system releases. This change-records sequence is subsequently analyzed from the perspective of each individual system class, to produce the class-evolution profile, i.e., a class-specific change-records' sequence. Three types of longitudinal analyses - phasic, gamma, and optimal matching analysis - are applied to the class-evolution profiles to recover a high-level abstraction of distinct evolutionary phases and their corresponding styles and to identify class clusters with similar evolution trajectories. The recovered knowledge facilitates the overall understanding of system evolution and the planning of future maintenance activities. We report on one real-world case study evaluating our approach.","1939-3520","","10.1109/TSE.2005.106","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1542067","Index Terms- Restructuring;reverse engineering;and reengineering.","History;Software design;Software systems;Object oriented modeling;Algorithm design and analysis;Surges;Quality management;Project management;Visualization;Documentation","object-oriented programming;object-oriented methods;Unified Modeling Language;software maintenance;software architecture;reverse engineering","object-oriented software system;evolutionary process model;system logical design;UMLDiff;UML-structure differencing algorithm;phasic analysis;gamma analysis;optimal matching analysis;software maintenance","","48","","41","IEEE","21 Nov 2005","","","IEEE","IEEE Journals"
"Refactoring the aspectizable interfaces: an empirical assessment","P. Tonella; M. Ceccato","Centro per la Ricerca Scientifica e Tecnologica, ITC IRST, Trento, Italy; Centro per la Ricerca Scientifica e Tecnologica, ITC IRST, Trento, Italy","IEEE Transactions on Software Engineering","21 Nov 2005","2005","31","10","819","832","Aspect oriented programming aims at addressing the problem of the crosscutting concerns, i.e., those functionalities that are scattered among several modules in a given system. Aspects can be defined to modularize such concerns. In this work, we focus on a specific kind of crosscutting concerns, the scattered implementation of methods declared by interfaces that do not belong to the principal decomposition. We call such interfaces aspectizable. All the aspectizable interfaces identified within a large number of classes from the Java Standard Library and from three Java applications have been automatically migrated to aspects. To assess the effects of the migration on the internal and external quality attributes of these systems, we collected a set of metrics and we conducted an empirical study, in which some maintenance tasks were executed on the two alternative versions (with and without aspects) of the same system. In this paper, we report the results of such a comparison.","1939-3520","","10.1109/TSE.2005.115","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1542065","Index Terms- Aspect oriented programming;refactoring;program transformations;empirical studies.","Scattering;Java;Functional programming;Libraries;Object oriented programming;Packaging;Containers","object-oriented programming;software metrics;Java;software libraries;software quality;software maintenance;application program interfaces","aspectizable interfaces;aspect oriented programming;crosscutting concerns;Java Standard Library;software metrics;software maintenance","","26","","38","IEEE","21 Nov 2005","","","IEEE","IEEE Journals"
"Measuring fine-grained change in software: towards modification-aware change metrics","D. M. German; A. Hindle","Software Engineering Group, Department fo Computer Science, University of Victoria, Canada; Software Engineering Group, Department fo Computer Science, University of Victoria, Canada","11th IEEE International Software Metrics Symposium (METRICS'05)","24 Oct 2005","2005","","","10 pp.","28","In this paper we propose the notion of change metrics, those that measure change in a project or its entities. In particular we are interested in measuring fine-grained changes, such as those stored by version control systems (such as CVS). A framework for the classification of change metrics is provided. We discuss the idea of change metrics which are modification aware, that is metrics which evaluate the change itself and not just the change in a measurement of the system before and after the change. We then provide examples of the use of these metrics on two mature projects","1530-1435","0-7695-2371-4","10.1109/METRICS.2005.32","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1509306","","Software measurement;Time measurement;Software systems;Open source software;Control systems;Data visualization;Software engineering;Computer science;Particle measurements;Research and development management","configuration management;software metrics","software change;software metrics;version control systems;change metrics classification;modification aware change metrics;change evaluation","","10","1","20","IEEE","24 Oct 2005","","","IEEE","IEEE Conferences"
"On refactoring support based on code clone dependency relation","N. Yoshida; Y. Higo; T. Kamiya; S. Kusumoto; K. Inoue","Graduate School of Information Science and Technology, Osaka University, Japan; Graduate School of Information Science and Technology, Osaka University, Japan; National Institute for Advanced Industrial Science and Technology, Japan; Graduate School of Information Science and Technology, Osaka University, Japan; Graduate School of Information Science and Technology, Osaka University, Japan","11th IEEE International Software Metrics Symposium (METRICS'05)","24 Oct 2005","2005","","","10 pp.","16","Generally, code clones are regarded as one of the factors that make software maintenance more difficult. A code clone is a set of source code fragments identical or similar to each other from the viewpoint of software maintainability, code clones should be removed. However, sometimes there are dependency relations among each of which belong to the different code clone, and it is advisable to refactor all of such code clones at once. In this paper, we focus on the case that such code fragment corresponds to a method body in Java programs. We defined ""chained method"" as a set of methods that have dependency relations. A set of ""chained methods"" whose elements are each other's code clone is called ""chained clone"", and an equivalence class of ""chained clone"" is called a ""chained clone set"". We propose a refactoring support method for ""chained clone set"" by providing an appropriate refactoring pattern to them. Finally, we present the ""chained clone set"" refactoring support tool that we have developed, together with some case studies to show the usefulness of the proposed method","1530-1435","0-7695-2371-4","10.1109/METRICS.2005.36","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1509294","","Cloning;Software maintenance;Java;Application software;Information science;Computer industry;Industrial relations;Large-scale systems;Software tools;Open source software","equivalence classes;Java;object-oriented programming;reverse engineering;software maintenance","code clone dependency relation;software maintenance;source code fragments;Java programs;chained method;equivalence class;refactoring pattern","","13","1","13","IEEE","24 Oct 2005","","","IEEE","IEEE Conferences"
"REGoLive: building a Web site comprehension tool by extending GoLive","G. Gui; H. M. Kienle; H. A. Muller","Department of Computer Science, University of Victoria, Canada; Department of Computer Science, University of Victoria, Canada; Department of Computer Science, University of Victoria, Canada","Seventh IEEE International Symposium on Web Site Evolution","17 Oct 2005","2005","","","46","53","Traditionally, program comprehension functionality is implemented with stand-alone tools. As a result, software engineers typically have to switch between various tools during comprehension activities. Each of these tools has its own idiosyncratic user interface and interaction paradigm, causing an unfavorable learning curve. As a result, many program comprehension tools fail to be adopted. Software engineering activities that involve program comprehension (e.g., maintenance) require the use of forward engineering tools (e.g., compilers) as well as reverse engineering tools (e.g., class hierarchy visualizers). Thus, extending forward engineering tools such as IDEs (e.g., Eclipse) or Web authoring tools (e.g., GoLive) by seamlessly adding program comprehension functionality helps software engineers and improves the adoption of comprehension functionality. In this paper, we introduce an adoption-centric tool development approach that leverages a Web authoring tool, GoLive, by grafting functionality for Web site comprehension on top. The benefits and drawbacks of this approach from the tool-user's as well as the tool-builder's perspective are discussed.","1550-4441","0-7695-2470-2","10.1109/WSE.2005.11","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1517980","","Reverse engineering;HTML;Software tools;Switches;Software engineering;Program processors;Visualization;Software systems;Software maintenance;Navigation","authoring systems;Web sites;reverse engineering","REGoLive;Web site comprehension tool;program comprehension;software engineering;forward engineering tool;reverse engineering tool;Web authoring tool;adoption-centric tool development approach;tool-user perspective;tool-builder perspective","","4","","32","IEEE","17 Oct 2005","","","IEEE","IEEE Conferences"
"Integrating static and dynamic analysis to improve the comprehension of existing Web applications","G. A. Di Lucca; M. Di Penta","RCOST-Research Centre on Software Technology, University of Sannio, Italy; RCOST-Research Centre on Software Technology, University of Sannio, Italy","Seventh IEEE International Symposium on Web Site Evolution","17 Oct 2005","2005","","","87","94","Web applications are today becoming more and more interactive and dynamic: the pages rendered in a browser on the client side can be dynamically built by server pages according to the user inputs or requests. Moreover, even pieces of code (e.g., client-side scripts) can be dynamically generated. The comprehension of such applications, needed to effectively perform maintenance or testing, may be very hard. Indeed, for highly dynamic Web applications, static analysis is likely to give only an imprecise and approximate picture, thus, also dynamic analysis is required to gain a proper understanding of complex and dynamic application behavior. This paper presents the integration and the enhancement of two existing Web application reverse engineering tools: one, WARE, performing static analysis, the other, WANDA, dynamic analysis. In particular, the paper shows how the integrated toolkit can be used to identify equivalence classes from groups of dynamically built client pages, with the aim of improving comprehension. To validate the proposed approach, results from a case study are presented and discussed.","1550-4441","0-7695-2470-2","10.1109/WSE.2005.8","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1517985","","Application software;Performance analysis;Testing;Reverse engineering;HTML;Failure analysis;Instruments;Business continuity;Performance evaluation;Web pages","program diagnostics;Internet;authoring systems;reverse engineering;client-server systems","static analysis;dynamic analysis;Web application comprehension;reverse engineering tool;WARE tool;WANDA tool;equivalence classes;client page","","17","2","18","IEEE","17 Oct 2005","","","IEEE","IEEE Conferences"
"Towards evolving Web sites into grid services environment","Jianzhi Li; Hongji Yang","Software Technology Research Laboratory, De Montfort University, Leicester, UK; Software Technology Research Laboratory, De Montfort University, Leicester, UK","Seventh IEEE International Symposium on Web Site Evolution","17 Oct 2005","2005","","","95","102","Grid services are emerged by integrating grid computing and Web services to perform a seamless information processing system across distributed, heterogeneous, dynamic virtual organisations that the user can access from any location. The Web Service Resource Framework (WSRF) was announced as a new way for manipulating ""stateful resources"" to perform grid services. It defines the concept of ""stateful resources"" and how they can be discovered, queried and manipulated via Web services. In this paper, we proposed a grid services-oriented reengineering approach to create stateful resources from conventional HTML Web sites, which applies hierarchical cluster and wrapper techniques to extract and translate Web sites resources. It supports services identification and packaging and archives Web site evolution into grid services environment by exploiting WRSF.","1550-4441","0-7695-2470-2","10.1109/WSE.2005.20","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1517986","","Web services;HTML;Grid computing;Information processing;Data mining;XML;Software performance;Laboratories;Packaging;Computer applications","grid computing;Web sites;systems re-engineering;formal specification","archives Web site evolution;grid services-oriented reengineering approach;grid computing;Web Service Resource Framework;stateful resources;hierarchical cluster;wrapper techniques;service identification;service packaging","","1","","24","IEEE","17 Oct 2005","","","IEEE","IEEE Conferences"
"Modernizing JavaServer Pages by Transformation","Shannon Xu; T. Dean","Queen''s University, Kingston, ONT, Canada; Queen''s University, Kingston, ONT, Canada","Seventh IEEE International Symposium on Web Site Evolution","17 Oct 2005","2005","","","111","118","One way to improve the maintainability of a web application is to separate its presentation from the business logic. Such separation not only makes a web application easier to evolve and maintain, but also allows individual developers with different skills to cooperate more efficiently. Custom tags are a recent addition to the JSP standard that helps to facilitate this separation. In this paper, we present a transform to restructure JSP pages by moving embedded Java code into custom tags without changing the original functionality or user interface. This reduces the complexity of the web applications, makes them more maintainable and makes best use different skill sets.","1550-4441","0-7695-2470-2","10.1109/WSE.2005.9","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1517988","","Java;HTML;Libraries;Logic;User interfaces;XML;Visual BASIC;Software prototyping;Prototypes;Debugging","Internet;Java;software maintenance;systems re-engineering","JavaServer page modernization;Web application maintainability;custom tags;JSP page restructuring","","2","1","21","IEEE","17 Oct 2005","","","IEEE","IEEE Conferences"
"Crosscutting concerns in J2EE applications","A. Mesbah; A. van Deursen","Centrum voor Wiskunde en Informatica, Netherlands; Centrum voor Wiskunde en Informatica, Netherlands","Seventh IEEE International Symposium on Web Site Evolution","17 Oct 2005","2005","","","14","21","We explore the evolution benefits of adopting aspects in a J2EE setting by studying crosscutting concerns in a typical J2EE application. To identify these concerns, we take a top-down as well as a bottom-up approach. In the top-down view we focus on typical concerns that are known to be crosscutting (e.g., persistence), the way they are currently implemented and the possible gains and benefits if solved by aspects. In the bottom-up approach we take a look at the application's source code, and apply aspect mining techniques in order to find crosscutting concerns. We discuss how such concerns can be represented in an aspect-oriented language (viz. AspectJ), and reflect on the results in terms of maintainability and evolvability of the affected system.","1550-4441","0-7695-2470-2","10.1109/WSE.2005.4","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1517976","","Java;Containers;Scattering;Positron emission tomography;HTML;Logic;Management information systems;Programming;Software systems;Software development management","Java;object-oriented programming;software prototyping;software maintenance","crosscutting concerns;J2EE application;top-down approach;bottom-up approach;aspect mining techniques;aspect-oriented language;system maintainability;system evolvability;AspectJ","","9","","20","IEEE","17 Oct 2005","","","IEEE","IEEE Conferences"
"Quasi-static scheduling of independent tasks for reactive systems","J. Cortadella; A. Kondratyev; L. Lavagno; C. Passerone; Y. Watanabe","Universitat Poliltècnica de Catalunya, Barcelona, Spain; Cadence Berkeley Laboratories, San Jose, CA, USA; Politecnico di Torino, Turin, Italy; Politecnico di Torino, Turin, Italy; Cadence Berkeley Laboratories, San Jose, CA, USA","IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems","26 Sep 2005","2005","24","10","1492","1514","A reactive system must process inputs from the environment at the speed and with the delay dictated by the environment. The synthesis of reactive software from a modular concurrent specification model generates a set of concurrent tasks coordinated by an operating system. This paper presents a synthesis approach for reactive software that is aimed at minimizing the overhead introduced by the operating system and the interaction among the concurrent tasks. A formal model based on Petri nets is used to synthesize the tasks and verify the correctness of their composition. A practical application of the approach is illustrated by means of a real-life industrial example, which shows the significant impact of the approach on the performance of the system.","1937-4151","","10.1109/TCAD.2005.852038","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1512369","Petri nets;reactivesystems;scheduling;software synthesis;specification languages","Resource management;Job shop scheduling;Operating systems;Processor scheduling;Application software;Network synthesis;Embedded system;Central Processing Unit;Digital signal processing;Field programmable gate arrays","embedded systems;scheduling;concurrency control;formal specification;Petri nets","quasistatic scheduling;independent tasks;reactive systems;reactive software synthesis;modular concurrent specification model;concurrent tasks;operating system;formal model;Petri nets;specification languages","","17","1","22","IEEE","26 Sep 2005","","","IEEE","IEEE Journals"
"Analyzing the effectiveness of fault hardening procedures","P. Gawkowski; J. Sosnowski; B. Radko","Institute of Computer Science, Warsaw University of Technology, Warsaw, Poland; Institute of Computer Science, Warsaw University of Technology, Warsaw, Poland; Institute of Computer Science, Warsaw University of Technology, Warsaw, Poland","11th IEEE International On-Line Testing Symposium","6 Sep 2005","2005","","","14","19","The paper addresses the problem of evaluating the effectiveness of fault hardening procedures based on software redundancy. We analyze the time and memory overhead of fine-grained and coarse-grained error detection and correction techniques. We check the impact of the involved overhead on fault coverage. The presented considerations are illustrated with fault injection experimental results.","1942-9401","0-7695-2406-0","10.1109/IOLTS.2005.16","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1498123","","Testing","fault simulation;redundancy;software fault tolerance;error correction;error detection","fault hardening;software redundancy;time overhead;memory overhead;error detection;error correction;fault coverage;fault injection","","10","","21","IEEE","6 Sep 2005","","","IEEE","IEEE Conferences"
"Supporting demanding hard-real-time systems with STI","B. J. Welch; S. O. Kanaujia; A. Seetharam; D. Thirumalai; A. G. Dean","Wireless and Event Sensing Applications Department, Sandia National Laboratories, Albuquerque, NM, USA; Department of Electrical and Computer Engineering, North Carolina State University, Raleigh, NC, USA; NA; NA; Department of Electrical and Computer Engineering, North Carolina State University, Raleigh, NC, USA","IEEE Transactions on Computers","29 Aug 2005","2005","54","10","1188","1202","Software thread integration (STI) is a compilation technique which enables the efficient use of an application's fine-grain idle time on generic processors without special hardware support. With STI, a primary function is automatically interleaved with a secondary function to create a single implicitly multithreaded function which minimizes context switching and, hence, both improves performance and also offers very fine-grain concurrency. In this work, we extend STI techniques to address two challenges. First, we reduce response time for interrupts or other high-priority threads by introducing polling servers into integrated threads. Second, we enable integration with long host threads, expanding the domain of STI. We derive methods to evaluate the response time for threads in systems with and without these new integration methods. We demonstrate these concepts with the integration of various threads in a sample hard-real-time system on a highly-constrained microcontroller. We use an inexpensive 20 MHz AVR 8-bit microcontroller to generate monochrome NTSC video while servicing a high-speed (115,2 kbaud) serial communication link. We have built and tested this system, achieving graphics rendering speed-ups of 3.99/spl times/ to 13.5/spl times/.","1557-9956","","10.1109/TC.2005.169","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1501786","Index Terms- Software thread integration;embedded systems;fine-grain concurrency;post-pass compiler;hardware-to-software migration.","Microcontrollers;Real time systems;Program compilers","multi-threading;microcontrollers;real-time systems;program compilers;hardware-software codesign","hard-real-time system;software thread integration;fine-grain idle time;multithreaded function;highly-constrained microcontroller;AVR 8-bit microcontroller;monochrome NTSC video;serial communication link;post-pass compiler;hardware-to-software migration","","1","","55","IEEE","29 Aug 2005","","","IEEE","IEEE Journals"
"Dynamic component assessment on PvC environments","A. Flores; M. Polo","Department of Computer Science, University of Comahue, Neuquen, Argentina; Escuela Superior de Informática, Universidad de Castilla La Mancha, Ciudad Real, Spain","10th IEEE Symposium on Computers and Communications (ISCC'05)","15 Aug 2005","2005","","","955","960","We aim at automating an integration process for component-based systems. Hence we describe a reference model where its first phase (qualification) is our current work. We intend to compare components data by semantic analysis, i.e. interoperability at a semantic level. Assessment is based on meta-data added to components: their context, assertions, and interface protocol. In a previous work we showed a component interface matching. In this paper we explain the assertions matching, that uses a technique based on abstract syntax trees, which detects similar pieces of code ('clones'). We aim to enhance the procedure by a semantic component treatment using ontologies. Thus the whole assessment procedure is highly improved both on efficacy and reliability.","1530-1346","0-7695-2373-0","10.1109/ISCC.2005.56","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1493838","","Ontologies;Computer science;Qualifications;Data analysis;Protocols;Pervasive computing;Usability;Assembly;Information analysis;Cloning","meta data;protocols;tree data structures;ubiquitous computing","dynamic component assessment;semantic analysis;meta-data;interface protocol;assertions matching;abstract syntax trees;pervasive computing environment","","","","14","IEEE","15 Aug 2005","","","IEEE","IEEE Conferences"
"An anti-cloning framework for software defined radio mobile devices","A. Brawerman; J. A. Copeland","School of Electrical and Computer Engineering, Georgia Institute of Technology, Atlanta, GA, USA; School of Electrical and Computer Engineering, Georgia Institute of Technology, Atlanta, GA, USA","IEEE International Conference on Communications, 2005. ICC 2005. 2005","15 Aug 2005","2005","5","","3434","3438 Vol. 5","The superior reconfigurability of software defined radio mobile devices has made it the most promising technology on the wireless network and in the communication industry. Despite several advantages, there is still a lot to discuss regarding security. One of the more dangerous threats in SDR wireless communication is cloning. Besides illegal billing, cloned units increase the competition of shared resources, the network congestion and degrade network services. In this paper, an anti-cloning framework for software defined radio mobile devices is proposed. In the framework, the SDR mobile device together with the wireless operator is responsible for detecting if it has been cloned or not. Another key point is that the framework is independent of the wireless communication technology, working well for different cellular technologies and the Internet. New pieces of hardware and new protocols are specified to avoid network services being used by cloned units. Proofs that analyze correctness of the protocols and the framework are also presented.","1938-1883","0-7803-8938-7","10.1109/ICC.2005.1495058","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1495058","","Software radio;Wireless communication;Protocols;Wireless networks;Communication industry;Cloning;Degradation;Communications technology;Internet;Hardware","software radio;mobile radio;telecommunication security;protocols","anti-cloning framework;software defined radio mobile devices;reconfigurability;SDR-MD security protocols;wireless operator clone detection;wireless communication technology independent framework;cellular technologies;Internet;privacy","","4","","11","IEEE","15 Aug 2005","","","IEEE","IEEE Conferences"
"ShareMe: running a distributed systems lab for 600 students with three faculty members","C. Kerer; G. Reif; T. Gschwind; Engin Kirda; R. Kurmanowytsch; M. Paralic","University of Technology, Vienna, Vienna, Austria; University of Technology, Vienna, Vienna, Austria; IBM Zurich Research Laboratory, Zurich, Switzerland; University of Technology, Vienna, Vienna, Austria; Comprendium, Vienna, Austria; Technical University of Kosice, Slovakia","IEEE Transactions on Education","15 Aug 2005","2005","48","3","430","437","The goal of the distributed systems (DS) laboratory is to provide an attractive environment in which students learn about network programming and apply some fundamental concepts of distributed systems. In the last two years, students had to implement a fully functional peer-to-peer file sharing system called ShareMe. This paper presents the approach the authors used to provide the best possible support and guidance for the students while keeping up with ever-rising participant numbers in the laboratory course (approximately 600 last year), as well as managing budget and personnel constraints. The learning environment is based on Web and Internet technologies and not only offers the description of the laboratory tasks but also covers electronic submission, a discussion forum, automatic grading, and online access to grading and test results. The authors report their experiences of using the automated grading system, the amount of work required to prepare and run the laboratory, and how they deal with students who submit plagiarized solutions. Furthermore, the results of student feedback and evaluation forms are presented, and the overall student course satisfaction is discussed. Detailed information about the DS laboratory is available at http://www.dslab.tuwien.ac.at.","1557-9638","","10.1109/TE.2005.849740","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1495651","Automated grading;distributed systems;e-learning;peer-to-peer;web-based education","Computer aided instruction;Laboratories;Internet","computer aided instruction;laboratories;peer-to-peer computing;Internet;educational courses","ShareMe;distributed systems lab;network programming;peer-to-peer file sharing system;Web;Internet;automated grading system","","11","","14","IEEE","15 Aug 2005","","","IEEE","IEEE Journals"
"Flexible hardware abstraction for wireless sensor networks","V. Handziski; J. Polastre; J. . -H. Hauer; C. Sharp; A. Wolisz; D. Culler","Telecommunication Networks Group, Technische Universität Berlin, Berlin, Germany; Computer Science Department, University of California, Berkeley, CA, USA; Telecommunication Networks Group, Technische Universität Berlin, Berlin, Germany; Computer Science Department, University of California, Berkeley, CA, USA; Telecommunication Networks Group, Technische Universität Berlin, Berlin, Germany; Computer Science Department, University of California, Berkeley, CA, USA","Proceeedings of the Second European Workshop on Wireless Sensor Networks, 2005.","25 Jul 2005","2005","","","145","157","We present a flexible hardware abstraction architecture (HAA) that balances conflicting requirements of wireless sensor networks (WSNs) applications and the desire for increased portability and streamlined development of applications. Our three-layer design gradually adapts the capabilities of the underlying hardware platforms to the selected platform-independent hardware interface between the operating system core and the application code. At the same time, it allows the applications to utilize a platform's full capabilities-exported at the second layer, when the performance requirements outweigh the need for cross-platform compatibility. We demonstrate the practical value of our approach by presenting how it can be applied to the most important hardware modules that are found in a typical WSN platform. We support our claims using concrete examples from existing hardware abstractions in TinyOS and our implementation of the MSP430 platform that follows the architecture proposed in this paper.","","0-7803-8801-1","10.1109/EWSN.2005.1462006","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1462006","","Hardware;Wireless sensor networks;Operating systems;Application software;Energy efficiency;Computer science;Computer architecture;Concrete;Impedance;Energy resolution","wireless sensor networks;operating systems (computers);computer architecture","flexible hardware abstraction architecture;HAA;wireless sensor network;WSN;platform-independent hardware interface;operating system core;application code;TinyOS;MSP430 platform","","40","4","19","IEEE","25 Jul 2005","","","IEEE","IEEE Conferences"
"Automatic mining of source code repositories to improve bug finding techniques","C. C. Williams; J. K. Hollingsworth","University of Maryland, College Park, MD, USA; University of Maryland, College Park, MD, USA","IEEE Transactions on Software Engineering","11 Jul 2005","2005","31","6","466","480","We describe a method to use the source code change history of a software project to drive and help to refine the search for bugs. Based on the data retrieved from the source code repository, we implement a static source code checker that searches for a commonly fixed bug and uses information automatically mined from the source code repository to refine its results. By applying our tool, we have identified a total of 178 warnings that are likely bugs in the Apache Web server source code and a total of 546 warnings that are likely bugs in Wine, an open-source implementation of the Windows API. We show that our technique is more effective than the same static analysis that does not use historical data from the source code repository.","1939-3520","","10.1109/TSE.2005.63","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1463230","Index Terms- Testing tools;version control;configuration control;debugging aids.","Computer bugs;Web server;Inspection;Detectors;History;Data mining;Information retrieval;Open source software;Debugging;Programming profession","data mining;Internet;application program interfaces;program testing;configuration management;public domain software;program diagnostics;program debugging;file servers","automatic mining;source code repository;bug finding technique;software project;data retrieval;static source code checker;Apache Web server;open-source implementation;Windows API;static analysis;historical data;testing tools;version control;configuration control;debugging aids","","108","10","31","IEEE","11 Jul 2005","","","IEEE","IEEE Journals"
"Lightweight Morphing Support for Evolving Middleware Data Exchanges in Distributed Applications","S. Agarwala; G. Eisenhauer; K. Schwan","College of Computing, Georgia Institute of Technology, Atlanta, GA, USA; College of Computing, Georgia Institute of Technology, Atlanta, GA, USA; College of Computing, Georgia Institute of Technology, Atlanta, GA, USA","25th IEEE International Conference on Distributed Computing Systems (ICDCS'05)","20 Jun 2005","2005","","","697","706","Most systems must evolve as their missions or roles change and/or as they adapt to new execution environments. When evolving large distributed applications, it is particularly difficult to make changes to the data formats that underlie their components' communications, because such 'format evolution' can affect all or many application components. Prior approaches to the problem of implementing changes in the communications of a deployed system have relied upon ad-hoc solutions or on protocol negotiation to avoid message format mismatches. Unfortunately, such solutions tend to increase the complexity of application code. This paper presents a novel approach to the problem of data format evolution that combines meta-data about the data being exchanged with dynamic binary code generation to create a robust data exchange system that naturally supports application evolution. The idea is to specialize the communications of application components by dynamically generating the code that can automatically transform incoming data into forms that receiving components can understand. A realistic example in the context of publish/subscribe middleware is used to illustrate how this technique can be applied to enhance interoperability between different version of distributed applications","1063-6927","0-7695-2331-5","10.1109/ICDCS.2005.45","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1437130","","Middleware;Distributed computing;Large-scale systems;Data structures;Educational institutions;Binary codes;Robustness;Context;Wireless application protocol;Hardware","binary codes;electronic data interchange;middleware;object-oriented programming;protocols","lightweight morphing support;evolving middleware data exchanges;distributed application;application components;protocol negotiation;data format evolution;meta data;binary code generation","","4","2","35","IEEE","20 Jun 2005","","","IEEE","IEEE Conferences"
"Improving program efficiency by packing instructions into registers","S. Hines; J. Green; G. Tyson; D. Whalley","Computer Science Department, Florida State University, Tallahassee, FL, USA; Computer Science Department, Florida State University, Tallahassee, FL, USA; Computer Science Department, Florida State University, Tallahassee, FL, USA; Computer Science Department, Florida State University, Tallahassee, FL, USA","32nd International Symposium on Computer Architecture (ISCA'05)","20 Jun 2005","2005","","","260","271","New processors, both embedded and general purpose, often have conflicting design requirements involving space, power, and performance. Architectural features and compiler optimizations often target one or more design goals at the expense of the others. This paper presents a novel architectural and compiler approach to simultaneously reduce power requirements, decrease code size, and improve performance by integrating an instruction register file (IRF) into the architecture. Frequently occurring instructions are placed in the IRF. Multiple entries in the IRF can be referenced by a single packed instruction in ROM or LI instruction cache. Unlike conventional code compression, our approach allows the frequent instructions to be referenced in arbitrary combinations. The experimental results show significant improvements in space and power, as well as some improvement in execution time when using only 32 entries. These advantages make packing instructions into registers an effective approach for improving overall efficiency.","1063-6897","0-7695-2270-X","10.1109/ISCA.2005.32","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1431562","","Read only memory;Registers;Encoding;Design optimization;Optimizing compilers;Energy consumption;Costs;Process design;Logic;Instruction sets","instruction sets;cache storage;embedded systems;computer architecture;optimising compilers","registers;architectural features;compiler optimizations;instruction register file;single packed instruction;ROM;LI instruction cache;code compression","","15","1","25","IEEE","20 Jun 2005","","","IEEE","IEEE Conferences"
"Design and evaluation of hybrid fault-detection systems","G. A. Reis; J. Chang; N. Vachharajani; S. S. Mukherjee; R. Rangan; D. I. August","Departments of Electrical Engineering and Computer Science, Princeton University, Princeton, NJ, USA; Departments of Electrical Engineering and Computer Science, Princeton University, Princeton, NJ, USA; Departments of Electrical Engineering and Computer Science, Princeton University, Princeton, NJ, USA; Departments of Electrical Engineering and Computer Science, Princeton University, Princeton, NJ, USA; Departments of Electrical Engineering and Computer Science, Princeton University, Princeton, NJ, USA; FACT Group, Intel Massachusetts, Inc., Hudson, MA, USA","32nd International Symposium on Computer Architecture (ISCA'05)","20 Jun 2005","2005","","","148","159","As chip densities and clock rates increase, processors are becoming more susceptible to transient faults that can affect program correctness. Up to now, system designers have primarily considered hardware-only and software-only fault-detection mechanisms to identify and mitigate the deleterious effects of transient faults. These two fault-detection systems, however, are extremes in the design space, representing sharp trade-offs between hardware cost, reliability, and performance. In this paper, we identify hybrid hardware/software fault-detection mechanisms as promising alternatives to hardware-only and software-only systems. These hybrid systems offer designers more options to fit their reliability needs within their hardware and performance budgets. We propose and evaluate CRAFT, a suite of three such hybrid techniques, to illustrate the potential of the hybrid approach. For fair, quantitative comparisons among hardware, software, and hybrid systems, we introduce a new metric, mean work to failure, which is able to compare systems for which machine instructions do not represent a constant unit of work. Additionally, we present a new simulation framework which rapidly assesses reliability and does not depend on manual identification of failure modes. Our evaluation illustrates that CRAFT, and hybrid techniques in general, offer attractive options in the fault-detection design space.","1063-6897","0-7695-2270-X","10.1109/ISCA.2005.21","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1431553","","Hardware;Costs;Fault diagnosis;Space technology;Error correction codes;Protection;Fault tolerance;Clocks;Software systems;Microprocessors","program processors;fault diagnosis;fault tolerant computing;hardware-software codesign;instruction sets;performance evaluation","hybrid hardware-software fault-detection system;transient fault;hardware cost;hardware reliability;hardware-only system;software-only system;CRAFT;mean work to failure","","106","2","29","IEEE","20 Jun 2005","","","IEEE","IEEE Conferences"
"Detecting and visualizing refactorings from software archives","C. Gorg; P. Weissgerber","Computer Science, University of Saarland, Saarbrucken, Germany; Computer Science, Catholic University of Eichstätt, Eichstatt, Germany","13th International Workshop on Program Comprehension (IWPC'05)","23 May 2005","2005","","","205","214","We perform knowledge discovery in software archives in order to detect refactorings on the level of classes and methods. Our REFVIS prototype finds these refactorings in CVS repositories and relates them to transactions and configurations. Additionally, REFVIS relates movements of methods to the class inheritance hierarchy of the analyzed project. Furthermore, we present our visualization technique that illustrates these refactorings. REFVIS provides both a class hierarchy layout and a package layout and uses color coding to distinguish different kinds of refactorings. Details on each can be displayed on demand using mouse-over tooltips. Finally, we demonstrate by case studies on two open source projects how REFVIS facilitates understanding of refactorings applied to a software project.","1092-8138","0-7695-2254-8","10.1109/WPC.2005.18","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1421036","","Visualization;Open source software;Programming profession;Data mining;Computer science;Packaging;Software performance;Software prototyping;Prototypes;Software systems","program visualisation;data mining;inheritance;reverse engineering","software archives;knowledge discovery;REFVIS prototype;CVS repository;class inheritance hierarchy;visualization technique;package layout;color coding;mouse-over tooltips;open source project;software project;refactory detection","","20","","24","IEEE","23 May 2005","","","IEEE","IEEE Conferences"
"Concise and consistent naming [software system identifier naming]","F. Deissenbock; M. Pizka","Institut für Informatik, Technische Universität München, Garching b. München, Germany; Institut für Informatik, Technische Universität München, Garching b. München, Germany","13th International Workshop on Program Comprehension (IWPC'05)","23 May 2005","2005","","","97","106","Approximately 70% of the source code of a software system consists of identifiers. Hence, the names chosen as identifiers are of paramount importance for the readability of computer programs and therewith their comprehensibility. However, virtually every programming language allows programmers to use almost arbitrary sequences of characters as identifiers which far too often results in more or less meaningless or even misleading naming. Coding style guides address this problem but are usually limited to general and hard to enforce rules like ""identifiers should be self-describing"". This paper renders adequate identifier naming far more precisely. A formal model, based on bijective mappings between concepts and names, provides a solid foundation for the definition of precise rules for concise and consistent naming. The enforcement of these rules is supported by a tool that incrementally builds and maintains a complete identifier dictionary while the system is being developed. The identifier dictionary explains the language used in the software system, aids in consistent naming, and improves productivity of programmers by proposing suitable names depending on the current context.","1092-8138","0-7695-2254-8","10.1109/WPC.2005.14","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1421019","","Software systems;Programming profession;Dictionaries;Productivity;Natural languages;Computer languages;Solid modeling;Computer science education;Educational programs;Software maintenance","reverse engineering;formal specification;naming services","software system identifier naming;program comprehension;bijective mappings;precise rule definition;concise naming;consistent naming;programming languages","","51","","25","IEEE","23 May 2005","","","IEEE","IEEE Conferences"
"Ranking significance of software components based on use relations","K. Inoue; R. Yokomori; T. Yamamoto; M. Matsushita; S. Kusumoto","Software Engineering Laboratory, Department of Computer Science, Graduate School of Information Science and Technology, Osaka University, Toyonaka, Osaka, Japan; Software Engineering Laboratory, Department of Computer Science, Graduate School of Information Science and Technology, Osaka University, Toyonaka, Osaka, Japan; Department of Computer Science, College of Information Science and Engineering, Ritsumeikan University, Kusatsu, Shiga, Japan; Software Engineering Laboratory, Department of Computer Science, Graduate School of Information Science and Technology, Osaka University, Toyonaka, Osaka, Japan; Software Engineering Laboratory, Department of Computer Science, Graduate School of Information Science and Technology, Osaka University, Toyonaka, Osaka, Japan","IEEE Transactions on Software Engineering","25 Apr 2005","2005","31","3","213","225","Collections of already developed programs are important resources for efficient development of reliable software systems. In this paper, we propose a novel graph-representation model of a software component library (repository), called component rank model. This is based on analyzing actual usage relations of the components and propagating the significance through the usage relations. Using the component rank model, we have developed a Java class retrieval system named SPARS-J and applied SPARS-J to various collections of Java files. The result shows that SPARS-J gives a higher rank to components that are used more frequently. As a result, software engineers looking for a component have a better chance of finding it quickly. SPARS-J has been used by two companies, and has produced promising results.","1939-3520","","10.1109/TSE.2005.38","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1423993","Index Terms- Component rank;graph representation model;reuse models;program analysis;reusable libraries.","Software libraries;Java;Software quality;Internet;Application software;Companies;Software systems;Programming;Information retrieval;Information analysis","Java;program diagnostics;software reusability;software libraries","graph-representation model;software component library;component rank model;Java class retrieval system;software reusability;program analysis","","99","7","29","IEEE","25 Apr 2005","","","IEEE","IEEE Journals"
"COTS clusters vs. the Earth simulator: an application study using IMPACT-3D","D. Chavarria-Miranda; Guohua Jin; J. Mellor-Crummey","Department of Computer Science, Rice University, USA; Department of Computer Science, Rice University, USA; Department of Computer Science, Rice University, USA","19th IEEE International Parallel and Distributed Processing Symposium","18 Apr 2005","2005","","","10 pp.","","In 2002, Japan announced the Earth Simulator - a supercomputer based on low-volume vector processors and a custom network - and reported that computational scientists had used it to achieve 14.9 TFLOPS with the IMPACT-3D code, which is written in high performance Fortran (HPF). Of particular interest was that they had achieved this level of performance using a high-level parallel programming model. There has been considerable concern in the U.S. about the appropriateness of its hardware and software investments in super computing technology. To help assess the U.S. strategy of building systems from commodity-off-the-shelf (COTS) components, we explored using a combination of HPF and scalar compiler technology to tailor IMPACT-3D to microprocessor-based supercomputers and evaluated its performance and scalability on the AlphaServer-based Lemieux cluster at the Pittsburgh Supercomputer Center (PSC). On the Earth Simulator, IMPACT-3D achieved 45% of peak performance on 4096 processors; on 1024 processors of PSC's Lemieux, we achieved 17.29% of peak performance.","1530-2075","0-7695-2312-9","10.1109/IPDPS.2005.156","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1419914","","Earth;Supercomputers;Computational modeling;Vector processors;Computer networks;High performance computing;Parallel programming;Hardware;Investments;Appropriate technology","mainframes;parallel machines;parallel programming;FORTRAN;file servers;multiprocessing systems","COTS cluster;Earth Simulator;IMPACT-3D;supercomputer based low-volume vector processor;custom network;high performance Fortran;high-level parallel programming model;super computing technology;building system;commodity-off-the-shelf;COTS;scalar compiler technology;microprocessor-based supercomputers;AlphaServer-based Lemieux cluster;Pittsburgh Supercomputer Center","","","","21","IEEE","18 Apr 2005","","","IEEE","IEEE Conferences"
"Evolution doctor: a framework to control software system evolution","M. Di Penta","RCOST-Research Centre on Software Technology, Department of Engineering, University of Sannio, Benevento, Italy","Ninth European Conference on Software Maintenance and Reengineering","4 Apr 2005","2005","","","280","283","Real world software systems undergo, during their lifetime, to repeated maintenance activities. Due to the market pressure and to the need for having back the system operational in the shortest time possible, maintenance tends to introduce negative side effects. Some examples are the growth of the cloning percentage, the increase of library size, the presence of unused objects, or the lost of source file organization. This thesis proposes a framework, named evolution doctor, to diagnose and cure such phenomena. The framework permits the analysis and prediction of several indicators of software system evolution (size, complexity, cloning). Then, the framework defines a set of methods and tools to cure the problems: remove clones and unused objects, reorganize libraries, and restructure the source file directory organizations.","1534-5351","0-7695-2304-8","10.1109/CSMR.2005.29","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1402143","Software Evolution;Software Renovation;Clustering","Control systems;Software systems;Cloning;Software libraries;Software maintenance;Data mining;Information analysis;Hardware;User interfaces;Code standards","software maintenance;file organisation;systems re-engineering;software libraries","software system evolution;software maintenance;source file directory organization;evolution doctor framework","","5","3","14","IEEE","4 Apr 2005","","","IEEE","IEEE Conferences"
"An incremental approach to system replacement and integration","H. M. Sneed","Anecon GmbH, Vienna Austria Institut für Wirtschaftsinformatik, University of Regensburg, Bavaria, Germany","Ninth European Conference on Software Maintenance and Reengineering","4 Apr 2005","2005","","","196","205","Business users have a problem in replacing existing business application systems. Well over 50% of all replacement projects fail. The systems have become much too complex and too much knowledge about them has been lost. It is nearly impossible to reconstruct the requirements. Therefore, this paper presents an incremental, integrative approach supported by bridging tools, which allows migrating without requirements. The basic premise is to first breakup the existing systems into separate, collaborating subsystems and then to either convert them, redevelop them or to wrap them one at a time. The key is the interaction of the subsystems with each other and with the database across platform boundaries. The new subsystems can coexist with the remaining old ones until such time that all of them have been replaced.","1534-5351","0-7695-2304-8","10.1109/CSMR.2005.9","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1402132","Business Architectures;Reverse Engineering;Reengineering;Wrapping;XML;Interfaces","Costs;Software systems;Collaboration;Databases;Reverse engineering;Wrapping;XML;Information systems;Pensions;Business","reverse engineering;systems re-engineering;XML;business data processing","incremental approach;system replacement;system integration;business architectures;reverse engineering;reengineering;wrapping;XML;business application system","","8","","21","IEEE","4 Apr 2005","","","IEEE","IEEE Conferences"
"Design pattern recovery by visual language parsing","G. Costagliola; A. De Lucia; V. Deufemia; C. Gravino; M. Risi","Dipartimento di Matematica e Informatica, Università di Salerno, Fisciano, Salerno, Italy; Dipartimento di Matematica e Informatica, Università di Salerno, Fisciano, Salerno, Italy; Dipartimento di Matematica e Informatica, Università di Salerno, Fisciano, Salerno, Italy; Dipartimento di Matematica e Informatica, Università di Salerno, Fisciano, Salerno, Italy; Dipartimento di Matematica e Informatica, Università di Salerno, Fisciano, Salerno, Italy","Ninth European Conference on Software Maintenance and Reengineering","4 Apr 2005","2005","","","102","111","We propose an object oriented (OO) design pattern recovery approach which makes use of a design pattern library, expressed in terms of visual grammars, and based on a visual language parsing technique. We also present a visual environment, which supports the pattern recognition process by automatically retrieving design patterns from imported UML class diagrams. The visual environment has been automatically generated through the VLDesk system, starting from a description of the design pattern grammar.","1534-5351","0-7695-2304-8","10.1109/CSMR.2005.23","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1402119","","Pattern recognition;Libraries;Unified modeling language;Design engineering;Knowledge engineering;Data mining;Reverse engineering;Software systems;Object oriented modeling;Documentation","object-oriented programming;visual languages;grammars;Unified Modeling Language;software libraries;program compilers","object oriented design;visual grammars;visual language parsing;pattern recognition process;UML class diagrams;VLDesk system;design pattern grammar","","24","","26","IEEE","4 Apr 2005","","","IEEE","IEEE Conferences"
"An XML-based framework for language neutral program representation and generic analysis","R. Al-Ekram; K. Kontogiannis","Department of Electrical and Computer Engineering, University of Waterloo, Waterloo, ONT, Canada; Department of Electrical and Computer Engineering, University of Waterloo, Waterloo, ONT, Canada","Ninth European Conference on Software Maintenance and Reengineering","4 Apr 2005","2005","","","42","51","XML applications are becoming increasingly popular to define structured or semi-structured constrained data in XML for special application areas. In pursuit there is a growing momentum of activities related to XML representation of source code in the area of program comprehension and software re-engineering. The source code and the artifacts extracted from a program are necessarily structured information that needs to be stored and exchanged among different tools. This makes XML to be a natural choice to be used as the external representation formats for program representations. Most of the XML representations proposed so far abstract the source code at the AST level. These AST representations are tightly coupled with the language grammar of the source code and hence require development of different tools for different programming languages to perform the same type of analysis. Moreover AST abstracts the program at a very fine level of granularity and hence not suitable to be used directly for higher-level sophisticated program analysis. As such, we propose XML applications for language neutral representation of programs at different levels of abstractions and by combining them we present a program representation framework in order to facilitate the development of generic program analysis tools.","1534-5351","0-7695-2304-8","10.1109/CSMR.2005.10","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1402113","","XML;Application software;Computer languages;Performance analysis;Abstracts;Markup languages;Data mining;Web sites;Equations;Telephony","abstract data types;XML;program diagnostics;systems re-engineering;software tools","language neutral program representation;generic program analysis tool;semistructured constrained data;structured constrained data;program comprehension;software re-engineering;XML representations;language grammar;source code abstraction;AST","","9","","29","IEEE","4 Apr 2005","","","IEEE","IEEE Conferences"
"Improving WCET by optimizing worst-case paths","W. Zhao; W. Kreahling; D. Whalley; C. Healy; F. Mueller","Computer Science Department, Florida State University, Tallahassee, FL, USA; Computer Science Department, Florida State University, Tallahassee, FL, USA; Computer Science Department, Florida State University, Tallahassee, FL, USA; Computer Science Department, Furman University, Greenville, SC, USA; Computer Science Department, North Carolina State University, Raleigh, NC, USA","11th IEEE Real Time and Embedded Technology and Applications Symposium","21 Mar 2005","2005","","","138","147","It is advantageous to perform compiler optimizations to lower the WCET of a task since tasks with lower WCETs are easier to schedule and more likely to meet their deadlines. Compiler writers in recent years have used profile information to detect the frequently executed paths in a program and there has been much effort to develop compiler optimizations to improve these paths in order to reduce average-case execution time. In this paper we describe our approach to reduce WCET by adapting and applying optimizations designed for frequent paths to the worst-case paths in an application. Our compiler uses feedback from our timing analyzer to detect the WCET paths through a function that will be subject to aggressive optimizations, reflect subsequent effects on the WCET of the paths due to these optimizations, and to also ensure that the worst-case path optimizations actually improve the WCET before committing to a code size increase. We evaluate a number of WC path optimizations and present results showing the decrease in WCET versus the increase in code size.","1545-3421","0-7695-2302-1","10.1109/RTAS.2005.29","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1388381","","Timing;Optical wavelength conversion;Optimizing compilers;Program processors;Performance analysis;Embedded system;Design optimization;Time factors;Information analysis;Feedback","optimising compilers;scheduling;program control structures;computational complexity","worst-case path optimization;compiler optimization;task scheduling;average-case execution time;worst-case execution time","","9","","30","IEEE","21 Mar 2005","","","IEEE","IEEE Conferences"
"Using origin analysis to detect merging and splitting of source code entities","M. W. Godfrey; L. Zou","School of Computer Science, University of Waterloo, Waterloo, ONT, Canada; School of Computer Science, University of Waterloo, Waterloo, ONT, Canada","IEEE Transactions on Software Engineering","7 Mar 2005","2005","31","2","166","181","Merging and splitting source code entities is a common activity during the lifespan of a software system; as developers rethink the essential structure of a system or plan for a new evolutionary direction, so must they be able to reorganize the design artifacts at various abstraction levels as seems appropriate. However, while the raw effects of such changes may be plainly evident in the new artifacts, the original context of the design changes is often lost. That is, it may be obvious which characters of which files have changed, but it may not be obvious where or why moving, renaming, merging, and/or splitting of design elements has occurred. In this paper, we discuss how we have extended origin analysis (Q. Tu et al., 2002), (M.W. Godfrey et al., 2002) to aid in the detection of merging and splitting of files and functions in procedural code; in particular, we show how reasoning about how call relationships have changed can aid a developer in locating where merges and splits have occurred, thereby helping to recover some information about the context of the design change. We also describe a case study of these techniques (as implemented in the Beagle tool) using the PostgreSQL database system as the subject.","1939-3520","","10.1109/TSE.2005.28","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1401931","Index Terms- Software evolution;origin analysis;restructuring;reverse engineering;and reengineering.","Merging;Software systems;History;Software maintenance;Information analysis;Database systems;Reverse engineering;Environmental management;Software tools;Documentation","reverse engineering;systems re-engineering;software maintenance;software development management;merging;SQL;reasoning about programs","merging;source code entity;software system;origin analysis;PostgreSQL database system","","137","27","25","IEEE","7 Mar 2005","","","IEEE","IEEE Journals"
"The class blueprint: visually supporting the understanding of glasses","S. Ducasse; M. Lanza","Software Composition Group, Institute of Applied Mathematics and Computer Science, University of Bern, Bern, Switzerland; Faculty of Informatics, University of Lugano, Lugano, Switzerland","IEEE Transactions on Software Engineering","14 Feb 2005","2005","31","1","75","90","Understanding source code is an important task in the maintenance of software systems. Legacy systems are not only limited to procedural languages, but are also written in object-oriented languages. In such a context, understanding classes is a key activity as they are the cornerstone of the object-oriented paradigm and the primary abstraction from which applications are built. Such an understanding is however difficult to obtain because of reasons such as the presence of late binding and inheritance. A first level of class understanding consists of the understanding of its overall structure, the control flow among its methods, and the accesses on its attributes. We propose a novel visualization of classes called class blueprint that is based on a semantically enriched visualization of the internal structure of classes. This visualization allows a software engineer to build a first mental model of a class that he validates via opportunistic code-reading. Furthermore, we have identified visual patterns that represent recurrent situations and as such convey additional, information to the viewer. The contributions of this article are the class blueprint, a novel visualization of the internal structure of classes, the identification of visual patterns, and the definition of a vocabulary based on these visual patterns. We have performed several case studies of which one is presented in depth, and validated the usefulness of the approach in a controlled experiment.","1939-3520","","10.1109/TSE.2005.14","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1392721","Index Terms- Object-oriented programming;software visualization;reverse engineering;visual patterns;smalltalk.","Visualization;Software maintenance;Software systems;Application software;Cognitive science;Vocabulary;Programming profession;Reverse engineering;Phase measurement;Software measurement","object-oriented programming;Smalltalk;reverse engineering;program visualisation;software maintenance;inheritance;vocabulary;formal verification","software system maintenance;legacy systems;procedural languages;object-oriented languages;late binding;class understanding;class blueprint;opportunistic code-reading;software visualization;reverse engineering;visual patterns;Smalltalk","","53","","44","IEEE","14 Feb 2005","","","IEEE","IEEE Journals"
"MobCon: A Generative Middleware Framework for Java Mobile Applications","V. Cepa; M. Mezini","Department of Computer Science, Darmstadt University of Technology, Germany; Department of Computer Science, Darmstadt University of Technology, Germany","Proceedings of the 38th Annual Hawaii International Conference on System Sciences","24 Jan 2005","2005","","","283b","283b","While dedicated technologies such as e.g., Sun's J2ME MIDP offer a simple programming model for mobile applications, appropriate support for modularizing the implementation of technical concerns such as data persistence, screen management, session management, etc. is still missing. As the result, the implementation of such concerns cuts across several applications, or even several places within a single application. In this paper, we introduce the notion of a logical mobile container aimed at automating the process of nearly transparently adding technical concerns to the core functionality of a MIDP application. The container we introduce is logical: Code generation allows us to profit from high-level abstractions without adding physical layers which are too costly for a mobile application. We present an extensible mobile container framework for MIDP applications, called MobCon, which is implemented as a generative framework based on annotations.","1530-1605","0-7695-2268-8","10.1109/HICSS.2005.431","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1385821","","Middleware;Java;Containers;Application software;Appropriate technology;Computer science;Mobile computing;Technology management;Mobile handsets;Personal digital assistants","","","","2","","41","IEEE","24 Jan 2005","","","IEEE","IEEE Conferences"
"WebSphere connector architecture evolution","S. M. Fontes; C. J. Nordstrom; K. W. Sutter","Research Triangle Park, IBM Software Group, NC, USA; IBM Software Group, Rochester, MN, USA; IBM Software Group, Rochester, MN, USA","IBM Systems Journal","6 Apr 2010","2004","43","2","316","326","The ability of applications to communicate with resources that are outside of the application server process and to use those resources efficiently has always been an important requirement for application developers. Equally important is the ability for vendors to plug in their own solutions for connecting to and using their resources. These capabilities have evolved over time in the IBM WebSphere Application Server, from the JDBC™ application programming interface to the Common Connector Framework and later to the J2EE™ Connector Architecture, the latter providing functions such as application server inbound communications, life cycle management, and work management. In this paper, the evolution of the WebSphere Application Server implementation of these architectures, their benefits, and their trade-offs are discussed. A preview of an important new architecture, the WebSphere Channel Framework Architecture (a logical extension to the J2EE Connector Architecture) is also presented.","0018-8670","","10.1147/sj.432.0316","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5386787","","","","","","1","","","","6 Apr 2010","","","IBM","IBM Journals"
"Curing schizophrenia by program rewriting in Esterel","O. Tardieu; R. de Simone","I.N.R.I.A. Sophia Antipolis, France; I.N.R.I.A. Sophia Antipolis, France","Proceedings. Second ACM and IEEE International Conference on Formal Methods and Models for Co-Design, 2004. MEMOCODE '04.","5 Jul 2005","2004","","","39","48","Synchronous languages such as Esterel can execute a series of statements in a single ""instant"" of time. If this series spans a loop iteration then it is possible that a computation local to the loop will have several distinct results during that ""instant"", which is referred to as schizophrenia. This makes the compilation of synchronous languages into more traditional computation models (such as C code or sequential logic) difficult. In a previous work (2004), we suggested to deal with schizophrenia through preprocessing in the Esterel language extended with a non-instantaneous jump statement. We now advocate for and experimented with such a program transformation, establishing the correctness, the completeness and the efficiency of our approach.","","0-7803-8509-8","10.1109/MEMCOD.2004.1459813","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1459813","","Curing;Circuits;Logic;Hardware;Silicon;Clocks;Design optimization;Mathematical model;Sequential analysis;Wire","high level languages;rewriting systems;formal verification","program rewriting;Esterel;synchronous languages","","14","","18","IEEE","5 Jul 2005","","","IEEE","IEEE Conferences"
"Domo: a force sensing humanoid robot for manipulation research","A. Edsinger-Gonzales; J. Weber","Artificial intelligence Laboratory, MIT Computer Science, Cambridge, MA, USA; Artificial intelligence Laboratory, MIT Computer Science, Cambridge, MA, USA","4th IEEE/RAS International Conference on Humanoid Robots, 2004.","20 Jun 2005","2004","1","","273","291 Vol. 1","Humanoid robots found in research and commercial use today typically lack the ability to operate in unstructured and unknown environments. Force sensing and compliance at each robot joint can allow the robot to safely act in these environments. However, these features can be difficult to incorporate into robot designs. We present a new force sensing and compliant humanoid under development in the humanoid robotics group at MIT CSAIL. The robot, named Domo, is to be a research platform for exploring issues in general dexterous manipulation, visual perception, and learning. In this paper we describe aspects of the design, detail proposed research directions for the robot, and illustrate how the design of humanoid robots can be informed by the desired research goals.","","0-7803-8863-1","10.1109/ICHR.2004.1442127","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1442127","","Humanoid robots;Robot sensing systems;Force control;Force sensors;Visual perception;Tactile sensors;Neck;Firewire;Computer science;Intelligent robots","humanoid robots;dexterous manipulators;compliance control;robot vision;force sensors","force sensing humanoid robot Domo;manipulation research;robot joint;robot designs;compliant humanoid;dexterous manipulation;visual perception","","59","","20","IEEE","20 Jun 2005","","","IEEE","IEEE Conferences"
"Non-competitive programming contest problems as the basis for just-in-time teaching","O. L. Astrachan","Department of Computer Science, Duke University, Durham, NC, USA","34th Annual Frontiers in Education, 2004. FIE 2004.","18 Apr 2005","2004","","","T3H/20","T3H/24 Vol. 1","We report on the successful use of small programming assignments that augment a just-in-time approach to teaching programming, and problem solving in the first year of computer science. The emphasis in these assignments is on algorithmic problem-solving rather than on object-oriented design and programming. Students are given a terse explanation of a problem and several non-exhaustive test cases. A programmed solution uses no I/O, but is tested via a Web-based submission system that reports success or failure for between 10 and 40 test cases. Students compile, test, and debug via the online Web-based system. There is no limit on the number of times students can test their solutions. After submission for grading, solutions are judged solely on whether they pass tests, all of which can be seen via the online testing mechanism, and not on the so-called quality of the code submitted.","0190-5848","0-7803-8552-7","10.1109/FIE.2004.1408553","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1408553","","Education;Problem-solving;System testing;Object oriented programming;Educational institutions;Algorithm design and analysis;Debugging;Array signal processing;Programming profession;Java","teaching;computer science education;Internet;problem solving;programming;educational courses","noncompetitive programming contest problems;just-in-time teaching;small programming assignments;teaching programming;computer science;algorithmic problem-solving;Web-based submission system;online testing mechanism","","11","","20","IEEE","18 Apr 2005","","","IEEE","IEEE Conferences"
"Legal concerns of Web site reverse engineering","H. M. Kienle; D. German; H. Muller","Computer Science Department, University of Victoria, Victoria, Canada; Computer Science Department, University of Victoria, Victoria, Canada; Computer Science Department, University of Victoria, Victoria, Canada","Proceedings. Sixth IEEE International Workshop on Web Site Evolution","4 Apr 2005","2004","","","41","50","Researchers involved in Web site reverse engineering are often not aware of potential legal implications of using someone else's Web site for experimentation. Even if researchers are concerned with legal problems, there is little guidance available. This paper explores the legality of Web site reverse engineering with the intent to raise awareness among researchers about this issue. The discussed legal issues encompass copyright, contract, and trespass law.","1550-4441","0-7695-2224-6","10.1109/WSE.2004.10000","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1410994","","Law;Legal factors;Reverse engineering;Protection;Costs;Manufacturing industries;Technological innovation;Computer science;Contracts;Internet","reverse engineering;Web sites;contract law;copyright","legal issues;Web site reverse engineering;copyright law;contract law;trespass law","","4","","67","IEEE","4 Apr 2005","","","IEEE","IEEE Conferences"
"The Inca Test Harness and Reporting Framework","S. Smallen; C. Olschanowsky; K. Ericson; P. Beckman; J. M. Schopf","San Diego Supercomputer Center, USA; San Diego Supercomputing Center, Iran; San Diego Supercomputer Center, USA; Argonne National Laboratory, USA; Argonne National Laboratory, USA","SC '04: Proceedings of the 2004 ACM/IEEE Conference on Supercomputing","21 Mar 2005","2004","","","55","55","Virtual organizations (VOs), communities that enable coordinated resource sharing among multiple sites, are becoming more prevalent in the high-performance computing community. In order to promote cross-site resource usability, most VOs prepare service agreements that include a minimum set of common resource functionality, starting with a common software stack and evolving into more complicated service and interoperability agreements. VO service agreements are often difficult to verify and maintain, however, because the sites are dynamic and autonomous. Automated verification of service agreements is critical: manual and user tests are not practical on a large scale. The Inca test harness and reporting framework is a generic system for the automated testing, data collection, verification, and monitoring of service agreements. This paper describes Inca’s architecture, system impact, and performance. Inca is being used by the TeraGrid project to verify software installations, monitor service availability, and collect performance data.","","0-7695-2153-3","10.1109/SC.2004.56","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1392985","","Automatic testing;System testing;Resource management;Large-scale systems;Software performance;Availability;Grid computing;Permission;Supercomputers;Laboratories","","","","12","31","45","IEEE","21 Mar 2005","","","IEEE","IEEE Conferences"
"Model-based development for time-triggered architectures","B. Dion; T. Le Sergent; B. Martin; H. Griebel","Esterel Technologies, Toulouse, France; Esterel Technologies, Toulouse, France; Esterel Technologies, Toulouse, France; TTTech, Vienna, Austria","The 23rd Digital Avionics Systems Conference (IEEE Cat. No.04CH37576)","14 Feb 2005","2004","2","","6.D.3","6.1","Time-triggered architectures (TTA) and SCADE are both well-established technologies and tools for building safety-critical embedded software. Both are based on the same time-triggered approach; TTA for the communication infrastructure and SCADE for the application components. This paper presents the integration of these two technologies and tools for the design of distributed systems 1. When completed, the breakthrough of this solution shows that it provides a single framework to: specify behavior, timing constraints, and mapping of tasks onto hardware; generate all the code needed to build communicating executables; simulate and perform formal verification of properties both for each individual task and also for the global model. Specification is accomplished with a graphical view that allows the definition of hardware nodes and mapping of any set of subsystems (a subsystem consists of several communicating tasks, all located on the same node) on these nodes. Replication is authorized and handled by the fault tolerant communication (FT-COM) layer. Code generation is supported by add-ons to the two toolsets: the complete architecture and timing information is generated from SCADE and passed to the TTP plan and TTP build functions that compute respectively the communication scheduling and the task scheduling for each node. The SCADE code generator generates certifiable C code for each task. TTP build generates the code for the scheduling of the tasks on each node. A simple wrapper code is generated to handle data transfer between the FT-COM layer and task interfaces. Simulation and formal verification are possible thanks to the same underlying paradigm for both technologies: as both the application tasks and the communication infrastructure are time-triggered, with complete determinism, a global system model can be represented and formally verified.","","0-7803-8539-X","10.1109/DASC.2004.1390733","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1390733","","Computer architecture;Application software;Embedded software;Fault tolerance;Timing;Hardware;Formal verification;Processor scheduling;Communication system control;Systems engineering and theory","embedded systems;program compilers;formal verification;safety-critical software;software fault tolerance;aerospace computing","model based development;time triggered architectures;safety critical embedded software;communication infrastructure;distributed systems;timing constraints;code generation;formal verification;graphical view;hardware nodes;fault tolerant communication layer;TTP plan functions;TTP build functions;communication scheduling;task scheduling;SCADE code generator;certifiable C code;wrapper code;data transfer;global system model;aerospace computing","","4","2","6","IEEE","14 Feb 2005","","","IEEE","IEEE Conferences"
"Clone detection in source code by frequent itemset techniques","V. Wahler; D. Seipel; J. Wolff; G. Fischer","University of Würzburg, Institute for Computer Science, Würzburg, Germany; University of Würzburg, Institute for Computer Science, Würzburg, Germany; Julius-Maximilians-Universitat Wurzburg, Wurzburg, Bayern, DE; University of Würzburg, Institute for Computer Science, Würzburg, Germany","Source Code Analysis and Manipulation, Fourth IEEE International Workshop on","24 Jan 2005","2004","","","128","135","We describe a new approach for the detection of clones in source code, which is inspired by the concept of frequent itemsets from data mining. The source code is represented as an abstract syntax tree in XML. Currently, such XML representations exist for instance for Java, C++, or PROLOG. Our approach is very flexible; it can be configured easily to work with multiple programming languages.","","0-7695-2144-4","10.1109/SCAM.2004.6","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1386166","","Cloning;Itemsets;XML;Computer languages;Testing;Software maintenance;Computer science;Data mining;Java;Programming profession","C++ language;Java;program debugging;PROLOG;source coding;XML","clone detection;source code;frequent itemset techniques;data mining;XML;Java;C++;PROLOG;multiple programming languages","","53","","18","IEEE","24 Jan 2005","","","IEEE","IEEE Conferences"
"Program restructuring through clustering techniques","Xia Xu; Chung-Horng Lung; M. Zaman; A. Srinivasan","Department of Systems and Computer Engineering, Carleton University, Ottawa, Canada; Department of Systems and Computer Engineering, Carleton University, Ottawa, Canada; Cistel Technology, Inc., Ottawa, Canada; EION, Inc., Ottawa, Canada","Source Code Analysis and Manipulation, Fourth IEEE International Workshop on","24 Jan 2005","2004","","","75","84","Program restructuring is a key method for improving the quality of ill-structured programs, thereby increasing the understandability and reducing the maintenance cost. It is a challenging task and a great deal of research is still ongoing. This work presents an approach to program restructuring at the function level, based on clustering techniques with cohesion as the major concern. Clustering has been widely used to group related entities together. The approach focuses on automated support for identifying ill-structured or low-cohesive functions and providing heuristic advice in both the development and evolution phases. A new similarity measure is defined and studied intensively. The approach is applied to restructure a real industrial program. The empirical observations show that the heuristic advice provided by the approach can help software designers make better decision of why and how to restructure a program. Specific source code level software metrics are presented to demonstrate the value of the approach.","","0-7695-2144-4","10.1109/SCAM.2004.18","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1386161","","Costs;Software design;Programming;Software maintenance;Lungs;Software metrics;Job shop scheduling;Software quality;Degradation;Telecommunication control","program diagnostics;cluster tools;software metrics","program restructuring;clustering techniques;source code level software metrics","","9","","39","IEEE","24 Jan 2005","","","IEEE","IEEE Conferences"
"Mining aspectual views using formal concept analysis","T. Tourwe; K. Mens","Centrum voor Wiskunde en Informatica, Amsterdam, Netherlands; Département dIngénierie Informatique, Université Catholique de Louvain, Louvain-la-Neuve, Belgium","Source Code Analysis and Manipulation, Fourth IEEE International Workshop on","24 Jan 2005","2004","","","97","106","We report upon an initial experiment using the technique of formal concept analysis for mining aspectual views from the source code. An aspectual view is a set of source code entities, such as class hierarchies, classes and methods that are structurally related in some way, and often crosscut a particular application. Initially, we follow a lightweight approach, where we only consider the names of classes and methods. This simplistic technique already results in the discovery of interesting and meaningful aspectual views, leaving us confident that more complex approaches will perform even better, and merit to be studied in the future.","","0-7695-2144-4","10.1109/SCAM.2004.15","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1386163","","Software maintenance;Software systems;Code standards;Standards development;Conferences;IEEE entities","object-oriented programming;source coding;data mining","formal concept analysis;aspectual view mining;source code","","47","1","19","IEEE","24 Jan 2005","","","IEEE","IEEE Conferences"
"Amorphous procedure extraction","M. Harman; D. Binkley; R. Singh; R. M. Hierons","Brunei University, Uxbridge, Middlesex, UK; Loyola College, Baltimore, MD, USA; Brunei University, Uxbridge, Middlesex, UK; Brunei University, Uxbridge, Middlesex, UK","Source Code Analysis and Manipulation, Fourth IEEE International Workshop on","24 Jan 2005","2004","","","85","94","The procedure extraction problem is concerned with the meaning preserving formation of a procedure from a (not necessarily contiguous) selected set of statements. Previous approaches to the problem have used dependence analysis to identify the non-selected statements which must be 'promoted' (also selected) in order to preserve semantics. All previous approaches to the problem have been syntax preserving. This work shows that by allowing transformation of the program's syntax it is possible to extract both procedures and functions in an amorphous manner. That is, although the amorphous extraction process is meaning preserving it is not necessarily syntax preserving. The amorphous approach is advantageous in a variety of situations. These include when it is desirable to avoid promotion, when a value-returning function is to be extracted from a scattered set of assignments to a variable, and when side effects are present in the program from which the procedure is to be extracted.","","0-7695-2144-4","10.1109/SCAM.2004.4","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1386162","","Amorphous materials;Educational institutions;Scattering;Cloning;Conferences","programming language semantics","amorphous procedure extraction;dependence analysis;program syntax","","2","","31","IEEE","24 Jan 2005","","","IEEE","IEEE Conferences"
"Scoped types for real-time Java","Tian Zhao; J. Noble; J. Vitek","University of Wisconsin, Milwaukee, USA; Victoria University of Wellington, New Zealand; Purdue University, USA","25th IEEE International Real-Time Systems Symposium","17 Jan 2005","2004","","","241","251","A memory model based on scoped areas is one of the distinctive features of the Real-Time Specification for Java (RTSJ). Scoped types ensure timely reclamation of memory and predictable performance. The price to pay for these benefits is an unfamiliar programming model that, at the same time, is complex, requires checking all memory accesses, and rewards design-time errors with run-time crashes. We investigate an alternative approach, referred to as scoped types, that simplifies the task of managing memory in real-time codes. The key feature of our proposal is that the run-time partition of memory imposed by scoped areas is straightforwardly mirrored in the program text. Thus cursory inspection of a program reveals which objects inhabit the different scopes, significantly simplifying the task of understanding real-time Java programs. Moreover, we introduce a type system which ensures that no run-time errors due to memory access checks occur. Thus a RTSJ-compliant virtual machine does not require memory access checks. The contributions of this paper are the concept of scoped types, and a proof soundness of the type system. Experimental results are described in future work.","1052-8725","0-7695-2247-5","10.1109/REAL.2004.51","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1381311","","Java;Yarn;Runtime;Memory management;Virtual machining;Real time systems;Safety;Computer crashes;Proposals;Inspection","real-time systems;Java;formal specification;storage management;virtual machines;system recovery","scoped types;Real-Time Specification for Java;memory management;run-time partition;memory access checks;virtual machine","","23","","24","IEEE","17 Jan 2005","","","IEEE","IEEE Conferences"
"Estimating Dependability of Parallel FFT Application using Fault Injection","A. Derezinska","Institute of Computer Science, Warsaw University of Technology, Poland","Parallel Computing in Electrical Engineering, 2004. International Conference on","17 Jan 2005","2004","","","240","245","This paper discusses estimation of dependability of a parallel FFT application. The application uses FFTW library. Fault susceptibility is assessed using software implemented fault injection. The fault injection campaign and the experiment results are presented. The response classes to injected faults are analyzed. The accuracy of evaluated data is verified experimentally.","","0-7695-2080-4","10.1109/PCEE.2004.32","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1376763","","Application software;Discrete Fourier transforms;Yarn;Concurrent computing;Software libraries;Fast Fourier transforms;Fault detection;Parallel processing;Performance evaluation;Fault tolerance","","","","","","12","IEEE","17 Jan 2005","","","IEEE","IEEE Conferences"
"Insights into system-wide code duplication","M. Rieger; S. Ducasse; M. Lanza","Software Composition Group, University of Bern, Switzerland; Software Composition Group, University of Bern, Switzerland; Software Composition Group, University of Bern, Switzerland","11th Working Conference on Reverse Engineering","17 Jan 2005","2004","","","100","109","Duplication of code is a common phenomenon in the development and maintenance of large software systems. The detection and removal of duplicated code has become a standard activity during the refactoring phases of a software life-cycle. However, code duplication identification tends to produce large amounts of data making the understanding of the duplication situation as a whole difficult. Reengineers can easily lose sight of the forest for the trees. There is a need to support a qualitative analysis of the duplicated code. We propose a number of visualizations of duplicated source elements that support reengineers in answering questions, e.g., which parts of the system are connected by copied code or which parts of the system are copied the most.","1095-1350","0-7695-2243-2","10.1109/WCRE.2004.25","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1374310","Code duplication detection;code visualization;polymetric views","Data visualization;Cloning;Software maintenance;Reverse engineering;Software systems;Phase detection;Standards activities;Time factors;Costs;Data engineering","program visualisation;software maintenance;reverse engineering;systems re-engineering;program diagnostics","system-wide code duplication;software development;software maintenance;refactoring phases;software life-cycle;code duplication identification;code visualization;polymetric views","","45","","16","IEEE","17 Jan 2005","","","IEEE","IEEE Conferences"
"Identifying aspects using fan-in analysis","M. Marin; A. van Deursen; L. Moonen","Software Evolution Research Laboratory, Delft University of Technnology, Netherlands; Software Evolution Research Laboratory,CWI, Delft University슠of슠Technology, Netherlands; Software Evolution Research Laboratory, Delft University of Technnology, Netherlands","11th Working Conference on Reverse Engineering","17 Jan 2005","2004","","","132","141","The issues of code scattering and tangling, thus of achieving a better modularity for a system's concerns, are addressed by the paradigm of aspect orientation. Aspect mining is a reverse engineering process that aims at finding crosscutting concerns in existing systems. This work describes a technique based on determining methods that are called from many different places (and hence have a high fan-in) to identify candidate aspects in a number of open-source Java systems. The most interesting aspects identified are discussed in detail, which includes several concerns not previously discussed in the aspect-oriented literature. The results show that a significant number of aspects can be recognized using fan-in analysis, and that the technique is suitable for a high degree of automation.","1095-1350","0-7695-2243-2","10.1109/WCRE.2004.23","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1374313","","Marine technology;Reverse engineering;Scattering;Automation;Open source software;Java;Software systems;Embedded system;Packaging;Cloning","object-oriented programming;reverse engineering;Java;public domain software","aspect identification;fan-in analysis;code scattering;code tangling;aspect orientation;aspect mining;reverse engineering;candidate aspects;open-source Java systems","","60","","23","IEEE","17 Jan 2005","","","IEEE","IEEE Conferences"
"Managing Duplicated Code with Linked Editing","M. Toomim; A. Begel; S. L. Graham","Department of Computer Science, University of California Berkeley, USA; Department of Computer Science, University of California Berkeley, USA; Department of Computer Science, University of California Berkeley, USA","2004 IEEE Symposium on Visual Languages - Human Centric Computing","27 Dec 2004","2004","","","173","180","We present Linked Editing, a novel, lightweight editor-based technique for managing duplicated source code. Linked Editing is implemented in a prototype editor called Codelink. We argue that the use of programming abstractions like functions and macros-the traditional solution to duplicated code-has inherent cognitive costs, leading programmers to chronically copy and paste code instead. Our user study compares functional abstraction with Linked Editing and shows that Linked Editing can give the benefits of abstraction with orders of magnitude decrease in programming time.","","0-7803-8696-5","10.1109/VLHCC.2004.35","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1372317","","Programming profession;Functional programming;Cloning;Prototypes;Cost function;Software systems;Computer science;Computer languages;Object oriented programming;Linux","macros;software engineering;text editing","linked editing;lightweight editor-based technique;duplicated source code;Codelink;programming abstractions;macros;cognitive costs;functional abstraction;programming time","","80","","43","IEEE","27 Dec 2004","","","IEEE","IEEE Conferences"
"Supporting dynamic crosscutting with partial behavioral reflection: a case study","L. Rodriguez; E. Tanter; J. Noye","Instituto de Computación, Universidad de la República, Montevideo, Uruguay; Departamento de Ciencias de la Computación, Universidad de Chile, Santiago, Chile; INRIA Rennes, Campus universitaire de Beaulieu, Rennes, France","XXIV International Conference of the Chilean Computer Science Society","27 Dec 2004","2004","","","48","58","The relationship between reflection and aspect-oriented programming is still under exploration. This paper reports on an experiment to support a widely-accepted, general-purpose aspect language mechanism - AspectJ's dynamic crosscutting -, with a model of partial behavioral reflection. We present a first approach to such a mapping, identify some extensions that can improve the effectiveness of the mapping, and validate our proposal through a revisited mapping. These extensions have been integrated into our Java reflective platform, Reflex.","","978-0-7695-2200-5","10.1109/QEST.2004.22","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1372104","","Reflection;Computer aided software engineering;Object oriented modeling;Proposals;Object oriented programming;Java;Protocols;Parallel processing;Fault tolerance;Software engineering","object-oriented programming;Java","dynamic crosscutting;partial behavioral reflection;aspect-oriented programming;aspect language mechanism;AspectJ;revisited mapping;Java reflective platform;Reflex","","5","","37","IEEE","27 Dec 2004","","","IEEE","IEEE Conferences"
"High performance communication system based on generic programming","A. L. G. Sanches; F. R. Secco; A. A. Frohlich","Brazil; Brazil; Software and Hardware Integration Laboratory-LISHA, Universidade Federal de Santa Catarina, Brazil","16th Symposium on Computer Architecture and High Performance Computing","13 Dec 2004","2004","","","92","99","This paper presents a high performance communication system based on generic programming. The system adapts itself according to the protocol being used on communication, simplifying the development of libraries. In order to validate the concepts, a MPI implementation has been developed and it is compared to a traditional implementation - MPICH-GM. It is demonstrated that the same functionality and interface can be offered with similar performance, but with much less programming effort. That is evidence that the large size of traditional MPI implementations is due to the limitations of conventional communication systems.","1550-6533","0-7695-2240-8","10.1109/SBAC-PAD.2004.19","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1364741","","Protocols;Software libraries;Middleware;Communication standards;Standards development;Hardware;Functional programming;Delay;High performance computing;Message passing","message passing;parallel programming;middleware","high performance communication system;generic programming;MPI;message passing;application program interfaces","","","","7","IEEE","13 Dec 2004","","","IEEE","IEEE Conferences"
"Linear complexity object-oriented similarity for clone detection and software evolution analyses","E. Merlo; G. Antoniol; M. Di Penta; V. F. Rollo","Ècole Polytechnique de Montréal, Montreal, Canada; Department of Engineering,RCOST-Research Centre on Software Technology, University of Sannio, Benevento, Italy; Department of Engineering,RCOST-Research Centre on Software Technology, University of Sannio, Benevento, Italy; Department of Engineering,RCOST-Research Centre on Software Technology, University of Sannio, Benevento, Italy","20th IEEE International Conference on Software Maintenance, 2004. Proceedings.","22 Nov 2004","2004","","","412","416","With the widespread adoption of object-oriented technologies, the lack of computationally efficient and scalable approaches is limiting the ability to model and analyze the history of large object-oriented software systems. This paper proposes an approximate representation of object-oriented code characteristics, inspired by pattern recognition centroids for clustering. An interesting application of such a representation is a linear-time complexity algorithm to detect duplicate or nearly duplicated code in object-oriented systems. The algorithm accuracy and time complexity were assessed on 11 releases of a large software system, the Eclipse framework.","1063-6773","0-7695-2213-0","10.1109/ICSM.2004.1357826","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1357826","","Cloning;Software algorithms;Software systems;Pattern recognition;Application software;Clustering algorithms;Object oriented modeling;Open source software;Software maintenance;History","object-oriented programming;software prototyping;computational complexity;pattern recognition;data flow analysis;software maintenance","object-oriented software evolution;clone detection;source code analysis;linear complexity object-oriented similarity;software evolution analysis;large object-oriented software system;object-oriented code characteristics;pattern recognition centroids;linear-time complexity algorithm;time complexity;Eclipse framework","","17","","8","IEEE","22 Nov 2004","","","IEEE","IEEE Conferences"
"Bad smells - humans as code critics","M. V. Mantyla; J. Vanhanen; C. Lassenius","Software Business and Engineering Institute, Helsinki University of Technology, Finland; Software Business and Engineering Institute, Helsinki University of Technology, Finland; Software Business and Engineering Institute, Helsinki University of Technology, Finland","20th IEEE International Conference on Software Maintenance, 2004. Proceedings.","22 Nov 2004","2004","","","399","408","This work presents the results of an initial empirical study on the subjective evaluation of bad code smells, which identify poor structures in software. Based on a case study in a Finnish software product company, we make two contributions. First, we studied the evaluator effect when subjectively evaluating the existence of smells in code modules. We found that the use of smells for code evaluation purposes is hard due to conflicting perceptions of different evaluators. Second, we applied source code metrics for identifying three smells and compared these results to the subjective evaluations. Surprisingly, the metrics and smell evaluations did not correlate.","1063-6773","0-7695-2213-0","10.1109/ICSM.2004.1357825","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1357825","","Software quality;Software design;Companies;Software maintenance;Software tools;Software measurement;Current measurement;Quality assessment;Programming;Internet","program diagnostics;software houses;software metrics;software performance evaluation","subjective evaluation;bad code smell;poor software structures;Finnish software product company;code modules;code evaluation;source code metrics","","30","","","IEEE","22 Nov 2004","","","IEEE","IEEE Conferences"
"An evaluation of clone detection techniques for crosscutting concerns","M. Bruntink; A. van Deursen; T. Tourwe; R. van Engelen","Centrum voor Wiskunde en Informatica, Amsterdam, Netherlands; Centrum voor Wiskunde en Informatica, Amsterdam, Netherlands; Centrum voor Wiskunde en Informatica, Amsterdam, Netherlands; ASML Netherlands B.V., Veldhoven, Netherlands","20th IEEE International Conference on Software Maintenance, 2004. Proceedings.","22 Nov 2004","2004","","","200","209","Code implementing a crosscutting concern is often spread over many different parts of an application. Identifying such code automatically greatly improves both the maintainability and the evolvability of the application. First of all, it allows a developer to more easily find the places in the code that must be changed when the concern changes, and thus makes such changes less time consuming and less prone to errors. Second, it allows a developer to refactor the code, so that it uses modern and more advanced abstraction mechanisms, thereby restoring its modularity. We evaluate the suitability of clone detection as a technique for the identification of crosscutting concerns. To that end, we manually identify four specific concerns in an industrial C application, and analyze to what extent clone detection is capable of finding these concerns. We consider our results as a stepping stone toward an automated ""concern miner"" based on clone detection.","1063-6773","0-7695-2213-0","10.1109/ICSM.2004.1357804","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1357804","","Cloning;Computer languages;Application software;Software systems;Scattering;Mathematics;Computer science;Computer errors;Programming;Detection algorithms","software maintenance;C language;data flow analysis","clone detection;crosscutting concerns;code refactoring;industrial C application;automated concern miner","","44","","19","IEEE","22 Nov 2004","","","IEEE","IEEE Conferences"
"Dex: a semantic-graph differencing tool for studying changes in large code bases","S. Raghavan; R. Rohana; D. Leon; A. Podgurski; V. Augustine","Electrical Engineering & Computer Science Department, Case Western Reserve University, Cleveland, OH, USA; Electrical Engineering & Computer Science Department, Case Western Reserve University, Cleveland, OH, USA; Electrical Engineering & Computer Science Department, Case Western Reserve University, Cleveland, OH, USA; Electrical Engineering & Computer Science Department, Case Western Reserve University, Cleveland, OH, USA; Electrical Engineering & Computer Science Department, Case Western Reserve University, Cleveland, OH, USA","20th IEEE International Conference on Software Maintenance, 2004. Proceedings.","22 Nov 2004","2004","","","188","197","This paper describes an automated tool called Dex (difference extractor) for analyzing syntactic and semantic changes in large C-language code bases. It is applied to patches obtained from a source code repository, each of which comprises the code changes made to accomplish a particular task. Dex produces summary statistics characterizing these changes for all of the patches that are analyzed. Dex applies a graph differencing algorithm to abstract semantic graphs (ASGs) representing each version. The differences are then analyzed to identify higher-level program changes. We describe the design of Dex, its potential applications, and the results of applying it to analyze bug fixes from the Apache and GCC projects. The results include detailed information about the nature and frequency of missing condition defects in these projects.","1063-6773","0-7695-2213-0","10.1109/ICSM.2004.1357803","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1357803","","Statistical analysis;Application software;Frequency;History;Software engineering;Control systems;Computer science;Software systems;Software testing;Software debugging","software tools;program debugging;C language","semantic-graph differencing tool;automated tool;difference extractor;large C-language code bases;source code repository;abstract semantic graphs;higher-level program changes;Apache;GCC","","44","2","29","IEEE","22 Nov 2004","","","IEEE","IEEE Conferences"
"Migrating interface implementations to aspects","P. Tonella; M. Ceccato","Centro per la Ricerca Scientifica e Tecnologica, ITC IRST, Trento, Italy; Centro per la Ricerca Scientifica e Tecnologica, ITC IRST, Trento, Italy","20th IEEE International Conference on Software Maintenance, 2004. Proceedings.","22 Nov 2004","2004","","","220","229","Separation of concerns and modularization are the cornerstones of software engineering. However, when a system is decomposed into units, functionalities often emerge which cannot be assigned to a single element of the decomposition. The implementation of interfaces represents a typical instance of this problem. In fact, the code that defines the interface methods is often scattered across several classes in the system and tangled with the original code. Aspect oriented programming provides mechanisms for the dynamic and static composition of transversal functionalities, that can be used to factor out the implementation of interfaces. We describe a technique for the identification of those interface implementations that are most likely to represent crosscutting concerns. Moreover, the code transformation (refactoring) to migrate such interfaces to aspects is also presented. Experimental results validate the approach.","1063-6773","0-7695-2213-0","10.1109/ICSM.2004.1357806","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1357806","","Functional programming;Scattering;Dynamic programming;Software systems;Software engineering;Engineering management;Mutual coupling;Computer architecture;Information retrieval;Graphical user interfaces","object-oriented programming;software engineering","interface implementation migration;software engineering;interface method;aspect oriented programming;dynamic composition;static composition;transversal functionality;code transformation","","8","","18","IEEE","22 Nov 2004","","","IEEE","IEEE Conferences"
"Advanced slicing of sequential and concurrent programs","J. Krinke","FernUniversität Hagen, Germany","20th IEEE International Conference on Software Maintenance, 2004. Proceedings.","22 Nov 2004","2004","","","464","468","Program slicing is a technique to identify statements that may influence the computations in other statements. Despite the ongoing research of almost 25 years, program slicing still has problems that prevent a widespread use: Sometimes, slices are too big to understand and too expensive and complicated to be computed for real-life programs. The presented thesis shows solutions to these problems: It contains various approaches which help the user to understand a slice more easily by making it more focused on the user's problem. All of these approaches have been implemented in the VALSOFT system and thorough evaluations of the proposed algorithms are presented. The underlying data structures used for slicing are program dependence graphs. They can also be used for different purposes: A new approach to clone detection based on identifying similar subgraphs in program dependence graphs is presented; it is able to detect modified clones better than other tools. In the theoretical part, this thesis presents a high-precision approach to slice concurrent procedural programs despite the fact that optimal slicing is known to be undecidable. It is the first approach to slice concurrent programs that does not rely on inlining of called procedures.","1063-6773","0-7695-2213-0","10.1109/ICSM.2004.1357836","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1357836","","Cloning;Data structures;Programming profession;Computer science;Concurrent computing;Java;User interfaces;Software maintenance;Data mining;Data flow computing","program slicing;data structures;graph theory;programming","sequential program slicing;concurrent program slicing;real-life programs;VALSOFT system;data structures;program dependence graphs;clone detection;concurrent procedural programs","","9","","24","IEEE","22 Nov 2004","","","IEEE","IEEE Conferences"
"Evaluating clone detection techniques from a refactoring perspective","F. Van Rysselberghe; S. Demeyer","Lab On Re-Engineering, University of Antwerp, Antwerp, Belgium; Lab On Re-Engineering, University of Antwerp, Antwerp, Belgium","Proceedings. 19th International Conference on Automated Software Engineering, 2004.","18 Oct 2004","2004","","","336","339","In the last decade, several researchers have investigated techniques to automatically detect duplicated code in programs exceeding hundreds of thousands lines of code. All of these techniques have known merits and deficiencies, but as of today, little is known on how these techniques fit into the refactoring process of object-oriented systems. This work compares three representative detection techniques (simple line matching, parameterized matching, and metric fingerprints) by means of five small to medium sized cases and analyses the differences between the reported matches. Based on this comparison, we conclude that (1) simple line matching is best suited for a partial, yet advanced restructuring with little effort; (2) metric fingerprints work best for refactoring a system with minimal effort; (3) parameterized matching demands more effort yet allows a more profound, less obvious restructuring of the code.","1938-4300","0-7695-2131-2","10.1109/ASE.2004.1342759","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1342759","","Cloning;Java;Fingerprint recognition;Classification tree analysis;Buildings;Pattern matching;Lab-on-a-chip;Software engineering","program diagnostics;object-oriented programming;software performance evaluation;software metrics","clone detection;duplicated code detection;refactoring process;object-oriented systems;simple line matching;parameterized matching;metric fingerprints;code restructuring;code cloning","","29","","20","IEEE","18 Oct 2004","","","IEEE","IEEE Conferences"
"Automatic method completion","R. Hill; J. Rideout","Department of Computer Science, University of Toronto, Toronto, ONT, Canada; Department of Computer Science, University of Toronto, Toronto, ONT, Canada","Proceedings. 19th International Conference on Automated Software Engineering, 2004.","18 Oct 2004","2004","","","228","235","Modern software development environments include tools to help programmers write code efficiently and accurately. For example many integrated development environments include variable name completion, method name completion and recently refactoring tools have been added to some environments. This work extends the idea of automatic completion to include completion of the body of a method by employing machine learning algorithms on the near duplicate code segments that frequently exist in large software projects.","1938-4300","0-7695-2131-2","10.1109/ASE.2004.1342740","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1342740","","Cloning;Java;Programming profession;Software systems;Detectors;Computer science;Educational institutions;Machine learning algorithms;Heart;Software maintenance","learning (artificial intelligence);program compilers;software engineering","automatic method completion;software development environments;integrated development environments;variable name completion;method name completion;refactoring tools;large software project;machine learning;duplicate code segment","","39","1","14","IEEE","18 Oct 2004","","","IEEE","IEEE Conferences"
"Aspect mining using event traces","S. Breu; J. Krinke","MCT/NASA Ames, USA; Fern Universität Hagen, Germany","Proceedings. 19th International Conference on Automated Software Engineering, 2004.","18 Oct 2004","2004","","","310","315","Aspect mining tries to identify crosscutting concerns in existing systems and thus supports the adaption to an aspect-oriented design. This work describes the first aspect mining approach that detects crosscutting concerns in legacy systems based on dynamic analysis. The analysis uses program traces that are generated in different program executions as underlying data pool. These traces are then investigated for recurring execution patterns based on different constraints, such as the requirement that the patterns have to exist in different calling contexts in the program trace. The implemented approach was evaluated in several case studies over systems with more than 80 kLoC. The tool was able to identify automatically both existing and seeded crosscutting concerns.","1938-4300","0-7695-2131-2","10.1109/ASE.2004.1342754","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1342754","","Software systems;Runtime;Information analysis;Algorithm design and analysis;Software algorithms;NASA;Software maintenance;Timing;Heuristic algorithms;Data mining","system monitoring;object-oriented programming;software maintenance","aspect mining;event traces;aspect-oriented design;legacy systems;dynamic analysis;program traces;program executions;program trace;execution patterns","","55","2","12","IEEE","18 Oct 2004","","","IEEE","IEEE Conferences"
"Fast paths in concurrent programs","W. Xu; Sanjeev Kumar; K. Li","Department of Computer Science, Princeton University, USA; Intel Cornoration, INTEL, Research Laboratory, USA; Department of Computer Science, Princeton University, USA","Proceedings. 13th International Conference on Parallel Architecture and Compilation Techniques, 2004. PACT 2004.","18 Oct 2004","2004","","","189","200","Compiling concurrent programs to run on a sequential processor presents a difficult tradeoff between execution time and size of generated code. On one hand, the process-based approach to compilation generates reasonable sized code but incurs significant execution overhead due to concurrency. On the other hand, the automata-based approach incurs a much smaller execution overhead but can result in code that is several orders of magnitude larger. We propose a way of combining the two approaches so that the performance of the automata-based approach can be achieved without suffering the code size increase due to it. The key insight is that the best of the two approaches can be achieved by using symbolic execution (similar to the automata-based approach) to generate code for the commonly executed paths (referred to as fast paths) and using the process-based approach to generate code for the rest of the program. We demonstrate the effectiveness of this approach by implementing our techniques in the ESP compiler and applying them to a set of filter programs and to VMMC network firmware.","1089-795X","0-7695-2229-7","10.1109/PACT.2004.1342553","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1342553","","Programming profession;Concurrent computing;Yarn;Computer science;Automatic control;Electrostatic precipitators;Program processors;Filters;Microprogramming;User interfaces","multiprocessing programs;optimising compilers;multiprocessing systems;program control structures","concurrent program compilation;sequential processor;automata-based approach;fast path optimization;ESP compiler;filter programs;VMMC network firmware","","","","32","IEEE","18 Oct 2004","","","IEEE","IEEE Conferences"
"From goals to aspects: discovering aspects from requirements goal models","Yijun Yu; J. C. S. P. Leite; J. Mylopoulos","University of Toronto, Toronto, ON, CA; Dept. of Comput. Sci., Toronto Univ., Ont., Canada; Department of Computer Science, University of Toronto, Canada","Proceedings. 12th IEEE International Requirements Engineering Conference, 2004.","20 Sep 2004","2004","","","38","47","Aspect-oriented programming (AOP) has been attracting much attention in the software engineering community by advocating that programs should be structured according to programmer concerns, such as ""efficient use of memory"". However, like other programming paradigms in their early days, AOP hasn't addressed yet earlier phases of software development. In particular, it is still an open question how one identifies aspects early on in the software development process. This work proposes an answer to this question. Specifically, we show that aspects can be discovered during goal-oriented requirements analysis. Our proposal includes a systematic process for discovering aspects from relationships between functional and nonfunctional goals. We illustrate the proposed process with a case study adapted from the literature.","1090-705X","0-7695-2174-6","10.1109/ICRE.2004.1335662","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1335662","","Software systems;Proposals;Computer science;Software engineering;Programming profession;Software maintenance","formal specification;object-oriented programming","requirements goal models;aspect-oriented programming;software engineering community;software development;goal-oriented requirements analysis;functional goals;nonfunctional goals","","16","","26","IEEE","20 Sep 2004","","","IEEE","IEEE Conferences"
"Aiding comprehension of cloning through categorization","C. Kapser; M. W. Godfrey","Software Architecture Group (SWAG), School of Computer Science, University of Waterloo, Canada; Software Architecture Group (SWAG), School of Computer Science, University of Waterloo, Canada","Proceedings. 7th International Workshop on Principles of Software Evolution, 2004.","20 Sep 2004","2004","","","85","94","Management of duplicated code in software systems is important in ensuring its graceful evolution. Commonly clone detection tools return large numbers of detected clones with little or no information about them, making clone management impractical and unscalable. We have used taxonomy of clones to augment current clone detection tools in order to increase the user comprehension of duplication of code within software systems and filter false positives from the clone set. We support our arguments by means of 2 case studies, where we found that as much as 53% of clones can be grouped to form function clones or partial function clones and we were able to filter out as many as 65% of clones as false positives from the reported clone pairs.","1550-4077","0-7695-2211-4","10.1109/IWPSE.2004.1334772","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1334772","","Cloning;Software systems;Software architecture;Computer science;Taxonomy;Computer bugs;Information filtering;Information filters;Software tools;Graphical user interfaces","software maintenance;software tools;program diagnostics;software prototyping;program compilers","cloning comprehension;clone categorization;duplicated code management;software systems;software evolution;clone detection tools;clone management;partial function clones","","30","","23","IEEE","20 Sep 2004","","","IEEE","IEEE Conferences"
"An automatic approach to identify class evolution discontinuities","G. Antoniol; M. Di Penta; E. Merlo","RCOST-Research Centre on Software Technology, Department of Engineering, University of Sannio, Benevento, Italy; RCOST-Research Centre on Software Technology, Department of Engineering, University of Sannio, Benevento, Italy; RCOST-Research Centre on Software Technology, Department of Engineering, École Polytechnique de Montréal, Montreal, Canada","Proceedings. 7th International Workshop on Principles of Software Evolution, 2004.","20 Sep 2004","2004","","","31","40","When a software system evolves, features are added, removed and changed. Moreover, refactoring activities are periodically performed to improve the software internal structure. A class may be replaced by another, two classes can be merged, or a class may be split in two others. As a consequence, it may not be possible to trace software features between a release and another. When studying software evolution, we should be able to trace a class lifetime even when it disappears because it is replaced by a similar one, split or merged. Such a capability is also essential to perform impact analysis. This work proposes an automatic approach, inspired on vector space information retrieval, to identify class evolution discontinuities and, therefore, cases of possible refactoring. The approach has been applied to identify refactorings performed over 40 releases of a Java open source domain name server. Almost all the refactorings found were actually performed in the analyzed system, thus indicating the helpfulness of the approach and of the developed tool.","1550-4077","0-7695-2211-4","10.1109/IWPSE.2004.1334766","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1334766","","Software systems;Software maintenance;Software performance;Performance analysis;Information retrieval;Java;Open source software;Merging;Software development management;Programming","software maintenance;Java;object-oriented programming;public domain software","automatic approach;class evolution discontinuity identification;software evolution;refactoring activities;software internal structure improvement;software features;impact analysis;vector space information retrieval;refactoring identification;Java open source domain name server;software releases;software refactoring;software traceability","","40","1","23","IEEE","20 Sep 2004","","","IEEE","IEEE Conferences"
"An ethnographic study of copy and paste programming practices in OOPL","Miryung Kim; L. Bergman; T. Lau; D. Notkin","Department of Computer Science & Engineering, University of Washington, USA; Department of Computer Science & Engineering, IBM Thomas J. Watson Research Center, USA; Department of Computer Science & Engineering, IBM Thomas J. Watson Research Center, USA; Department of Computer Science & Engineering, University of Washington, USA","Proceedings. 2004 International Symposium on Empirical Software Engineering, 2004. ISESE '04.","20 Sep 2004","2004","","","83","92","Although programmers frequently copy and paste code when they develop software, implications of common copy and paste (C&P) usage patterns have not been studied previously. We have conducted an ethnographic study in order to understand programmers' C&P programming practices and discover opportunities to assist common C&P usage patterns. We observed programmers using an instrumented Eclipse IDE and then analyzed why and how they use C&P operations. Based on our analysis, we constructed a taxonomy of C&P usage patterns. This paper presents our taxonomy of C&P usage patterns and discusses our insights with examples drawn from our observations. From our insights, we propose a set of tools that both can reduce software maintenance problems incurred by C&P and can better support the intents of commonly used C&P scenarios.","","0-7695-2165-7","10.1109/ISESE.2004.1334896","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1334896","","Programming profession;Software engineering;Pattern analysis;Taxonomy;Software maintenance;Computer languages;Cloning;History;Software tools;Computer science","object-oriented programming;object-oriented languages;software maintenance","ethnographic study;copy and paste programming;OOPL;copy and paste code;software development;copy and paste usage patterns;Eclipse IDE;copy and paste operations;software tools;software maintenance problems;object-oriented programming language","","49","","19","IEEE","20 Sep 2004","","","IEEE","IEEE Conferences"
"Managing trace data volume through a heuristical clustering process based on event execution frequency","A. Zaidman; S. Demeyer","Department of Mathematics and Computer Science, Laboratory On Re-Engineering, University of Antwerp, Antwerp, Belgium; Department of Mathematics and Computer Science, Laboratory On Re-Engineering, University of Antwerp, Antwerp, Belgium","Eighth European Conference on Software Maintenance and Reengineering, 2004. CSMR 2004. Proceedings.","24 Aug 2004","2004","","","329","338","To regain architectural insight into a program using dynamic analysis, one of the major stumbling blocks remains the large amount of trace data collected. Therefore, this paper proposes a heuristic which divides the trace data into recurring event clusters. To compose such clusters the Euclidian distance is used as a dissimilarity measure on the frequencies of the events. Manual inspection of these event sequences revealed that the heuristic provides interesting starting points for further examination.","1534-5351","0-7695-2107-X","10.1109/CSMR.2004.1281435","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1281435","","Programming profession;Software systems;Reverse engineering;Protocols;Mathematics;Computer science;Frequency measurement;Inspection;Bridges;Writing","program diagnostics;pattern clustering;reverse engineering;program visualisation","trace data volume;heuristical clustering process;event execution frequency;program dynamic analysis;Euclidian distance","","25","2","20","IEEE","24 Aug 2004","","","IEEE","IEEE Conferences"
"Source code modularization using lattice of concept slices","R. Al-Ekram; K. Kontogiannis","Department of Electrical and Computer Engineering, University of Waterloo, Waterloo, ONT, Canada; Department of Electrical and Computer Engineering, University of Waterloo, Waterloo, ONT, Canada","Eighth European Conference on Software Maintenance and Reengineering, 2004. CSMR 2004. Proceedings.","24 Aug 2004","2004","","","195","203","Most legacy systems have been altered due to prolonged maintenance to the point that they deviate significantly from their original and intended design and consequently, they lack modularity. Static source code analysis techniques like concept assignment, formal concept analysis and program slicing, have been successfully used by researchers for program understanding and for restoring system design properties. In our approach we combine these three techniques, aiming to gain on their individual strengths and overcoming their weaknesses. Here we present a program representation formalism that we call the lattice of concept slices and a program modularization technique that aims to separate statements in a code fragment according to the concept they implement or they may belong to. The lattice shows the relationship between the statements of a program and the domain concepts that might be implemented by the statements. Using the lattice as a primary data structure we present two algorithms for decomposing the program into appropriate modules. The goal is to achieve a modularization such that the modules are self-contained, side effect free and the code duplication among nodes is minimal. The modularization process is illustrated with an example C program.","1534-5351","0-7695-2107-X","10.1109/CSMR.2004.1281420","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1281420","","Lattices;Data structures;Algorithms;System analysis and design;Software systems;Data mining;Books;Software maintenance","program slicing;reverse engineering;software maintenance","source code modularization;lattice of concept slices;software maintenance;static source code analysis;formal concept analysis;program slicing;program understanding;program representation formalism;program modularization","","7","","17","IEEE","24 Aug 2004","","","IEEE","IEEE Conferences"
"Supporting architectural restructuring by analyzing feature models","I. Pashov; M. Riebisch; I. Philippow","Technical University Ilmenau, Germany; Technical University Ilmenau, Germany; Technical University Ilmenau, Germany","Eighth European Conference on Software Maintenance and Reengineering, 2004. CSMR 2004. Proceedings.","24 Aug 2004","2004","","","25","34","In order to lower the risk, reengineering projects aim at high reuse rates. Therefore, tasks like architectural restructuring have to be performed in a way that developed new system architectures allow reuse of all valuable legacy systems' parts with minimal changes. During architectural restructuring there are two major types of modification: detection of architecture disproportions and their refactoring and detection of redundancies and their fusion. We introduce a method for applying domain knowledge for supporting these restructuring steps. The method operates on feature models. Words and terms of features and of architectural documents are analyzed by cluster analysis, information retrieval and metrics techniques. In this way, the method joins the approaches of feature analysis and of enhancing reengineering with domain knowledge by applying feature models for structuring the domain knowledge. The method results in clues and hints for the development of a new architecture. It provides an effective addition to the conventional software architecture design methods. The method was developed and applied in an industrial reengineering project within image processing domain. It has been proved to be applicable to large and complex systems even in case of heavy monolithic parts. We use examples from this project to illustrate the method.","1534-5351","0-7695-2107-X","10.1109/CSMR.2004.1281403","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1281403","","Information analysis;Computer architecture;Documentation;Information retrieval;Software architecture;Design methodology;Image processing;Bridges;Redundancy;Software maintenance","software architecture;software maintenance;software reusability;reverse engineering;software metrics;systems re-engineering;information retrieval;pattern clustering","architectural restructuring;system architectures;legacy systems;architecture disproportions detection;redundancy detection;feature models method;cluster analysis;information retrieval;metrics techniques;software architecture design methods;industrial reengineering project;image processing domain","","5","1","27","IEEE","24 Aug 2004","","","IEEE","IEEE Conferences"
"Automated source code transformations on fourth generation languages","J. Martin; J. Gutenberg","Johannes Gutenberg Universitat Mainz, Mainz, Rheinland-Pfalz, DE; Mainz Univ., Germany","Eighth European Conference on Software Maintenance and Reengineering, 2004. CSMR 2004. Proceedings.","24 Aug 2004","2004","","","214","220","To control the operation of large application suites or to tailor a special purpose application to particular need, developers frequently use application specific languages, such as batch, scripting, and query languages. These languages which are also referred to as fourth generation languages (4GLs) therefore play an important role in today's economy. Incompatibilities between different versions of 4GLs and changing requirements may make massive changes on a company's library of 4GL programs necessary. Here, we explore possibilities for performing mass changes on 4GLs and show how the transformation of programs written in 4GLs compares to the transformation of mainstream programming languages.","1534-5351","0-7695-2107-X","10.1109/CSMR.2004.1281422","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1281422","","Computer languages;MATLAB;Software libraries;Automatic control;Database languages;Spatial databases;Java;Programming profession;Web pages;Prototypes","high level languages;automatic programming;program compilers","automated source code transformation;fourth generation language;application specific language;query language","","1","","15","IEEE","24 Aug 2004","","","IEEE","IEEE Conferences"
"Towards reengineering Web sites to Web-services providers","Y. Jiang; E. Stroulia","Department of Computing Science, University of Alberta, Edmonton, AB, Canada; Department of Computing Science, University of Alberta, Edmonton, AB, Canada","Eighth European Conference on Software Maintenance and Reengineering, 2004. CSMR 2004. Proceedings.","24 Aug 2004","2004","","","296","305","The Web-services stack of standards is aimed at facilitating the development of Web applications by integrating software components, developed across organizational boundaries. This flexible integration relies on the specification of the components services in terms of an open, XML-based standard, WSDL. A critical step in the process of reusing existing, WSDL-specified components is the availability of a multitude of such components. Automated re-engineering methods for constructing Web services out of functionalities already offered by existing Web sites can therefore play an important role in facilitating the adoption of these standards. In this paper, we describe our work on reverse-engineering the interaction between Web-site servers and client browsers into XML specifications, syntactically and semantically close to WSDL.","1534-5351","0-7695-2107-X","10.1109/CSMR.2004.1281432","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1281432","","Web services;Web server;Software standards;Standards development;Standards organizations;Application software;Simple object access protocol;HTML;XML;Web sites","Web design;reverse engineering;systems re-engineering;XML;client-server systems;Internet;object-oriented programming;formal specification","Web site reengineering;Web-services providers;software components integration;XML-based standard;reverse-engineering","","10","4","17","IEEE","24 Aug 2004","","","IEEE","IEEE Conferences"
"Predicting source code changes by mining change history","A. T. T. Ying; G. C. Murphy; R. Ng; M. C. Chu-Carroll","IBM Thomas J. Watson Research Center, Hawthorne, NY, USA; Department of Computer Science, University of British Columbia, Vancouver, BC, Canada; Department of Computer Science, University of British Columbia, Vancouver, BC, Canada; IBM Thomas J. Watson Research Center, Hawthorne, NY, USA","IEEE Transactions on Software Engineering","24 Aug 2004","2004","30","9","574","586","Software developers are often faced with modification tasks that involve source which is spread across a code base. Some dependencies between source code, such as those between source code written in different languages, are difficult to determine using existing static and dynamic analyses. To augment existing analyses and to help developers identify relevant source code during a modification task, we have developed an approach that applies data mining techniques to determine change patterns - sets of files that were changed together frequently in the past - from the change history of the code base. Our hypothesis is that the change patterns can be used to recommend potentially relevant source code to a developer performing a modification task. We show that this approach can reveal valuable dependencies by applying the approach to the Eclipse and Mozilla open source projects and by evaluating the predictability and interestingness of the recommendations produced for actual modification tasks on these systems.","1939-3520","","10.1109/TSE.2004.52","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1324645","Index Terms- Enhancement;maintainability;clustering;classification;association rules;data mining.","History;Data mining;Association rules;Pattern analysis;Computer Society;Software systems;Computer languages;Frequency;Programming profession;Computer science","data mining;software tools;program verification;software maintenance;configuration management","software developers;modification task;code base;source code changes prediction;data mining technique;change history;Eclipse open source project;Mozilla open source project;software maintainability;pattern clustering;pattern classification;association rules","","330","21","29","IEEE","24 Aug 2004","","","IEEE","IEEE Journals"
