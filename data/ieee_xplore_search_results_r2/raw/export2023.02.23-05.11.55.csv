"Document Title",Authors,"Author Affiliations","Publication Title",Date Added To Xplore,"Publication Year","Volume","Issue","Start Page","End Page","Abstract","ISSN",ISBNs,"DOI",Funding Information,PDF Link,"Author Keywords","IEEE Terms","INSPEC Controlled Terms","INSPEC Non-Controlled Terms","Mesh_Terms",Article Citation Count,Patent Citation Count,"Reference Count","License",Online Date,Issue Date,"Meeting Date","Publisher",Document Identifier
"Clone Smells in Software Evolution","T. Bakota; R. Ferenc; T. Gyimothy","Department of Software Engineering, University of Szeged, Hungary; Department of Software Engineering, University of Szeged, Hungary; Department of Software Engineering, University of Szeged, Hungary","2007 IEEE International Conference on Software Maintenance","22 Oct 2007","2007","","","24","33","Although source code cloning (copy&paste programming) represents a significant threat to the maintainability of a software system, problems usually start to arise only when the system evolves. Most of the related research papers tackle the question of finding code clones in one particular version of the software only, leaving the dynamic behavior of the clones out of consideration. Eliminating these clones in large software systems often seems absolutely hopeless, as there might exist several thousands of them. Alternatively, tracking the evolution of individual clones can be used to identify those occurrences that could really cause problems in the future versions. In this paper we present an approach for mapping clones from one particular version of the software to another one, based on a similarity measure. This mapping is used to define conditions under which clones become suspicious (or ""smelly"") compared to their other occurrences. Accordingly, these conditions introduce the notion of dynamic clone smells. The usefulness of these smells is validated on the Mozilla Firefox internet browser, where the approach was able to find specific bugs that resulted from neglecting earlier copy&paste activities.","1063-6773","978-1-4244-1255-6","10.1109/ICSM.2007.4362615","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4362615","","Cloning;Software systems;Software maintenance;Computer bugs;Programming profession;Software engineering;Genetic programming;Particle measurements;Software measurement;Internet","Internet;software maintenance;software prototyping","software evolution;source code cloning;software maintenance;Mozilla Firefox Internet browser","","50","","26","IEEE","22 Oct 2007","","","IEEE","IEEE Conferences"
"A model to predict anti-regressive effort in Open Source Software","A. Capiluppi; J. Fernandez-Ramil","Department of Computing and Informatics, University of Lincoln, UK; Computing Department, The Open University, UK","2007 IEEE International Conference on Software Maintenance","22 Oct 2007","2007","","","194","203","Accumulated changes on a software system are not uniformly distributed: some elements are changed more often than others. For optimal impact, the limited time and effort for complexity control, called anti-regressive work, should be applied to the elements of the system which are frequently changed and are complex. Based on this, we propose a maintenance guidance model (MGM) which is tested against real-world data. MGM takes into account several dimensions of complexity: size, structural complexity and coupling. Results show that maintainers of the eight open source systems studied tend, in general, to prioritize their anti-regressive work in line with the predictions given by our MGM, even though, divergences also exist. MGM offers a history-based alternative to existing approaches to the identification of elements for anti-regressive work, most of which use static code characteristics only.","1063-6773","978-1-4244-1255-6","10.1109/ICSM.2007.4362632","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4362632","ANTI-REGRESSIVE WORK;COUPLING;EMPIRICAL STUDIES;MCCABE CYCLOMATIC COMPLEXITY;MAINTENANCE;METRICS;OPEN SOURCE;SoFTWARE EVOLUTION","Predictive models;Open source software;Software systems;Informatics;Optimal control;Control systems;Software testing;System testing;Documentation;Knowledge management","public domain software;software metrics","open source software;complexity control;antiregressive work;maintenance guidance model","","5","","28","IEEE","22 Oct 2007","","","IEEE","IEEE Conferences"
"Mining the Lexicon Used by Programmers during Sofware Evolution","G. Antoniol; Y. -G. Gueheneuc; E. Merlo; P. Tonella","Soccer Laboratory, DGI, École Polytechnique de Montréal, Canada; GEODES Laboratory, DIRO, University of Montréal, Canada; Soccer Laboratory, DGI, École Polytechnique de Montréal, Canada; Fondazione Bruno Kessler (FBK), Trento, Italy","2007 IEEE International Conference on Software Maintenance","22 Oct 2007","2007","","","14","23","Identifiers represent an important source of information for programmers understanding and maintaining a system. Self-documenting identifiers reduce the time and effort necessary to obtain the level of understanding appropriate for the task at hand. While the role of the lexicon in program comprehension has long been recognized, only a few works have studied the quality and enhancement of the identifiers and no works have studied the evolution of the lexicon. In this paper, we characterize the evolution of program identifiers in terms of stability metrics and occurrences of renaming. We assess whether an evolution process similar to the one occurring for the program structure exists for identifiers. We report data and results about the evolution of three large systems, for which several releases are available. We have found evidence that the evolution of the lexicon is more limited and constrained than the evolution of the structure. We argue that the different evolution results from several factors including the lack of advanced tool support for lexicon construction, documentation, and evolution.","1063-6773","978-1-4244-1255-6","10.1109/ICSM.2007.4362614","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4362614","","Programming profession;Stability;Software maintenance;Structural engineering;System testing;Information resources;Documentation;Personnel;Preventive maintenance;Frequency","configuration management;data mining;software maintenance;software metrics;software prototyping;software quality","software evolution process;lexicon mining;self-documenting identifiers;program comprehension;stability metrics;software maintenance;system version;software quality","","22","","22","IEEE","22 Oct 2007","","","IEEE","IEEE Conferences"
"An Activity-Based Quality Model for Maintainability","F. Deissenboeck; S. Wagner; M. Pizka; S. Teuchert; J. . -F. Girard","Institut füir Informatik, Technische Universität München, Garching, Germany; Institut füir Informatik, Technische Universität München, Garching, Germany; Institut füir Informatik, Technische Universität München, Garching, Germany; Elektronik Regelungs-und Steuerungssysteme (TSE), MAN Nutzfahrzeuge AG, Munchen, Germany; Elektronik Regelungs-und Steuerungssysteme (TSE), MAN Nutzfahrzeuge AG, Munchen, Germany","2007 IEEE International Conference on Software Maintenance","22 Oct 2007","2007","","","184","193","Maintainability is a key quality attribute of successful software systems. However, its management in practice is still problematic. Currently, there is no comprehensive basis for assessing and improving the maintainability of software systems. Quality models have been proposed to solve this problem. Nevertheless, existing approaches do not explicitly take into account the maintenance activities, that largely determine the software maintenance effort. This paper proposes a 2-dimensional model of maintainability that explicitly associates system properties with the activities carried out during maintenance. The separation of activities and properties facilitates the identification of sound quality criteria and allows to reason about their interdependencies. This transforms the quality model into a structured and comprehensive quality knowledge base that is usable in industrial project environments. For example, review guidelines can be generated from it. The model is based on an explicit quality metamodel that supports its systematic construction and fosters preciseness as well as completeness. An industrial case study demonstrates the applicability of the model for the evaluation of the maintainability of Matlab Simulink models that are frequently used in model-based development of embedded systems.","1063-6773","978-1-4244-1255-6","10.1109/ICSM.2007.4362631","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4362631","","Software maintenance;Mathematical model;Software systems;Costs;Construction industry;Personnel;Terminology;Guidelines;Embedded system;Environmental economics","embedded systems;software maintenance;software quality","activity-based quality model;software maintainability;2-dimensional model;industrial project environment;metamodel;Matlab;Simulink;embedded system;model-based development","","43","","27","IEEE","22 Oct 2007","","","IEEE","IEEE Conferences"
"Introductory Computing Construct Use in an End-User Programming Community","B. Dorn; A. E. Tew; M. Guzdial","Georgia Institute of Technology, USA; Georgia Institute of Technology, USA; Georgia Institute of Technology, USA","IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC 2007)","22 Oct 2007","2007","","","27","32","Previous studies of end-user programmers have indicated a reliance on related examples for learning. Accordingly, we analyzed the projects contained in an online community with respect to their use of introductory computing constructs. In general, the projects resemble those of novice programmers, implying the opportunity for supporting additional learning. Project authors' attention to matters of intellectual property may also directly impact other end-users' willingness to learn.","1943-6106","978-0-7695-2987-5","10.1109/VLHCC.2007.35","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4351323","","Programming profession;Intellectual property;Computer science;Computer graphics;Application software;Java;Algorithms;Data structures;Educational programs;Books","personal computing","introductory computing;end-user programming community;online community","","7","","9","IEEE","22 Oct 2007","","","IEEE","IEEE Conferences"
"Mining Software Evolution to Predict Refactoring","J. Ratzinger; T. Sigmund; P. Vorburger; H. Gall","Institute of Information Systems, University of Technology, Vienna, Vienna, Austria; Institute of Information Systems, University of Technology, Vienna, Vienna, Austria; Department of Informatics, University of Zurich, Zurich, Switzerland; Department of Informatics, University of Zurich, Zurich, Switzerland","First International Symposium on Empirical Software Engineering and Measurement (ESEM 2007)","15 Oct 2007","2007","","","354","363","Can we predict locations of future refactoring based on the development history? In an empirical study of open source projects we found that attributes of software evolution data can be used to predict the need for refactoring in the following two months of development. Information systems utilized in software projects provide a broad range of data for decision support. Versioning systems log each activity during the development, which we use to extract data mining features such as growth measures, relationships between classes, the number of authors working on a particular piece of code, etc. We use this information as input into classification algorithms to create prediction models for future refactoring activities. Different state-of-the-art classifiers are investigated such as decision trees, logistic model trees, prepositional rule learners, and nearest neighbor algorithms. With both high precision and high recall we can assess the refactoring proneness of object-oriented systems. Although we investigate different domains, we discovered critical factors within the development life cycle leading to refactoring, which are common among all studied projects.","1949-3789","978-0-7695-2886-1","10.1109/ESEM.2007.9","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4343763","","Open source software;Data mining;Object oriented modeling;History;Information systems;Software systems;Feature extraction;Particle measurements;Classification algorithms;Prediction algorithms","data mining;decision trees;object-oriented methods;software engineering","mining software evolution;development history;open source projects;software projects;decision support;versioning systems;data mining features;decision trees;logistic model trees;prepositional rule learners;object-oriented systems","","36","","21","IEEE","15 Oct 2007","","","IEEE","IEEE Conferences"
"Requirement and Design Trade-offs in Hackystat: An In-Process Software Engineering Measurement and Analysis System","P. M. Johnson","Collaborative Software Development Laboratory Department of Information and Computer Sciences, University of Hawai, Honolulu, HI, USA","First International Symposium on Empirical Software Engineering and Measurement (ESEM 2007)","15 Oct 2007","2007","","","81","90","For five years, the Hackystat project has incremen tally developed and evaluated a generic framework for in process software engineering measurement and analysis (ISEMA). At least five other independent ISEMA system development projects have been initiated during this time, indicating growing interest and investment in this approach by the software engineering community. This pa per presents 12 important requirement and design trade offs made in the Hackystat system, some of their implications for organizations wishing to introduce ISEMA, and six directions for future research and development. The three goals of this paper are to: (1) help potential users of ISEMA systems to better evaluate the relative strengths and weaknesses of current and future systems, (2) help potential developers of ISEMA systems to better understand some of the important requirement and design tradeoffs that they must make, and (3) help accelerate progress in ISEMA by identifying promising directions for future research and development.","1949-3789","978-0-7695-2886-1","10.1109/ESEM.2007.36","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4343735","","Software engineering;Software measurement;Size measurement;Sensor systems;Research and development;Programming;Information analysis;Collaborative software;Data analysis;Humans","software engineering","inprocess software engineering measurement;ISEMA;Hackystat system","","24","","16","IEEE","15 Oct 2007","","","IEEE","IEEE Conferences"
"Detecting Change in Program Behavior for Adaptive Optimization","N. Peleg; B. Mendelson","IBM Haifa Research Laboratory, Israel; IBM Haifa Research Laboratory, Israel","16th International Conference on Parallel Architecture and Compilation Techniques (PACT 2007)","1 Oct 2007","2007","","","150","162","Feedback information has proven useful in guiding optimizations in compilers and post-link optimizers. Program performance behavior can change over time and may invalidate the feedback information. Low overhead monitoring can be used to detect such changes, using performance metrics such as CPI. On a loaded SMT system, where other threads are simultaneously activated on the same CPU, the CPI shows large variability. We introduce an efficient monitoring method that is insensitive to other activities in the system and can be safely used to collect program behavior on a loaded SMT system. The overhead of this method is 0.58% with SPECint2000. We also introduce a novel transformation to the program behavior representation, which makes it insensitive to code optimizations and enables a comparison of the program behavior collected in different optimization cycles. This approach opens new opportunities and enables adaptive optimizations on modern SMT architectures.","1089-795X","978-0-7695-2944-8","10.1109/PACT.2007.4336208","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4336208","","Monitoring;Optimizing compilers;Surface-mount technology;Feedback;Measurement;Yarn;Frequency;Runtime;Databases;Sampling methods","feedback;program compilers","program behavior;adaptive optimization;compilers;post-link optimizers;feedback information;monitoring method;loaded SMT system;program behavior representation","","9","","26","IEEE","1 Oct 2007","","","IEEE","IEEE Conferences"
"A Practical Model for Measuring Maintainability","I. Heitlager; T. Kuipers; J. Visser","Software Improvement Group, Netherlands; Software Improvement Group, Netherlands; Software Improvement Group, Netherlands","6th International Conference on the Quality of Information and Communications Technology (QUATIC 2007)","1 Oct 2007","2007","","","30","39","The amount of effort needed to maintain a software system is related to the technical quality of the source code of that system. The ISO 9126 model for software product quality recognizes maintainability as one of the 6 main characteristics of software product quality, with adaptability, changeability, stability, and testability as subcharacteristics of maintainability. Remarkably, ISO 9126 does not provide a consensual set of measures for estimating maintainability on the basis of a system's source code. On the other hand, the maintainability index has been proposed to calculate a single number that expresses the maintainability of a system. In this paper, we discuss several problems with the MI, and we identify a number of requirements to be fulfilled by a maintainability model to be usable in practice. We sketch a new maintainability model that alleviates most of these problems, and we discuss our experiences with using such as system for IT management consultancy activities.","","978-0-7695-2948-6","10.1109/QUATIC.2007.8","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4335232","","Software quality;Software maintenance;ISO standards;Communication system software;Software systems;Software testing;IEC standards;Software standards;Communications technology;Software measurement","software maintenance;software quality","practical model;maintainability measurement;software system;technical quality;source code;ISO 9126 model;software product quality;maintainability index;IT management consultancy activities","","135","","34","IEEE","1 Oct 2007","","","IEEE","IEEE Conferences"
"Software Reuse Detection Using an Integrated Space-Logic Domain Model","W. Qu; M. Jiang; Y. Jia","Motorola Labs, Motorola, Inc., Schaumburg, IL, USA; Motorola Labs, Motorola, Inc., Schaumburg, IL, USA; Bioengineering Department, University of Illinois, Chicago, IL, USA","2007 IEEE International Conference on Information Reuse and Integration","4 Sep 2007","2007","","","638","643","Software reuse detection is a challenging task due to various modifications and the large size of software code. Most existing approaches adopt a token-based software representation and use sequential analysis for software reuse detection. Due to the intrinsic limitations of such a space-domain analysis, these methods have difficulties to handle statement reordering, insertion and control replacement. Recently, logic-domain models such as program dependent graph have been exploited to solve these issues. Although they can improve the performance in terms of accuracy, they introduce additional problems. Their computational complexity is very high and dramatically increases with the software size, limiting their applications in practice. In this paper, we propose a novel software reuse detection framework using an integrated space-logic domain model. It embeds a logic-domain software model into a space-domain analysis and thoroughly exploits the software 's information from both space domain and logic domain. The preliminary experimental results have demonstrated the superior performance of the proposed approach compared with other methods.","","1-4244-1499-7","10.1109/IRI.2007.4296692","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4296692","","Sequential analysis;Plagiarism;Computational complexity;Open source software;Application software;Embedded software;Filters;Software debugging;Biomedical engineering;Information analysis","formal logic;software reusability","software reuse detection;integrated space-logic domain model;software code;token-based software representation;use sequential analysis","","2","1","14","IEEE","4 Sep 2007","","","IEEE","IEEE Conferences"
"Comparison and Evaluation of Clone Detection Tools","S. Bellon; R. Koschke; G. Antoniol; J. Krinke; E. Merlo","Axivion GmbH, Stuttgart, Germany; Universitat Bremen, Bremen, Germany; Département de Génie Informatique, École Polytechnique de Montréal, Canada; FernUniversität Hagen, Hagen, Germany; Department of Computer Engineering, Ecole Polytechnique Montreal, Montreal, QUE, Canada","IEEE Transactions on Software Engineering","13 Aug 2007","2007","33","9","577","591","Many techniques for detecting duplicated source code (software clones) have been proposed in the past. However, it is not yet clear how these techniques compare in terms of recall and precision as well as space and time requirements. This paper presents an experiment that evaluates six clone detectors based on eight large C and Java programs (altogether almost 850 KLOC). Their clone candidates were evaluated by one of the authors as independent third party. The selected techniques cover the whole spectrum of the state-of-the-art in clone detection. The techniques work on text, lexical and syntactic information, software metrics, and program dependency graphs.","1939-3520","","10.1109/TSE.2007.70725","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4288192","Redundant code;duplicated code;software clones","Cloning;Computer Society;Detectors;Java;Software metrics;Concrete;Software tools;Visualization;Fingerprint recognition;Abstracts","program diagnostics;program verification;software metrics","clone detection tool;duplicated source code detection;text information;lexical information;syntactic information;software metrics;program dependency graphs","","463","1","44","IEEE","13 Aug 2007","","","IEEE","IEEE Journals"
"Finding Clones with Dup: Analysis of an Experiment","B. S. Baker","Berkeley Heights, NJ, USA","IEEE Transactions on Software Engineering","13 Aug 2007","2007","33","9","608","621","An experiment was carried out by a group of scientists to compare different tools and techniques for detecting duplicated or near-duplicated source code. The overall comparative results are presented elsewhere. This paper takes a closer look at the results for one tool, Dup, which finds code sections that are textually the same or the same except for systematic substitution of parameters such as identifiers and constants. Various factors that influenced the results are identified and their impact on the results is assessed via rerunning Dup with changed options and modifications. These improve the performance of Dup with regard to the experiment and could be incorporated into a postprocessor to be used with other tools.","1939-3520","","10.1109/TSE.2007.70720","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4288194","Redundant code;duplicated code;softwareclones","Cloning;Java;Computer bugs;Plagiarism;Data structures;Design methodology;Software tools;Tree graphs;Particle measurements","software reusability;software tools","Dup;source code;code sections;systematic substitution;postprocessor","","42","","18","IEEE","13 Aug 2007","","","IEEE","IEEE Journals"
"Bad-Smell Metrics for Aspect-Oriented Software","K. Srivisut; P. Muenchaisri","Software Engineering Laboratory, Center of Excellence in Software Engineering, Department of Computer Engineering, Faculty of Engineering, Chulalongkom University, Bangkok, Thailand; Software Engineering Laboratory, Center of Excellence in Software Engineering, Department of Computer Engineering, Faculty of Engineering, Chulalongkom University, Bangkok, Thailand","6th IEEE/ACIS International Conference on Computer and Information Science (ICIS 2007)","23 Jul 2007","2007","","","1060","1065","Aspect-oriented programming (AOP) is a new programming paradigm that improves separation of concerns by decomposing the crosscutting concerns in aspect modules. Bad smells are metaphors to describe software patterns that are generally associated with bad design and bad programming of object-oriented programming (OOP). New notions and different ways of thinking for developing aspect-oriented (AO) software inevitably introduce bad smells which are specific bad design and bad programming in AO software called AO bad smells. Software metrics have been used to measure software artifact for a better understanding of its attributes and to assess its quality. Bad-smell metrics should be used as indicators for determining whether a particular fraction of AO code contains bad smells or not. Therefore, this paper proposes definition of metrics corresponding to the characteristic of each AO bad smell as a means to detecting them. The proposed bad-smell metrics are validated and the results show that the proposed bad- smell metrics can preliminarily indicate bad smells hidden in AO software.","","0-7695-2841-4","10.1109/ICIS.2007.68","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4276524","","Software metrics;Software engineering;Programming profession;Software measurement;Laboratories;Object oriented programming;Software quality;Encapsulation;Packaging;Particle measurements","object-oriented programming;software metrics;software quality","bad-smell metrics;aspect-oriented software;aspect-oriented programming;separation of concerns;crosscutting concern decomposition;aspect modules;software patterns;bad design;bad programming;object-oriented programming;software metrics;software artifact measurement;software attributes;software quality assessment","","11","","17","IEEE","23 Jul 2007","","","IEEE","IEEE Conferences"
"Refactoring--Does It Improve Software Quality?","K. Stroggylos; D. Spinellis","Department of Management Science and Technology, Athens University of Economics and Business, Athens, Greece; Department of Management Science and Technology, Athens University of Economics and Business, Athens, Greece","Fifth International Workshop on Software Quality (WoSQ'07: ICSE Workshops 2007)","16 Jul 2007","2007","","","10","10","Software systems undergo modifications, improvements and enhancements to cope with evolving requirements. This maintenance can cause their quality to decrease. Various metrics can be used to evaluate the way the quality is affected. Refactoring is one of the most important and commonly used techniques of transforming a piece of software in order to improve its quality. However, although it would be expected that the increase in quality achieved via refactoring is reflected in the various metrics, measurements on real life systems indicate the opposite. We analyzed source code version control system logs of popular open source software systems to detect changes marked as refactorings and examine how the software metrics are affected by this process, in order to evaluate whether refactoring is effectively used as a means to improve software quality within the open source community.","","0-7695-2959-3","10.1109/WOSQ.2007.11","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4273477","","Software quality;Software systems;Software metrics;Open source software;Maintenance;Environmental economics;Technology management;Control systems;Data mining;Software measurement","software metrics;software quality","software quality;refactoring;source code version control system;open source software systems;software metrics","","80","","40","IEEE","16 Jul 2007","","","IEEE","IEEE Conferences"
"An Integrated Approach to Quality Modelling","S. Wagner; F. Deissenboeck","Institut für Informatik, Technische Universitat Münich, Garching, Germany; Institut für Informatik, Technische Universitat Münich, Garching, Germany","Fifth International Workshop on Software Quality (WoSQ'07: ICSE Workshops 2007)","16 Jul 2007","2007","","","1","1","Software quality is described by various views using different attributes and models. All these types of software quality have their own benefits and applications. However, the isolated solutions do not allow an integrated view on software quality. This renders a comprehensive analysis of software difficult and causes overlaps and inconsistencies in the models. Therefore, this paper proposes an integrated approach to quality modelling. The approach is based on the idea to use an explicit meta-model that provides the means to develop a base quality model. This base model contains the relevant relationships w.r.t. quality. Furthermore, so-called purpose models are derived by quantifying from this basis in order to aid specific tasks in quality management. The approach is illustrated with a proven example of a meta-model and derived quality model for maintainability.","","0-7695-2959-3","10.1109/WOSQ.2007.3","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4273468","","Software quality;Maintenance engineering;Costs;Software engineering;Coordinate measuring machines;Application software;Quality management;Quality assurance;Particle measurements;Software measurement","software quality","quality modelling;software quality;meta-model;quality management","","12","","14","IEEE","16 Jul 2007","","","IEEE","IEEE Conferences"
"Large-Scale Code Reuse in Open Source Software","A. Mockus","Avaya Laboratories Research, Basking Ridge, NJ, USA","First International Workshop on Emerging Trends in FLOSS Research and Development (FLOSS'07: ICSE Workshops 2007)","16 Jul 2007","2007","","","7","7","We are exploring the practice of large-scale reuse involving at least a group of source code files. Our research question is to determine the extent of such reuse occurring in open source projects, to identify the code that is reused the most, and to investigate patterns of large-scale reuse. We start by identifying a sample of projects involving all code in several large repositories of open source projects, all projects bundled with popular distributions of Linux and BSD, and several large individual projects. In the next step we obtain the source code and identify groups of files reused among projects and determine the code that is most widely reused in our sample. Our findings indicate that more than 50% of the files were used in more than one project. The most widely reused components were small and represented templates requiring major and minor modifications and a group of files reused without any change. Some widely reused components involved hundreds of files.","","0-7695-2961-5","10.1109/FLOSS.2007.10","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4273078","","Large-scale systems;Open source software;Business;Licenses;Linux;Cloning;Research and development;Companies;Packaging;Advertising","Linux;public domain software;software reusability","large-scale code reuse;open source software;source code files;Linux","","66","1","9","IEEE","16 Jul 2007","","","IEEE","IEEE Conferences"
"Evaluating Aspect Mining Techniques: A Case Study","C. K. Roy; M. Gias Uddin; B. Roy; T. R. Dean","School of Computing, Queen''s University Belfast, Kingston, ONT, Canada; School of Computing, Queen''s University Belfast, Kingston, ONT, Canada; School of Computing, Queen''s University Belfast, Kingston, ONT, Canada; Department of Electrical and Computer Engineering, Queen''s University Belfast, Kingston, ONT, Canada","15th IEEE International Conference on Program Comprehension (ICPC '07)","9 Jul 2007","2007","","","167","176","Aspect mining aims at identifying cross-cutting concerns in existing systems and therefore advocates the adaption to an aspect-oriented design. This paper presents a case study examining three existing aspect mining techniques from the literature by applying them to four different open source java applications. We compare and evaluate the individual technique and confirm the findings of a previous study of combining different aspect mining techniques in order to get better results with less manual intervention.","1092-8138","0-7695-2860-0","10.1109/ICPC.2007.21","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4268251","","Scattering;Java;Application software;Manuals;Guidelines","data mining;Java;software maintenance","aspect mining techniques evaluation;aspect-oriented design;open source Java applications","","5","","26","IEEE","9 Jul 2007","","","IEEE","IEEE Conferences"
"Evaluating the Harmfulness of Cloning: A Change Based Experiment","A. Lozano; M. Wermelinger; B. Nuseibeh","Computing Department, The Open University, UK; Computing Department, The Open University, UK; Computing Department, The Open University, UK","Fourth International Workshop on Mining Software Repositories (MSR'07:ICSE Workshops 2007)","11 Jun 2007","2007","","","18","18","Cloning is considered a harmful practice for software maintenance because it requires consistent changes of the entities that share a cloned fragment. However this claim has not been refuted or confirmed empirically. Therefore, we have developed a prototype tool, CloneTracker, in order to study the rate of change of applications containing clones. This paper describes CloneTracker and illustrates its preliminary application on a case study.","2160-1860","0-7695-2950-X","10.1109/MSR.2007.8","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4228655","","Cloning;Degradation;Software maintenance;Software prototyping;Prototypes;Application software;Java;Telecommunications;Linux;Kernel","configuration management;program diagnostics;software maintenance;software prototyping","software maintenance;prototype tool;CloneTracker","","43","","11","IEEE","11 Jun 2007","","","IEEE","IEEE Conferences"
"Analysis of the Linux Kernel Evolution Using Code Clone Coverage","S. Livieri; Y. Higo; M. Matsushita; K. Inoue","Graduate School of Information Science and Technology, Osaka University, Toyonaka, Osaka, Japan; Graduate School of Information Science and Technology, Osaka University, Toyonaka, Osaka, Japan; Graduate School of Information Science and Technology, Osaka University, Toyonaka, Osaka, Japan; Graduate School of Information Science and Technology, Osaka University, Toyonaka, Osaka, Japan","Fourth International Workshop on Mining Software Repositories (MSR'07:ICSE Workshops 2007)","11 Jun 2007","2007","","","22","22","Most studies of the evolution of software systems are based on the comparison of simple software metrics. In this paper, we present our preliminary investigation of the evolution of the Linux kernel using code-clone analysis and the code-clone coverage metrics. We examined 136 versions of the stable Linux kernel using a distributed extension of the code clone detection tool CCFinder. The result is shown as a heat map.","2160-1860","0-7695-2950-X","10.1109/MSR.2007.1","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4228659","","Linux;Kernel;Cloning;Software systems;Performance analysis;Information analysis;Information science;Software metrics;Large-scale systems;Vehicles","Linux;operating system kernels;software metrics","Linux kernel evolution;code clone detection tool;software metrics","","17","","9","IEEE","11 Jun 2007","","","IEEE","IEEE Conferences"
"Release Pattern Discovery via Partitioning: Methodology and Case Study","A. Hindle; M. W. Godfrey; R. C. Holt","University of Waterloo, Canada; University of Waterloo, Canada; University of Waterloo, Canada","Fourth International Workshop on Mining Software Repositories (MSR'07:ICSE Workshops 2007)","11 Jun 2007","2007","","","19","19","The development of Open Source systems produces a variety of software artifacts such as source code, version control records, bug reports, and email discussions. Since the development is distributed across different tool environments and developer practices, any analysis of project behavior must be inferred from whatever common artifacts happen to be available. In this paper, we propose an approach to characterizing a project's behavior around the time of major and minor releases; we do this by partitioning the observed activities, such as artifact check-ins, around the dates of major and minor releases, and then look for recognizable patterns. We validate this approach by means of a case study on the MySQL database system; in this case study, we found patterns which suggested MySQL was behaving consistently within itself. These patterns included testing and documenting that took place more before a release than after and that the rate of source code changes dipped around release time.","2160-1860","0-7695-2950-X","10.1109/MSR.2007.28","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4228656","","Capability maturity model;Programming;Testing;Software measurement;Control systems;Time measurement;Software tools;Data analysis;Data mining;Open source software","public domain software;software architecture;SQL","open source system;software artifacts;source code;MySQL database system;artifact check-ins","","16","","12","IEEE","11 Jun 2007","","","IEEE","IEEE Conferences"
"Mining a Change-Based Software Repository","R. Robbes","Faculty of Informatics, University of Lugano, Switzerland","Fourth International Workshop on Mining Software Repositories (MSR'07:ICSE Workshops 2007)","11 Jun 2007","2007","","","15","15","Although state-of-the-art software repositories based on versioning system information are useful to assess the evolution of a software system, the information they contain is limited in several ways. Versioning systems such as CVS or subversion store only snapshots of text files, leading to a loss of information: The exact sequence of changes between two versions is hard to recover. In this paper we present an alternative information repository which stores incremental changes to the system under study, retrieved from the IDE used to build the software. We then use this change-based model of system evolution to assess when refactorings happen in two case studies, and compare our findings with refactoring detection approaches on classical versioning system repositories.","2160-1860","0-7695-2950-X","10.1109/MSR.2007.18","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4228652","","Software systems;Application software;Sampling methods;Informatics;Information retrieval;Degradation;Software design;Concrete;Frequency;Software performance","configuration management;data mining;software maintenance;software prototyping","change-based software repository;data mining;versioning system information;software evolution;information repository;software refactoring","","33","6","18","IEEE","11 Jun 2007","","","IEEE","IEEE Conferences"
"Identifying Changed Source Code Lines from Version Repositories","G. Canfora; L. Cerulo; M. Di Penta","Department of Engineering, University of Sannio, Benevento, Italy; Department of Engineering, University of Sannio, Benevento, Italy; Universita degli Studi del Sannio, Benevento, Campania, IT","Fourth International Workshop on Mining Software Repositories (MSR'07:ICSE Workshops 2007)","11 Jun 2007","2007","","","14","14","Observing the evolution of software systems at different levels of granularity has been a key issue for a number of studies, aiming at predicting defects or at studying certain phenomena, such as the presence of clones or of crosscutting concerns. Versioning systems such as CVS and SVN, however, only provide information about lines added or deleted by a contributor: any change is shown as a sequence of additions and deletions. This provides an erroneous estimate of the amount of code changed. This paper shows how the evolution of changes at source code line level can be inferred from CVS repositories, by combining information retrieval techniques and the Levenshtein edit distance. The application of the proposed approach to the ArgoUML case study indicates a high precision and recall.","2160-1860","0-7695-2950-X","10.1109/MSR.2007.14","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4228651","","Cloning;Information retrieval;Collaborative software;Software systems;Collaborative work;Information analysis;Lab-on-a-chip","configuration management;information retrieval;software prototyping;software reusability","software evolution system;source code lines;crosscutting concern;information retrieval;concurrent versioning system;ArgoUML snapshot","","51","4","21","IEEE","11 Jun 2007","","","IEEE","IEEE Conferences"
"Rapid Prototyping of Intrusion Detection Systems","F. Kordon; J. . -B. Voron; L. Iftode","Laboratoire dInformatique de Paris 6/MoVe, Université Pierre et Marie Curie, Paris, France; Laboratoire dInformatique de Paris 6/MoVe, Université Pierre et Marie Curie, Paris, France; Department of Computer Science, Rutgers University, Piscataway, NJ, USA","18th IEEE/IFIP International Workshop on Rapid System Prototyping (RSP '07)","11 Jun 2007","2007","","","89","98","Designing security softwares that evolve as quickly as threats is a truthful challenge. In addition, current software becomes increasingly more complex and difficult to handle even for security experts. Intrusion Detection Softwares (IDS) represent a solution that can alleviate these concerns. This paper proposes a framework to automatically build an effective online IDS which can check if the program's expected behavior is respected during the execution. The proposed framework extracts relevant information from the program's source code to build a dedicated IDS. We use the GCC compiler to produce the structure of our behavior's model and ensure the IDS is correct. Thanks to Petri nets, our framework allows program offline monitoring and simplifies the online monitoring development.","2150-5519","0-7695-2834-1","10.1109/RSP.2007.34","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4228491","","Prototypes;Intrusion detection;Computerized monitoring;Data mining;Petri nets;Software prototyping;Computer science;Computer security;Information security;Computer languages","Petri nets;program compilers;program verification;safety-critical software;security of data;software prototyping;system monitoring","rapid prototyping;intrusion detection system;GCC compiler;Petri net;program offline monitoring;online monitoring development;security software design","","","","18","IEEE","11 Jun 2007","","","IEEE","IEEE Conferences"
"Rapid Prototyping of Intrusion Detection Systems","F. Kordon; J. -B. Voron; L. Iftode","Laboratoire d'Informatique de Paris 6/MoVe, Université Pierre and Marie Curie, Paris, France; Laboratoire d'Informatique de Paris 6/MoVe, Université Pierre and Marie Curie, Paris, France; Department of Computer Science, Rutgers University, Piscataway, NJ, USA","18th IEEE/IFIP International Workshop on Rapid System Prototyping (RSP '07)","11 Jun 2007","2007","","","106","112","Designing security softwares that evolve as quickly as threats is a truthful challenge. In addition, current software becomes increasingly more complex and difficult to handle even for security experts. Intrusion Detection Softwares (IDS) represent a solution that can alleviate these concerns. This paper proposes a framework to automatically build an effective online IDS which can check if the program's expected behavior is respected during the execution. The proposed framework extracts relevant information from the program's source code to build a dedicated IDS. We use the GCC compiler to produce the structure of our behavior's model and ensure the IDS is correct. Thanks to Petri nets, our framework allows program offline monitoring and simplifies the online monitoring development.","2150-5519","0-7695-2834-1","10.1109/RSP.2007.33","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4228493","","Prototypes;Intrusion detection;Computerized monitoring;Data mining;Petri nets;Software prototyping;Computer science;Computer security;Information security;Computer languages","","","","","","18","IEEE","11 Jun 2007","","","IEEE","IEEE Conferences"
"Understanding and Aiding Code Evolution by Inferring Change Patterns","M. Kim","Computer Science & Engineering, University of Washington, Seattle, WA, USA","29th International Conference on Software Engineering (ICSE'07 Companion)","4 Jun 2007","2007","","","101","102","Evolution continues to play an ever-increasing role in software engineering. Although changing a program is the core of software evolution, program change patterns have not been considered as a first class entity in most classic studies of software evolution. Past empirical studies of software evolution primarily relied on quantitative and statistical analyses of a program over time, but did not focus on semantic and qualitative change patterns of a program. We hypothesize that by treating change patterns as first class entities we can better understand software evolution and also aid programmers in changing software. Our goal is to infer clone evolution patterns from a set of program versions stored in a source code repository. We defined a set of common clone evolution patterns based on our insights from the copy and paste study.","","0-7695-2892-9","10.1109/ICSECOMPANION.2007.81","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4222700","","Cloning;Programming profession;Software engineering;Pattern analysis;Computer science;Software quality;Statistical analysis;Software tools;Computer languages;Control systems","configuration management;software prototyping","software engineering;software evolution;program change pattern;program version;source code repository;clone evolution pattern","","1","","5","IEEE","4 Jun 2007","","","IEEE","IEEE Conferences"
"Automatic Inference of Structural Changes for Matching across Program Versions","M. Kim; D. Notkin; D. Grossman","Computer Science & Engineering, University of Washington, Seattle, WA, USA; Computer Science & Engineering, University of Washington, Seattle, WA, USA; Computer Science & Engineering, University of Washington, Seattle, WA, USA","29th International Conference on Software Engineering (ICSE'07)","4 Jun 2007","2007","","","333","343","Mapping code elements in one version of a program to corresponding code elements in another version is a fundamental building block for many software engineering tools. Existing tools that match code elements or identify structural changes - refactorings and API changes - between two versions of a program have two limitations that we overcome. First, existing tools cannot easily disambiguate among many potential matches or refactoring candidates. Second, it is difficult to use these tools' results for various software engineering tasks due to an unstructured representation of results. To overcome these limitations, our approach represents structural changes as a set of high-level change rules, automatically infers likely change rules and determines method-level matches based on the rules. By applying our tool to several open source projects, we show that our tool identifies matches that are difficult to find using other approaches and produces more concise results than other approaches. Our representation can serve as a better basis for other software engineering tools.","1558-1225","0-7695-2828-7","10.1109/ICSE.2007.20","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4222595","","Software engineering;Packaging;Software tools;Programming profession;Information analysis;Testing;Computer science;Software packages;Rendering (computer graphics);Natural languages","codes;software tools","automatic inference;structural changes;program versions;code elements;software engineering tools;open source projects","","77","1","39","IEEE","4 Jun 2007","","","IEEE","IEEE Conferences"
"Information Needs in Collocated Software Development Teams","A. J. Ko; R. DeLine; G. Venolia","Human-Computer Interaction Institute, Carnegie Mellon University, Pittsburgh, PA, USA; Microsoft Research Limited, Redmond, WA, USA; Microsoft Research Limited, Redmond, WA, USA","29th International Conference on Software Engineering (ICSE'07)","4 Jun 2007","2007","","","344","353","Previous research has documented the fragmented nature of software development work. To explain this in more detail, we analyzed software developers' day-to-day information needs. We observed seventeen developers at a large software company and transcribed their activities in 90-minute sessions. We analyzed these logs for the information that developers sought, the sources that they used, and the situations that prevented information from being acquired. We identified twenty-one information types and cataloged the outcome and source when each type of information was sought. The most frequently sought information included awareness about artifacts and coworkers. The most often deferred searches included knowledge about design and program behavior, such as why code was written a particular way, what a program was supposed to do, and the cause of a program state. Developers often had to defer tasks because the only source of knowledge was unavailable coworkers.","1558-1225","0-7695-2828-7","10.1109/ICSE.2007.45","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4222596","","Programming;Software engineering;Writing;Switches;Information analysis;Communication switching;Content management;Cloning;File servers;Books","software engineering;systems analysis","collocated software development;information needs;program behavior","","257","5","20","IEEE","4 Jun 2007","","","IEEE","IEEE Conferences"
"Tracking Code Clones in Evolving Software","E. Duala-Ekoko; M. P. Robillard","School of Computer Science, McGill University, Montreal, QUE, Canada; School of Computer Science, McGill University, Montreal, QUE, Canada","29th International Conference on Software Engineering (ICSE'07)","4 Jun 2007","2007","","","158","167","Code clones are generally considered harmful in software development, and the predominant approach is to try to eliminate them through refactoring. However, recent research has provided evidence that it may not always be practical, feasible, or cost-effective to eliminate certain clone groups. We propose a technique for tracking clones in evolving software. Our technique relies on the concept of abstract clone region descriptors (CRD), which describe clone regions within methods in a robust way that is independent from the exact text of the clone region or its location in a file. We present our definition of CRDs, and describe a complete clone tracking system capable of producing CRDs from the output of a clone detection tool, notify developers of modifications to clone regions, and support the simultaneous editing of clone regions. We report on two experiments and a case study conducted to assess the performance and usefulness of our approach.","1558-1225","0-7695-2828-7","10.1109/ICSE.2007.90","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4222578","","Cloning;Software systems;Monitoring;Computer science;Robustness;Computer languages;Writing;Logic programming;Q factor;Programming profession","software maintenance;source coding","code clone tracking;software development;clone region descriptor;clone detection tool","","99","2","24","IEEE","4 Jun 2007","","","IEEE","IEEE Conferences"
"DECKARD: Scalable and Accurate Tree-Based Detection of Code Clones","L. Jiang; G. Misherghi; Z. Su; S. Glondu","University of California, Davis, USA; University of California, Davis, USA; University of California, Davis, USA; ENS Cachan, France","29th International Conference on Software Engineering (ICSE'07)","4 Jun 2007","2007","","","96","105","Detecting code clones has many software engineering applications. Existing approaches either do not scale to large code bases or are not robust against minor code modifications. In this paper, we present an efficient algorithm for identifying similar subtrees and apply it to tree representations of source code. Our algorithm is based on a novel characterization of subtrees with numerical vectors in the Euclidean space Rnmiddot and an efficient algorithm to cluster these vectors w.r.t. the Euclidean distance metric. Subtrees with vectors in one cluster are considered similar. We have implemented our tree similarity algorithm as a clone detection tool called DECKARD and evaluated it on large code bases written in C and Java including the Linux kernel and JDK. Our experiments show that DECKARD is both scalable and accurate. It is also language independent, applicable to any language with a formally specified grammar.","1558-1225","0-7695-2828-7","10.1109/ICSE.2007.30","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4222572","","Cloning;Robustness;Clustering algorithms;Software engineering;Fingerprint recognition;Programming profession;Application software;Euclidean distance;Java;Linux","software engineering;trees (mathematics)","Deckard;tree-based detection;code clones;software engineering;tree representations;source code;Euclidean distance metric;subtrees","","495","9","24","IEEE","4 Jun 2007","","","IEEE","IEEE Conferences"
"Using Server Pages to Unify Clones in Web Applications: A Trade-Off Analysis","D. C. Rajapakse; S. Jarzabek","Department of Computer Science, National University of Singapore, Singapore; Department of Computer Science, National University of Singapore, Singapore","29th International Conference on Software Engineering (ICSE'07)","4 Jun 2007","2007","","","116","126","Server page technique is commonly used for implementing Web application user interfaces. Server pages can represent many similar Web pages in a generic form. Yet our previous study revealed high rates of repetitions in Web applications, particularly in the user interfaces. Code duplication, commonly known as 'cloning', signals untapped opportunities to achieve simpler, smaller, more generic, and more maintainable Web applications. Using PHP server page technique, we conducted a case study to explore how far server page technique can be pushed to achieve clone-free Web applications. Our study suggests that clone unification using server pages affects system qualities (e.g., runtime performance) to an extent that may not be acceptable in many project situations. Our paper discusses the trade-offs we observed when applying server pages to unify clones in Web applications. We expect our findings to help in developing and validating complementary techniques that can unify clones without incurring such trade-offs.","1558-1225","0-7695-2828-7","10.1109/ICSE.2007.95","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4222574","","Cloning;Application software;User interfaces;Web pages;Computer science;Computer interfaces;Error correction;Productivity;Application specific processors;HTML","Internet;user interfaces","Web application user interfaces;trade-off analysis;code duplication;PHP server page technique;clone unification","","29","","21","IEEE","4 Jun 2007","","","IEEE","IEEE Conferences"
"Very-Large Scale Code Clone Analysis and Visualization of Open Source Programs Using Distributed CCFinder: D-CCFinder","S. Livieri; Y. Higo; M. Matushita; K. Inoue","Graduate School of Information Science and Technology, Osaka University, Toyonaka, Osaka, Japan; Graduate School of Information Science and Technology, Osaka University, Toyonaka, Osaka, Japan; Graduate School of Information Science and Technology, Osaka University, Toyonaka, Osaka, Japan; Graduate School of Information Science and Technology, Osaka University, Toyonaka, Osaka, Japan","29th International Conference on Software Engineering (ICSE'07)","4 Jun 2007","2007","","","106","115","The increasing performance-price ratio of computer hardware makes possible to explore a distributed approach at code clone analysis. This paper presents D-CCFinder, a distributed approach at large-scale code clone analysis. D-CCFinder has been implemented with 80 PC workstations in our student laboratory, and a vast collection of open source software with about 400 million lines in total has been analyzed with it in about 2 days. The result has been visualized as a scatter plot, which showed the presence of frequently used code as easy recognizable patterns. Also, D-CCFinder has been used to analyze a single software system against the whole collection in order to explore the presence of code imported from open source software.","1558-1225","0-7695-2828-7","10.1109/ICSE.2007.97","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4222573","","Cloning;Visualization;Open source software;Distributed computing;Hardware;Performance analysis;Large-scale systems;Workstations;Laboratories;Scattering","public domain software;systems analysis","very-large scale code clone analysis;very-large scale code clone visualization;open source programs;distributed CCFinder;code clone analysis;open source software;recognizable patterns","","82","1","22","IEEE","4 Jun 2007","","","IEEE","IEEE Conferences"
"An Empirical Study of the Evolution of an Agile-Developed Software System","A. Capiluppi; J. Fernandez-Ramil; J. Higman; H. C. Sharp; N. Smith","University of Lincoln, UK; Open University, UK; University of Lincoln, UK; University of Lincoln, UK; Independent Agile Coach, London, UK","29th International Conference on Software Engineering (ICSE'07)","4 Jun 2007","2007","","","511","518","We have analyzed evolution patterns over two and a half years for a system developed using extreme programming. We find that the system shows a smooth pattern of growth overall, that (McCabe) code complexity is low, and that the relative amount of complexity control work (e.g. refactoring) is higher than in other systems we have studied. To interpret these results, we have drawn on qualitative data including the results of an observational study, records of progress and productivity, and comments on our findings from team members.","1558-1225","0-7695-2828-7","10.1109/ICSE.2007.14","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4222612","","Software systems;Genetic programming;Productivity;Software measurement;Pattern analysis;Control systems;Collaborative work;Large-scale systems;Documentation;Personnel","software engineering","agile-developed software system;extreme programming;code complexity;qualitative data","","20","","27","IEEE","4 Jun 2007","","","IEEE","IEEE Conferences"
"New Frontiers of Reverse Engineering","G. Canfora; M. Di Penta","RCOST - University of Sannio, Benevento, Italy; RCOST - University of Sannio, Benevento, Italy","Future of Software Engineering (FOSE '07)","4 Jun 2007","2007","","","326","341","Comprehending and modifying software is at the heart of many software engineering tasks, and this explains the growing interest that software reverse engineering has gained in the last 20 years. Broadly speaking, reverse engineering is the process of analyzing a subject system to create representations of the system at a higher level of abstraction. This paper briefly presents an overview of the field of reverse engineering, reviews main achievements and areas of application, and highlights key open research issues for the future.","","0-7695-2829-5","10.1109/FOSE.2007.15","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4221630","","Reverse engineering;Software maintenance;Software engineering;Conferences;Software testing;Computer science;Helium;Organizing;Computer Society;Heart","reverse engineering;software engineering","Gerardo Canfora;Massimiliano Di Penta;software engineering;software reverse engineering","","64","2","117","IEEE","4 Jun 2007","","","IEEE","IEEE Conferences"
"The Future of Programming Environments: Integration, Synergy, and Assistance","A. Zeller","University of Saarland, Saarbruecken, Germany","Future of Software Engineering (FOSE '07)","4 Jun 2007","2007","","","316","325","Modern programming environments foster the integration of automated, extensible, and reusable tools. New tools can thus leverage the available functionality and collect data from program and process. The synergy of both will allow the automation of current empirical approaches. This leads to automated assistance in all development decisions for programmers and managers alike: ""For this task, you should collaborate with Joe, because it will likely require risky work on the mailbox class"".","","0-7695-2829-5","10.1109/FOSE.2007.31","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4221629","","Programming environments;Programming profession;Computer science;History;Manufacturing;Production;Collaborative software;Quality management;Project management;Books","programming environments;software reusability;software tools","programming environments;reusable tools;empirical approaches automation","","20","","34","IEEE","4 Jun 2007","","","IEEE","IEEE Conferences"
"Source Code Analysis: A Road Map","D. Binkley","Loyola College, Baltimore, MD, USA","Future of Software Engineering (FOSE '07)","4 Jun 2007","2007","","","104","119","The automated and semi-automated analysis of source code has remained a topic of intense research for more than thirty years. During this period, algorithms and techniques for source-code analysis have changed, sometimes dramatically. The abilities of the tools that implement them have also expanded to meet new and diverse challenges. This paper surveys current work on source-code analysis. It also provides a road map for future work over the next five-year period and speculates on the development of source-code analysis applications, techniques, and challenges over the next 10, 20, and 50 years.","","0-7695-2829-5","10.1109/FOSE.2007.27","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4221615","","Programming profession;Educational institutions;Computer science;NIST;Software engineering;Data mining;Humans;Productivity;Assembly;Software safety","program compilers;program diagnostics;software tools","source code analysis;road map;software tool","","98","3","119","IEEE","4 Jun 2007","","","IEEE","IEEE Conferences"
"Parameterized Looped Schedules for Compact Representation of Execution Sequences in DSP Hardware and Software Implementation","M. -Y. Ko; C. Zissulescu; S. Puthenpurayil; S. S. Bhattacharyya; B. Kienhuis; E. F. Deprettere","Department of Electrical and Computer Engineering, University of Maryland, College Park, MD, USA; Leiden Institute of Advanced Computer Science, Leiden University, Leiden, Netherlands; Department of Electrical and Computer Engineering, University of Maryland, College Park, MD, USA; Department of Electrical and Computer Engineering, Institute for Advanced Computer Studies, University of Maryland, College Park, MD, USA; Leiden Institute of Advanced Computer Science, Leiden University, Leiden, Netherlands; Leiden Institute of Advanced Computer Science, Leiden University, Leiden, Netherlands","IEEE Transactions on Signal Processing","21 May 2007","2007","55","6","3126","3138","In this paper, we present a technique for compact representation of execution sequences in terms of efficient looping constructs. Here, by a looping construct, we mean a compact way of specifying a finite repetition of a set of execution primitives. Such compaction, which can be viewed as a form of hierarchical run-length encoding (RLE), has application in many very large scale integration (VLSI) signal processing contexts, including efficient control generation for Kahn processes on field-programmable gate arrays (FPGAs), and software synthesis for static dataflow models of computation. In this paper, we significantly generalize previous models for loop-based code compaction of digital signal processing (DSP) programs to yield a configurable code compression methodology that exhibits a broad range of achievable tradeoffs. Specifically, we formally develop and apply to DSP hardware and software synthesis a parameterizable loop scheduling approach with compact format, dynamic reconfigurability, and low-overhead decompression","1941-0476","","10.1109/TSP.2007.893964","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4203085","Design automation;embedded systems;field-programmable gate arrays (FPGAs);high-level synthesis;program compilers;reconfigurable design;signal processing","Digital signal processing;Hardware;Compaction;Very large scale integration;Field programmable gate arrays;Signal synthesis;Encoding;Application software;Array signal processing;Signal generators","data compression;digital signal processing chips;field programmable gate arrays;runlength codes;scheduling;software engineering;VLSI","parameterized loop schedules;compact representation;DSP hardware;software implementation;looping construct;hierarchical runlength encoding;very large scale integration;VLSI;digital signal processing;Kahn process;field programmable gate arrays;FPGA;static dataflow models;loop-based code compaction;DSP;code compression methodology","","27","","27","IEEE","21 May 2007","","","IEEE","IEEE Journals"
"Feature Location Using Probabilistic Ranking of Methods Based on Execution Scenarios and Information Retrieval","D. Poshyvanyk; Y. -G. Gueheneuc; A. Marcus; G. Antoniol; V. Rajlich","Department of Computer Science, Wayne State University, Detroit, MI, USA; Département dinformatique et recherche opérationnelle, Université de Montreal, Montreal, QUE, Canada; Department of Computer Science, Wayne State University, Detroit, MI, USA; Département dinformatique, École Polytechnique de Montréal, Montreal, QUE, Canada; Department of Computer Science, Wayne State University, Detroit, MI, USA","IEEE Transactions on Software Engineering","7 May 2007","2007","33","6","420","432","This paper recasts the problem of feature location in source code as a decision-making problem in the presence of uncertainty. The solution to the problem is formulated as a combination of the opinions of different experts. The experts in this work are two existing techniques for feature location: a scenario-based probabilistic ranking of events and an information-retrieval-based technique that uses latent semantic indexing. The combination of these two experts is empirically evaluated through several case studies, which use the source code of the Mozilla Web browser and the Eclipse integrated development environment. The results show that the combination of experts significantly improves the effectiveness of feature location as compared to each of the experts used independently","1939-3520","","10.1109/TSE.2007.1016","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4181710","Program understanding;feature identification;concept location;dynamic and static analyses;information retrieval;Latent Semantic Indexing;scenario-based probabilistic ranking;open source software.","Information retrieval;Performance analysis;Indexing;Programming profession;Computer Society;Decision making;Uncertainty;Information analysis;Open source software;Computer bugs","decision making;information retrieval;probability;program diagnostics","feature location;information retrieval;decision-making problem;scenario-based probabilistic event ranking;latent semantic indexing;Mozilla Web browser;Eclipse integrated development","","314","4","49","IEEE","7 May 2007","","","IEEE","IEEE Journals"
"Aspect Mining Using Method Call Tree","L. Qu; D. Liu","Computer Science and Technology Institute, Harbin Engineering of Technology, Harbin, China; Computer Science and Technology Institute, Harbin Engineering of Technology, Harbin, China","2007 International Conference on Multimedia and Ubiquitous Engineering (MUE'07)","7 May 2007","2007","","","407","412","Aspect mining tries to identify crosscutting concerns in legacy systems and thus supports the adaptation to an aspect-oriented design. This paper describes an automatic static aspect mining approach that relies on the method call tree. It uses method call tree to generate method call traces. These traces are then investigated for recurring method patterns based on different constraints, such as the requirement that the patterns exist in always the same composition and in different calling contexts in the method call trace. A experimental evaluation shows that the approach improves the recall of the aspect candidates and the efficiency of the aspect mining.","","0-7695-2777-9","10.1109/MUE.2007.91","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4197307","","Software systems;Computer languages;Computer science;Design engineering;Scattering;Programming;Pattern analysis;Runtime;Application software;Java","data mining;object-oriented programming;software maintenance","method call tree;crosscutting concerns;legacy systems;automatic static aspect mining;recurring method patterns","","1","","12","IEEE","7 May 2007","","","IEEE","IEEE Conferences"
"Improving Usability of Software Refactoring Tools","E. Mealy; D. Carrington; P. Strooper; P. Wyeth","School of Information Technology and Electrical Engineering, University of Queensland, QLD, Australia; School of Information Technology and Electrical Engineering, University of Queensland, QLD, Australia; School of Information Technology and Electrical Engineering, University of Queensland, QLD, Australia; School of Information Technology and Electrical Engineering, University of Queensland, QLD, Australia","2007 Australian Software Engineering Conference (ASWEC'07)","23 Apr 2007","2007","","","307","318","Post-deployment maintenance and evolution can account for up to 75% of the cost of developing a software system. Software refactoring can reduce the costs associated with evolution by improving system quality. Although refactoring can yield benefits, the process includes potentially complex, error-prone, tedious and time-consuming tasks. It is these tasks that automated refactoring tools seek to address. However, although the refactoring process is well-defined, current refactoring tools do not support the full process. To develop better automated refactoring support, we have completed a usability study of software refactoring tools. In the study, we analysed the task of software refactoring using the ISO 9241-11 usability standard and Fitts' List of task allocation. Expanding on this analysis, we reviewed 11 collections of usability guidelines and combined these into a single list of 38 guidelines. From this list, we developed 81 usability requirements for refactoring tools. Using these requirements, the software refactoring tools Eclipse 3.2, Condenser 1.05, RefactorIT 2.5.1, and Eclipse 3.2 with the Simian UI 2.2.12 plugin were studied. Based on the analysis, we have selected a subset of the requirements that can be incorporated into a prototype refactoring tool intended to address the full refactoring process.","1530-0803","0-7695-2778-7","10.1109/ASWEC.2007.24","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4159683","","Usability;Software tools;Costs;Software systems;ISO standards;Guidelines;Software quality;Software standards;Software prototyping;Prototypes","software maintenance;software prototyping;software tools","software refactoring tool;ISO 9241-11 usability standard;task allocation","","22","1","34","IEEE","23 Apr 2007","","","IEEE","IEEE Conferences"
"Agile Development Methodology for Embedded Systems: A Platform-Based Design Approach","L. Cordeiro; R. Barreto; R. Barcelos; M. Oliveira; V. Lucena; P. Maciel","Departamento de Ciência da Computação, Universidade Federal do Amazonas, Brazil; Departamento de Ciência da Computação, Universidade Federal do Amazonas, Brazil; Research and Development Center, BenQ Mobile, Brazil; Centro de Informática, Universidade Federal de Pernambuco, Brazil; Departamento de Ciência da Computação, Universidade Federal do Amazonas, Brazil; Centro de Informática, Universidade Federal de Pernambuco, Brazil","14th Annual IEEE International Conference and Workshops on the Engineering of Computer-Based Systems (ECBS'07)","10 Apr 2007","2007","","","195","202","This paper describes an agile development methodology which combines agile principles with organizational patterns and adapts them to build embedded real-time systems focusing on the system's constraints. The hardware/software partitioning and platform-based design are used in the proposed methodology to support the embedded system designer meet the system's constraints in an iterative and incremental way and to reduce substantially the design time and cost of the product. To discuss the strengths and weakness of this methodology, a case study involving a pulse oximeter is also presented","","0-7695-2772-8","10.1109/ECBS.2007.16","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4148934","","Embedded system;Hardware;Embedded software;Software engineering;Real time systems;Costs;Application software;Embedded computing;Iterative methods;Systems engineering and theory","embedded systems;software engineering","agile development;platform-based design approach;embedded real-time systems;hardware-software partitioning","","12","","13","IEEE","10 Apr 2007","","","IEEE","IEEE Conferences"
"Graph-Based Procedural Abstraction","A. Dreweke; M. Worlein; I. Fischer; D. Schell; T. Meinl; M. Philippsen","Computer Science Department, University of Erlangen Nuremberg, Erlangen, Germany; Computer Science Department, University of Erlangen Nuremberg, Erlangen, Germany; Computer Science Department, University of Erlangen Nuremberg, Erlangen, Germany; Computer Science Department, University of Erlangen Nuremberg, Erlangen, Germany; Computer Science Department, University of Erlangen Nuremberg, Erlangen, Germany; Computer Science Department, University of Erlangen Nuremberg, Erlangen, Germany","International Symposium on Code Generation and Optimization (CGO'07)","2 Apr 2007","2007","","","259","270","Procedural abstraction (PA) extracts duplicate code segments into a newly created method and hence reduces code size. For embedded micro computers the amount of memory is still limited so code reduction is an important issue. This paper presents a novel approach to PA, that is especially targeted towards embedded systems. Earlier approaches of PA are blind with respect to code reordering, i.e., two code segments with the same semantic effect but with different instruction orders were not detected as candidates for PA. Instead of instruction sequences, in our approach the data flow graphs of basic blocks are considered. Compared to known PA techniques more than twice the number of instructions can be saved on a set of binaries, by detecting frequently appearing graph fragments with a graph mining tool based on the well known gSpan algorithm. The detection and extraction of graph fragments is not as straight forward as extracting sequential code fragments. NP-complete graph operations and special rules to decide which parts can be abstracted are needed. However, this effort pays off as smaller sizes significantly reduce costs on mass-produced embedded systems","","0-7695-2764-7","10.1109/CGO.2007.14","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4145120","","Embedded system;Flow graphs;Computer science;Cost function;Microcomputers;Data mining;Embedded computing;Energy consumption;Mass production;Cellular phones","embedded systems;graph theory;microcomputers;optimisation;optimising compilers","graph-based procedural abstraction;embedded micro computers;gSpan algorithm;mass-produced embedded systems","","14","1","48","IEEE","2 Apr 2007","","","IEEE","IEEE Conferences"
"Code Compaction of an Operating System Kernel","H. He; J. Trimble; S. Perianayagam; S. Debray; G. Andrews","Department of Computer Science, University of Arizona Tucson, Tucson, AZ, USA; Department of Computer Science, University of Arizona Tucson, Tucson, AZ, USA; Department of Computer Science, University of Arizona Tucson, Tucson, AZ, USA; Department of Computer Science, University of Arizona Tucson, Tucson, AZ, USA; Department of Computer Science, University of Arizona Tucson, Tucson, AZ, USA","International Symposium on Code Generation and Optimization (CGO'07)","2 Apr 2007","2007","","","283","298","General-purpose operating systems, such as Linux, are increasingly being used in embedded systems. Computational resources are usually limited, and embedded processors often have a limited amount of memory. This makes code size especially important. This paper describes techniques for automatically reducing the memory footprint of general-purpose operating systems on embedded platforms. The problem is complicated by the fact that kernel code tends to be quite different from ordinary application code, including the presence of a significant amount of hand-written assembly code, multiple entry points, implicit control flow paths involving interrupt handlers, and frequent indirect control flow via function pointers. We use a novel ""approximate decompilation"" technique to apply source-level program analysis to hand-written assembly code. A prototype implementation of our ideas on an Intel x86 platform, applied to a Linux kernel that has been configured to exclude unnecessary code, obtains a code size reduction of close to 24%","","0-7695-2764-7","10.1109/CGO.2007.3","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4145122","","Compaction;Operating systems;Kernel;Embedded system;Linux;Assembly;Cellular phones;Runtime;Prototypes;Hardware","embedded systems;Linux;operating system kernels;program diagnostics","code compaction;operating system kernel;embedded systems;embedded processors;approximate decompilation;source-level program analysis;hand-written assembly code;Intel x86 platform;Linux kernel","","7","","24","IEEE","2 Apr 2007","","","IEEE","IEEE Conferences"
"How Clones are Maintained: An Empirical Study","L. Aversano; L. Cerulo; M. Di Penta","RCOST-Research Centre on Software Technology, Department of Engineering, University of Sannio, Benevento, Italy; RCOST-Research Centre on Software Technology, Department of Engineering, University of Sannio, Benevento, Italy; RCOST-Research Centre on Software Technology, Department of Engineering, University of Sannio, Benevento, Italy","11th European Conference on Software Maintenance and Reengineering (CSMR'07)","2 Apr 2007","2007","","","81","90","Despite the conventional wisdom concerning the risks related to the use of source code cloning as a software development strategy, several studies appeared in literature indicated that this is not true. In most cases clones are properly maintained and, when this does not happen, is because cloned code evolves independently. Stemming from previous works, this paper combines clone detection and co-change analysis to investigate how clones are maintained when an evolution activity or a bug fixing impact a source code fragment belonging to a clone class. The two case studies reported confirm that, either for bug fixing or for evolution purposes, most of the cloned code is consistently maintained during the same co-change or during temporally close co-changes","1534-5351","0-7695-2802-3","10.1109/CSMR.2007.26","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4145027","","Cloning;Software systems;Software maintenance;Performance analysis;Maintenance engineering;Programming;Testing;Java;Linux;Kernel","software maintenance;source coding","source code cloning;software development;software maintenance;clone detection;cochange analysis;source code fragment;software evolution","","112","","21","IEEE","2 Apr 2007","","","IEEE","IEEE Conferences"
"High-impact Refactoring Based on Architecture Violations","F. Bourquin; R. K. Keller","Züihike Engineering A G, Zurich-Schlieren, Switzerland; Züihike Engineering A G, Zurich-Schlieren, Switzerland","11th European Conference on Software Maintenance and Reengineering (CSMR'07)","2 Apr 2007","2007","","","149","158","Software refactoring has been identified as a key technique for the maintenance and evolution of object-oriented systems. Most interesting are high-impact refactorings, that is, refactorings that have a strong impact on the quality of the system's architecture. ""Bad smells "" and code metrics have been suggested as means for identifying refactoring needs. According to our experience these techniques are useful yet, in order to spot opportunities for high-impact refactorings, they should be complemented with the analysis of architectural violations. The subject of this report is a mid-sized Java enterprise application from the telecommunications domain whose functionality had to be radically extended We show how we combined several tools and techniques to identify' opportunities for high-impact refactorings, and discuss the resulting architecture, the refactoring process, tool support as well as related experiences","1534-5351","0-7695-2802-3","10.1109/CSMR.2007.25","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4145033","","Computer architecture;Application software;Software maintenance;Java;Electrical equipment industry;Software quality;Programming;Software testing;Software architecture;Computer Society","Java;object-oriented programming;software architecture;software maintenance;software metrics;software quality","software refactoring;software architecture violations;software maintenance;software evolution;object-oriented systems;software quality;code metrics;Java enterprise","","26","","16","IEEE","2 Apr 2007","","","IEEE","IEEE Conferences"
"Requirements and Open Issues in Distributed Detection of Node Identity Replicas in WSN","M. Conti; R. Di Pietro; L. V. Mancini; A. Mei","Dipartimento di Informatica, Universitá di Roma, La Sapienza, Italy; Dipartimento di Matematica, Universitá di Roma Tre, Italy; Dipartimento di Informatica, Universitá di Roma, La Sapienza, Italy; Dipartimento di Informatica, Universitá di Roma, La Sapienza, Italy","2006 IEEE International Conference on Systems, Man and Cybernetics","16 Jul 2007","2006","2","","1468","1473","Wireless sensor networks (WSN) are often deployed in hostile environments, where an attacker can also capture some nodes. Once a node is captured, the attacker can re-program it and start replicating the node. These replicas can then be deployed in all (or a part of) the network area. The replicas can thus perform the attack they are programmed for: DoS (Denial of Service), or influencing any voting mechanism are just examples. Detection of node replication attack is therefore a fundamental property of all the WSN applications in which an attacker presence is possible. The contribution of this paper is twofold: First, we analyze the desirable properties of a distributed mechanism for the detection of replicated IDs; second, we show that the first proposal recently appeared in literature to realize a distributed solution for the detection of replicas does not completely fulfil the requirements. Hence, the design of efficient and distributed protocols to detect node identity replicas is still an open and demanding issue.","1062-922X","1-4244-0099-6","10.1109/ICSMC.2006.384924","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4274058","","Wireless sensor networks;Protocols;Cloning;Voting;Mechanical factors;Base stations;Cybernetics;Computer crime;Intrusion detection;Proposals","protocols;telecommunication security;wireless sensor networks","distributed detection;node identity replicas;wireless sensor networks;denial of service;voting mechanism","","12","","16","IEEE","16 Jul 2007","","","IEEE","IEEE Conferences"
"Validation of Geant4 Bremsstrahlung models: first results","S. Chauvie; S. Guatelli; B. Mascialino; L. Pandola; M. G. Pia; P. Rodrigues; A. Trindade","INFN Sezione di Torino, Cuneo, Italy; I.N.F.N. Sezione di Genova, Genoa, Italy; I.N.F.N. Sezione di Genova, Genoa, Italy; NA; I.N.F.N. Sezione di Genova, Genoa, Italy; Fisica Experimentalde Particulas, Laboratoriode Instrumentacaoe, Lisboa, Portugal; Fisica Experimentalde Particulas, Laboratoriode Instrumentacaoe, Lisboa, Portugal","2006 IEEE Nuclear Science Symposium Conference Record","7 May 2007","2006","3","","1511","1515","A project is in progress for a systematic, rigorous validation of Geant4 electromagnetic physics. This paper presents the first results concerning the validation of Geant4 bremsstrahlung models against experimental data.","1082-3654","1-4244-0560-2","10.1109/NSSMIC.2006.354185","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4179298","Geant4;Monte Carlo;simulation;Bremsstrahlung;validation","Object oriented modeling;Electromagnetic modeling;Electrons;Packaging;Physics;Monte Carlo methods;Libraries;Atomic measurements;Solid modeling;Power system reliability","bremsstrahlung;electron radiation;Monte Carlo methods","Geant4 bremsstrahlung models;Geant4 electromagnetic physics","","3","","15","IEEE","7 May 2007","","","IEEE","IEEE Conferences"
"Visualizing Clone Cohesion and Coupling","Z. M. Jiang; A. E. Hassan; R. C. Holt","University of Waterloo, Canada; University of Victoria B.C, Canada; University of Waterloo, Canada","2006 13th Asia Pacific Software Engineering Conference (APSEC'06)","26 Mar 2007","2006","","","467","476","Coupling and cohesion between subsystems are commonly studied metrics when analyzing the architecture of software systems. It is usually desirable for subsystems to have high cohesion within the subsystem and to have low coupling to other subsystems. High cohesion implies cohesive concerns and low coupling implies localized changes. We extend the ideas of coupling and cohesion to code cloning. A code clone is a segment of code that has been created through duplication of another piece of code. Previous research has shown that in some instances code cloning is desirable, whereas in other cases it is not. We believe that it is justifiable to have code cloning within subsystems (high cohesion), whereas it is not justifiable and likely not desirable to have it across subsystems (high coupling). We present an approach, which consists of a framework that generates and filters cloning data and a visualization technique which graphically highlights clone cohesion and coupling between architectural subsystems. Our approach can be used by developers to locate undesirable cloning in their software system. We demonstrate our approach through a case study on the SCSI drivers in the Linux kernel.","1530-1362","0-7695-2685-3","10.1109/APSEC.2006.63","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4137451","","Cloning;Software systems;Computer architecture;Filters;Data visualization;Linux;Kernel;Software maintenance;Monitoring;Computer bugs","data visualisation;software architecture;software maintenance;software metrics","visualizing clone cohesion;coupling;code clone;visualization technique;software system;SCSI drivers;Linux kernel","","11","","21","IEEE","26 Mar 2007","","","IEEE","IEEE Conferences"
"Genericity - a ""Missing in Action"" Key to Software Simplification and Reuse","S. Jarzabek","Department of Computer Science, School of Computing, National University of Singapore, Singapore","2006 13th Asia Pacific Software Engineering Conference (APSEC'06)","26 Mar 2007","2006","","","293","300","In controlled lab experiments and industrial projects, we observed 50%-90% rates of repetitions that deliberately recurred in newly developed, well- designed programs. Most often, recurring program structures represented an important concept from software requirements or design spaces. Repetitions increased conceptual complexity and physical size of programs, and also signified unexploited reuse opportunities. Despite potential benefits, avoiding or explicating repetitions with conventional programming techniques was either impossible or would require developers to compromise other important design goals. We believe these problems are common in many program situations. We hypothesize that they have their roots in much similarity that is inherent in software, and not strong enough generic design mechanisms to represent repetitions in a unified, generic way. We discuss mixed-strategy approach that strengthens generic design capabilities of conventional programming techniques with help of a generative meta-programming technique.","1530-1362","0-7695-2685-3","10.1109/APSEC.2006.37","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4137430","","Computer languages;Industrial control;Software design;Productivity;Application software;Computer science;Computer industry;Java;Buildings;Cloning","software reliability;software reusability","genericity;software simplification;software reuse;software requirements;generative meta-programming technique","","4","","29","IEEE","26 Mar 2007","","","IEEE","IEEE Conferences"
"Detecting Duplications in Sequence Diagrams Based on Suffix Trees","H. Liu; Z. Ma; L. Zhang; W. Shao","Software Institute, School of Electronics Engineering and Computer Science, Peking University, Beijing, China; Software Institute, School of Electronics Engineering and Computer Science, Peking University, Beijing, China; Software Institute, School of Electronics Engineering and Computer Science, Peking University, Beijing, China; Software Institute, School of Electronics Engineering and Computer Science, Peking University, Beijing, China","2006 13th Asia Pacific Software Engineering Conference (APSEC'06)","26 Mar 2007","2006","","","269","276","With the popularity of UML and MDA, models are replacing source code as core artifacts of software development and maintenance. But duplications in models reduce models' maintainability and reusability. To address the problem, we should detect duplications first. As an initial step to address the problem, we propose an approach to detect duplications in sequence diagrams. With special preprocessing, we convert 2-dimensional sequence diagrams into a 1-dimensional array. Then we construct a suffix tree of the array. We revise the traditional construction algorithm of suffix trees by proposing a special algorithm to detect common prefixes of suffixes. The algorithm ensures that every duplication detected with the suffix tree can be extracted into a separate reusable sequence diagram. With the suffix tree, duplications are found as refactoring candidates. With tool support, the proposed approach has been applied to real industrial projects, and the evaluation results suggest that the approach is effective.","1530-1362","0-7695-2685-3","10.1109/APSEC.2006.32","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4137427","","Unified modeling language;Software maintenance;Programming;Maintenance engineering;Computer science;Computer industry;Computer architecture;Context modeling;Collaboration;Asia","software architecture;software maintenance;Unified Modeling Language","duplications;sequence diagrams;suffix trees;UML;MDA;source code;software development;software maintenance","","21","","16","IEEE","26 Mar 2007","","","IEEE","IEEE Conferences"
"Aspect-Oriented Modeling for Power System Stability Assessment","J. Ma; Z. Y. Dong","School of Information Technology and Electrical Engineering, University of Queensland, Brisbane, QLD, Australia; School of Information Technology and Electrical Engineering, University of Queensland, Brisbane, QLD, Australia","2006 International Conference on Power System Technology","26 Feb 2007","2006","","","1","6","Object-oriented techniques have been applied to power system software development for quite long time. However, object-oriented modeling has several disadvantages for power system stability assessment software. Aspect-oriented modeling (AOM) has become an extension of object-oriented modeling by capitalizing on its advantages while improving the disadvantages. This paper addresses the disadvantages encountered by object-oriented modeling in power system stability assessment software, and proposes using aspect-oriented modeling for power system stability assessment software development so as to solve the problems encountered by object- oriented techniques. A framework based on the aspect-oriented technique for stability assessment software is presented.","","1-4244-0110-0","10.1109/ICPST.2006.321963","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4116254","Aspect-oriented modeling;object-oriented modeling;power system;stability assessment","Power system modeling;Power system stability;Object oriented modeling;Power system analysis computing;Software systems;Application software;Programming;Power system simulation;Real time systems;Power system management","object-oriented programming;power system analysis computing;power system simulation;power system stability","aspect-oriented modeling;power system stability assessment","","1","","19","IEEE","26 Feb 2007","","","IEEE","IEEE Conferences"
"Loop Nest Splitting for WCET-Optimization and Predictability Improvement","H. Falk; M. Schwarzer","Computer Science, University of Dortmund, Dortmund, Germany; Computer Science, University of Dortmund, Dortmund, Germany","2006 IEEE/ACM/IFIP Workshop on Embedded Systems for Real Time Multimedia","26 Feb 2007","2006","","","115","120","This paper presents the effect of the loop nest splitting source code optimization on worst-case execution time (WCET). Loop nest splitting minimizes the number of executed if-statements in loop nests of multimedia applications. It identifies iterations where all if-statements are satisfied and splits the loop nest such that if-statements are not executed at all for large parts of the loop nest's iteration space. Especially loops and if-statements are an inherent source of unpredictability and loss of precision for WCET analysis. This is caused by the difficulty to obtain safe and tight worst-case estimates of an application's high-level control flow. In addition, assembly-level control flow redirections reduce predictability even more due to complex processor pipelines and branch prediction units. Loop nest splitting bases on precise mathematical models combined with genetic algorithms. On the one hand, these techniques achieve a significantly more homogeneous control flow structure. On the other hand, the precision of our analyses enables to generate very accurate high-level flow facts for loops and if-statements. The application of our implemented algorithms to three real-life benchmarks leads to average speed-ups by 25.0%-30.1%, while WCET is reduced by 34.0%-36.3%","2325-1301","0-7803-9783-5","10.1109/ESTMED.2006.321283","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4115463","","Pipelines;Real time systems;MPEG 4 Standard;Computer science;Application software;Assembly;Mathematical model;Genetic algorithms;Motion estimation;Hazards","genetic algorithms;mathematical analysis;multimedia systems;program control structures;source coding","loop nest splitting;predictability improvement;source code optimization;worst-case execution time;WCET analysis;multimedia application;precise mathematical model;genetic algorithm;homogeneous control flow structure","","5","","13","IEEE","26 Feb 2007","","","IEEE","IEEE Conferences"
"Evolving Warriors for the Nano Core","E. Sanchez; M. Schillaci; G. Squillero","Politecnico di Turino, Italy; Politecnico di Turino, Italy; Politecnico di Turino, Italy","2006 IEEE Symposium on Computational Intelligence and Games","20 Feb 2007","2006","","","272","278","The paper describes the attempt to cultivate programs to climb the nano hill, a contest with exceptionally tight parameters of the game called corewar. An existing tool, called muGP, has been exploited. Two genetic operators were added to tackle the peculiarities of the objective. The generated programs compared favorably with others, either manually written or evolved. muGP autonomously reproduced the same structure of the current champion of the competition, and devised a sharp self-modifying program exploiting a completely new strategy","2325-4289","1-4244-0464-9","10.1109/CIG.2006.311712","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4100139","","Yarn;White noise;Mars;Internet;Genetics;H infinity control;Assembly;Virtual machining;Evolutionary computation;Microprocessors","computer games;genetic algorithms","nanocore;nanohill;corewar game;genetic operator;self-modifying program","","","","9","IEEE","20 Feb 2007","","","IEEE","IEEE Conferences"
"A New k-means Based Clustering Algorithm in Aspect Mining","G. Serban; G. S. Moldovan","Department of Computer Science, Babe&-Bolyai University, Cluj-Napoca, Romania; Department of Computer Science, Babe&-Bolyai University, Cluj-Napoca, Romania","2006 Eighth International Symposium on Symbolic and Numeric Algorithms for Scientific Computing","12 Feb 2007","2006","","","69","74","Clustering is a division of data into groups of similar objects. Aspect mining is a process that tries to identify cross-cutting concerns in existing software systems. The goal is to refactor the existing systems to use aspect oriented programming, in order to make them easier to maintain and to evolve. This paper aims at presenting a new k-means based clustering algorithm used in Aspect Mining. Clustering is used in order to identify crosscutting concerns. We propose some quality measures in order to evaluate the results both from the clustering point of view and the aspect mining point of view, and we also report two case studies.","","0-7695-2740-X","10.1109/SYNASC.2006.5","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4090299","clustering;aspect mining.","Clustering algorithms;Software systems;Computer science;Partitioning algorithms;Scattering;Machine learning;Unsupervised learning;Petroleum;Software engineering;Productivity","data mining;object-oriented programming;pattern clustering","k-means-based clustering;aspect mining;cross-cutting concerns;software systems;aspect oriented programming","","11","","15","IEEE","12 Feb 2007","","","IEEE","IEEE Conferences"
"Software Tool for Validating and Verifying Rehosted Legacy Software and Interface Hardware","D. Mueller","Northrop Grumman Corporation, Clearfield, UT, USA","2006 IEEE Autotestcon","15 Jan 2007","2006","","","360","365","A Search Tool for integrating software and hardware, audits source code against requirement documents, highlights legacy references and unused code, and performs test setup analysis. The Search Tool reduces development time through use of automatic systems-level checks before the integration phase of development. This new systems-level software tool, called the GMATS Search Tool, analyzes design documents developed in several commercial, off-the-shelf (COTS) applications. The search tool checks Test Program Set (TPS) source code for correct switch management, unused code, incorrect names, and incorrect part numbers. Automated software audits compare source code to test requirement documents. The tool integrates Interface Test Adapter (ITA) wire list information with software to identify inconsistencies in the measurement, stimulus, and power test paths. The tool uses the ITA wire list to audit test diagrams. By utilizing these systems-level checks early in the re-host effort, software developers identify errors in the design long before the integration phase of development and achieve greater consistency among design documents and source code. Overall, the tool's software checks maintain the quality of the TPS and reduce the risk of adding new errors in the re- host effort.","1558-4550","1-4244-0051-1","10.1109/AUTEST.2006.283687","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4062400","","Software tools;Hardware;Software testing;Switches;Wire;Software maintenance;Software performance;Performance evaluation;Performance analysis;Application software","automatic test equipment;program testing;program verification;software tools","software tool;legacy software;interface hardware;search tool;systems-level checks;GMATS;test program set;source code;switch management;interface test adapter","","","","4","IEEE","15 Jan 2007","","","IEEE","IEEE Conferences"
"Merging Head and Tail Duplication for Convergent Hyperblock Formation","B. A. Maher; A. Smith; D. Burger; K. S. McKinley","Department of Computer Sciences, University of Texas, Austin, USA; Department of Computer Sciences, University of Texas, Austin, USA; Department of Computer Sciences, University of Texas, Austin, USA; Department of Computer Sciences, University of Texas, Austin, USA","2006 39th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO'06)","26 Dec 2006","2006","","","65","76","VLIW and EDGE (explicit data graph execution) architectures rely on compilers to form high-quality hyper-blocks for good performance. These compilers typically perform hyperblock formation, loop unrolling, and scalar optimizations in a fixed order. This approach limits the compiler's ability to exploit or correct interactions among these phases. EDGE architectures exacerbate this problem by imposing structural constraints on hyperblocks, such as instruction count and instruction composition. This paper presents convergent hyperblock formation, which iteratively applies if-conversion, peeling, unrolling, and scalar optimizations until converging on hyperblocks that are as close as possible to the structural constraints. To perform peeling and unrolling, convergent hyperblock formation generalizes tail duplication, which removes side entrances to acyclic traces, to remove back edges into cyclic traces using head duplication. Simulation results for an EDGE architecture show that convergent hyperblock formation improves code quality over discrete-phase approaches with heuristics for VLIW and EDGE. This algorithm offers a solution to hyperblock phase ordering problems and can be configured to implement a wide range of policies","2379-3155","0-7695-2732-9","10.1109/MICRO.2006.34","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4041836","","Merging;Tail;VLIW;Optimizing compilers;Constraint optimization;Hardware;Parallel processing;Runtime;Microarchitecture;High performance computing","computer architecture;data flow graphs;program compilers","convergent hyperblock formation;explicit data graph execution architecture;scalar optimization;discrete-phase approach;hyperblock phase ordering problem","","13","32","25","IEEE","26 Dec 2006","","","IEEE","IEEE Conferences"
"Software and Biological Evolvability: A Comparison Using Key Properties","L. Yu; S. Ramaswamy","Computer Science and Informatics, Indiana University, South Bend, IN, USA; Invited Research Professor, LITIS, University of Arkansas, Little Rock, France","2006 Second International IEEE Workshop on Software Evolvability (SE'06)","19 Dec 2006","2006","","","82","88","Biological and software systems share a common property from evolution: they need to change and adapt to either a new environment or a new requirement. If the environment or requirement changes, those systems that have high evolvability will survive and others will be eliminated. The evolvability of a biological system has been widely studied and shown to be dependent on several properties: self-organization, modularity, gene duplication, gene robustness, and symbiosis. This position paper discusses the evolvability of a software system with respect to these properties. Our study shows that software systems share similar evolvability properties with biological systems. We conclude that studying and comparing the internal structures as well as the overall evolution process of these biological systems can help us understand software systems from a holistic 'product-lifecycle' perspective thereby helping us develop software systems with better evolvability traits","","0-7695-2698-5","10.1109/SOFTWARE-EVOLVABILITY.2006.11","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4032452","","Software systems;Evolution (biology);Biological systems;Open systems;Biology;Organisms;Robustness;Symbiosis;Software engineering;Software measurement","evolution (biological);software prototyping","software system evolvability;biological system evolvability;product-lifecycle perspective","","12","","30","IEEE","19 Dec 2006","","","IEEE","IEEE Conferences"
"Extracting Reusable Object-Oriented Legacy Code Segments with Combined Formal Concept Analysis and Slicing Techniques for Service Integration","Z. Zhang; H. Yang; W. C. Chu","Software Technology Research Laboratory, De Montfort University, Leicester, UK; Software Technology Research Laboratory, De Montfort University, Leicester, UK; Department of Computer Science and Information Engineering, TungHai University, Taichung, Taiwan","2006 Sixth International Conference on Quality Software (QSIC'06)","19 Dec 2006","2006","","","385","392","Web services, together with service-oriented architectures, are promising integration technology to facilitate legacy system Webification and evolution. However, a service-oriented re-engineering process is still essential for legacy systems to survive in the service-oriented computing environment. In this service-oriented re-engineering process, understanding and reusing object-oriented code turn to be important activities. In this paper, we proposed a comprehensive approach to support the extraction and integration of reusable object-oriented legacy code. In the extraction phase, formal concept analysis, which is a general and flexible technique for recovering structural design information, and inter-procedural program slicing are adopted as main reverse engineering techniques to recover reusable object-oriented code. In the integration phase, service packaging processes are presented in details. Our approach produces extracted components with core legacy object-oriented code function in Web services by wrapping underlying computing models with XML","2332-662X","0-7695-2718-3","10.1109/QSIC.2006.29","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4032309","","Service oriented architecture;Web services;Data mining;Application software;Reverse engineering;Information analysis;Computer architecture;Object oriented modeling;Lattices;Software reusability","formal specification;object-oriented programming;program compilers;program slicing;reverse engineering;software maintenance;software reusability;systems re-engineering;Web services;XML","reusable object-oriented legacy code segment extraction;formal concept analysis;service integration;Web services;service-oriented architecture;legacy system Webification;legacy system evolution;service-oriented reengineering;service-oriented computing;code understanding;structural design information;interprocedural program slicing;reverse engineering;service packaging;component extraction;XML","","11","1","32","IEEE","19 Dec 2006","","","IEEE","IEEE Conferences"
"Using a Competitive Clustering Algorithm to Comprehend Web Applications","A. De Lucia; G. Scanniello; G. Tortora","Universita degli Studi di Salerno, Fisciano, Campania, IT; Dipartimento di Matematica e Informatica, University of Salerno Via Ponte Don Melillo, Fisciano, SA, ITALY; Dipartimento di Matematica e Informatica, University of Salerno Via Ponte Don Melillo, Fisciano, SA, ITALY","2006 Eighth IEEE International Symposium on Web Site Evolution (WSE'06)","11 Dec 2006","2006","","","33","40","We propose an approach based on winner takes all, a competitive clustering algorithm, to support the comprehension of static and dynamic Web applications. The process first computes the distances between the Web pages and then identifies similar pages through the winner takes all clustering algorithm. Two different instances of the process are presented to identify similar pages at structural and content level, respectively. The first instance encodes the page structure into a string and then uses the Levenshtein algorithm to achieve the distances between pairs of pages. On the other hand, to group similar pages at content level we use the latent semantic indexing to produce the page representations as vectors in the concept space. The Euclidean distance is then computed between the vectors to achieve the distances between the pages to be given as input to the adopted clustering algorithm. A prototype to automate the identification of group of similar pages has been implemented. The approach and the prototype have been assessed in a case study","1550-4441","0-7695-2696-9","10.1109/WSE.2006.19","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4027204","","Clustering algorithms;Web pages;Application software;Prototypes;Reverse engineering;HTML;Cloning;Software prototyping;Indexing;Euclidean distance","indexing;pattern clustering;Web sites","competitive clustering;Web application comprehension;Web pages;winner takes all clustering;Levenshtein algorithm;latent semantic indexing;Euclidean distance","","4","2","25","IEEE","11 Dec 2006","","","IEEE","IEEE Conferences"
"Normalizing Metamorphic Malware Using Term Rewriting","A. Walenstein; R. Mathur; M. R. Chouchane; A. Lakhotia","Center for Advanced Computer Studies, University of Louisiana, Lafayette, USA; Center for Advanced Computer Studies, University of Louisiana, Lafayette, USA; Center for Advanced Computer Studies, University of Louisiana, Lafayette, USA; Center for Advanced Computer Studies, University of Louisiana, Lafayette, USA","2006 Sixth IEEE International Workshop on Source Code Analysis and Manipulation","11 Dec 2006","2006","","","75","84","Metamorphic malware - including certain viruses and worms - rewrite their code during propagation. This paper presents a method for normalizing multiple variants of metamorphic programs that perform their transformations using finite sets of instruction-sequence substitutions. The paper shows that the problem of constructing a normalizer can, in specific contexts, be formalized as a term rewriting problem. A general method is proposed for constructing normalizers. It involves modeling the metamorphic program's transformations as rewrite rules, and then modifying these rules to create a normalizing rule set. Casting the problem in terms of term rewriting exposes key challenges for constructing effective normalizers. In cases where the challenges cannot be met, approximations are proposed. The normalizer construction method is applied in a case study involving the virus called""W32.Evolt"". The results demonstrate that both the overall approach and the approximation schemes may have practical use on realistic malware, and may thus have the potential to improve signature-based malware scanners.","","0-7695-2353-6","10.1109/SCAM.2006.20","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4026857","","Computer worms;Computer viruses;Casting;Pattern matching;Emulation;Manipulator dynamics;Conferences;Computer aided instruction;Data mining","","","","30","","20","IEEE","11 Dec 2006","","","IEEE","IEEE Conferences"
"Evolving TXL","A. D. Thurston; J. R. Cordy","School of Computing, Queen''s University, Kingston, ONT, Canada; School of Computing, Queen''s University, Kingston, ONT, Canada","2006 Sixth IEEE International Workshop on Source Code Analysis and Manipulation","11 Dec 2006","2006","","","117","126","TXL is a functional programming language specifically designed for expressing source transformation tasks. Originally designed for the rapid prototyping of modest syntactic enhancements, in recent years it has been extensively used in large scale source code analysis and reengineering applications that are much more challenging. As a result, many common programming techniques needed in these larger scale applications are difficult or impossible to express in TXL. Examples include multi-way decisions, generic rules and functions, polymorphism and information hiding. In this paper we introduce ETXL, an experimental extension of TXL which includes convenient features designed to address these issues. Designed to be a compatible variant that remains faithful to the original TXL syntax and semantics, ETXL has itself been prototyped as a source transformation to original TXL.","","0-7695-2353-6","10.1109/SCAM.2006.14","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4026861","","Functional programming;Prototypes;Computer languages;Large-scale systems;Heart;Web page design;Logic programming;Testing;Conferences","","","","5","","16","IEEE","11 Dec 2006","","","IEEE","IEEE Conferences"
"On the Use of Process Trails to Understand Software Development","L. Cerulo","RCOST-Research Centre on Software Technology, University of Sannio, Benevento, Italy","2006 13th Working Conference on Reverse Engineering","11 Dec 2006","2006","","","303","304","Software repositories, such as version control systems (CVS) and bug-tracking systems (Bugzilla), provide useful information about software process trails left by developers during the evolution of a software project. Mining these repositories provides a way to understand software development, to support predictions about software development, and to plan various aspects of software projects. We introduce three cases in the areas of impact analysis, change request assignment, and crosscutting concern mining, that takes benefit from historical information and show that the combination of different type of analyses can improve the performance of these software engineering models","2375-5369","0-7695-2719-1","10.1109/WCRE.2006.40","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4024004","","Programming;Performance analysis;Information analysis;Software systems;Control systems;Software engineering;Software tools;Documentation;Software performance;Information resources","configuration management;data mining;program debugging;program diagnostics;software process improvement","process trails;software development;software repository;version control systems;bug-tracking systems;Bugzilla;impact analysis;change request assignment;crosscutting concern mining;software engineering model","","5","","7","IEEE","11 Dec 2006","","","IEEE","IEEE Conferences"
"Mining Control Flow Graphs for Crosscutting Concerns","J. Krinke","Fern Universität Hagen, Germany","2006 13th Working Conference on Reverse Engineering","11 Dec 2006","2006","","","334","342","Aspect mining tries to identify crosscutting concerns in existing systems and thus supports the adoption to an aspect-oriented design. This paper describes an automatic static aspect mining approach, where the control flow graphs of a program are investigated for recurring execution patterns based on different constraints, such as the requirement that the patterns have to exist in different calling contexts. A case study done with the implemented tool shows that most discovered crosscutting candidates are instances of crosscutting delegation and should not be refactored into aspects","2375-5369","0-7695-2719-1","10.1109/WCRE.2006.37","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4024015","","Flow graphs;Software systems;Pattern analysis;Automatic control;Runtime;Control systems;Scattering;Software maintenance;Timing;Reverse engineering","data mining;flow graphs;object-oriented programming","control flow graph mining;crosscutting concerns;aspect-oriented design;automatic static aspect mining;recurring execution patterns","","12","","25","IEEE","11 Dec 2006","","","IEEE","IEEE Conferences"
"Clone Detection Using Abstract Syntax Suffix Trees","R. Koschke; R. Falke; P. Frenzel","University of Brethemen, Germany; University of Brethemen, Germany; University of Brethemen, Germany","2006 13th Working Conference on Reverse Engineering","11 Dec 2006","2006","","","253","262","Reusing software through copying and pasting is a continuous plague in software development despite the fact that it creates serious maintenance problems. Various techniques have been proposed to find duplicated redundant code (also known as software clones). A recent study has compared these techniques and shown that token-based clone detection based on suffix trees is extremely fast but yields clone candidates that are often no syntactic units. Current techniques based on abstract syntax trees-on the other hand-find syntactic clones but are considerably less efficient. This paper describes how we can make use of suffix trees to find clones in abstract syntax trees. This new approach is able to find syntactic clones in linear time and space. The paper reports the results of several large case studies in which we empirically compare the new technique to other techniques using the Bellon benchmark for clone detectors","2375-5369","0-7695-2719-1","10.1109/WCRE.2006.18","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4023995","","Cloning;Detectors;Programming profession;Concrete;Redundancy;Abstracts;Encoding;Software maintenance;Monitoring;Filters","abstract data types;programming language semantics;software maintenance;software reusability;trees (mathematics)","clone detection;abstract syntax suffix trees;software reusability;software development;software maintenance;redundant code;software clones;syntactic units;syntactic clones;Bellon benchmark","","162","3","27","IEEE","11 Dec 2006","","","IEEE","IEEE Conferences"
"Refactoring Detection based on UMLDiff Change-Facts Queries","Z. Xing; E. Stroulia","Computing Science Department, University of Alberta, Edmonton, AB, Canada; Computing Science Department, University of Alberta, Edmonton, AB, Canada","2006 13th Working Conference on Reverse Engineering","11 Dec 2006","2006","","","263","274","Refactoring is an important activity in the evolutionary development of object-oriented software systems. Several IDEs today support the automated application of some refactorings; at the same time, there is substantial on-going research aimed at developing support for deciding when and how software should be refactored and for estimating the effect of the refactoring on the quality requirements of the software. On the other hand, understanding the refactorings in the evolutionary history of a software system is essential in understanding its design rationale. Yet, only very limited support exists for detecting refactorings. In this paper, we present our approach for detecting refactorings by analyzing the system evolution at the design level. We evaluate our method with case studies, examining two realistic examples of object-oriented software","2375-5369","0-7695-2719-1","10.1109/WCRE.2006.48","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4023996","","Software systems;History;Documentation;Visualization;Algorithm design and analysis;Software quality;Software design;Cloning;Reverse engineering;Concrete","object-oriented programming;software maintenance;software quality;Unified Modeling Language","refactoring detection;UMLDiff change-facts queries;object-oriented software","","61","","36","IEEE","11 Dec 2006","","","IEEE","IEEE Conferences"
"""Cloning Considered Harmful"" Considered Harmful","C. Kapser; M. W. Godfrey","Software Architecture Group (SWAG), David R. Cheriton School of Computer Science, University of Waterloo, Canada; Software Architecture Group (SWAG), David R. Cheriton School of Computer Science, University of Waterloo, Canada","2006 13th Working Conference on Reverse Engineering","11 Dec 2006","2006","","","19","28","Current literature on the topic of duplicated (cloned) code in software systems often considers duplication harmful to the system quality and the reasons commonly cited for duplicating code often have a negative connotation. While these positions are sometimes correct, during our case studies we have found that this is not universally true, and we have found several situations where code duplication seems to be a reasonable or even beneficial design option. For example, a method of introducing experimental changes to core subsystems is to duplicate the subsystem and introduce changes there in a kind of sandbox testbed. As features mature and become stable within the experimental subsystem, they can then be introduced gradually into the stable code base. In this way risk of introducing instabilities in the stable version is minimized. This paper describes several patterns of cloning that we have encountered in our case studies and discusses the advantages and disadvantages associated with using them","2375-5369","0-7695-2719-1","10.1109/WCRE.2006.1","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4023973","","Cloning;Software systems;Stability;Software architecture;Computer science;Testing;Libraries;Costs;Reverse engineering","software maintenance","code cloning;software system;code duplicating","","125","","30","IEEE","11 Dec 2006","","","IEEE","IEEE Conferences"
"A common framework for aspect mining based on crosscutting concern sorts","M. Marin; L. Moonen; A. V. Deursen","Delft University of Technology, The Netherlands; Delft Univ. of Technology & CWI, The Netherlands; Delft Univ. of Technology & CWI, The Netherlands","2006 13th Working Conference on Reverse Engineering","11 Dec 2006","2006","","","29","38","The increasing number of aspect mining techniques proposed in literature calls for a methodological way of comparing and combining them in order to assess, and improve on, their quality. This paper addresses this situation by proposing a common framework based on crosscutting concern sorts which allows for consistent assessment, comparison and combination of aspect mining techniques. The framework identifies a set of requirements that ensure homogeneity in formulating the mining goals, presenting the results and assessing their quality. We demonstrate feasibility of the approach by retrofitting an existing aspect mining technique to the framework, and by using it to design and implement two new mining techniques. We apply the three techniques to a known aspect mining benchmark and show how they can be consistently assessed and combined to increase the quality of the results. The techniques and combinations are implemented in FINT, our publicly available free aspect mining tool","2375-5369","0-7695-2719-1","10.1109/WCRE.2006.6","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4023974","","Marine technology;Convergence;Acoustic scattering;Humans;Pattern analysis","data mining","aspect mining;crosscutting concern sorts;FINT","","13","","14","IEEE","11 Dec 2006","","","IEEE","IEEE Conferences"
"Dynamic Aspects Weaving in Service Composition","H. Song; Y. Yin; S. Zheng","College of Mechanical Engineering, South China University of Technology, Guangzhou, Guangdong, China; Department of Electronic Engineering, GuangDong Polytechnic Normal University, Guangzhou, Guangdong, China; College of Mechanical Engineering, School of Business Administration, South China University of Technology, Guangzhou, Guangdong, China","Sixth International Conference on Intelligent Systems Design and Applications","11 Dec 2006","2006","1","","1003","1008","Web service composition is to construct complex service through combining available services components as request. A service component is a self-contained unit of service construction that provides an identifiable and distinct part of a service with well-defined interface. For example, to assure the security of Web service, both the service provider and requestor should take account of the security control. But the implementation of crosscutting concerns, such as security control, will scatter in multiple components. In this paper we adopt the aspect-oriented programming (AOP) to separate security control from other functional requirements. AOP is a new software development paradigm that aims to increase comprehensibility, adaptability, and reusability by introducing aspect to modularize the crosscutting concerns. Any behavior associated to several components is encapsulated into an aspect. In our work, the composition is extended by weaving extension at running time. It makes the service composition more flexible and gives the composer a chance to unify security policy in composed service by specifying appropriate security extension himself. This paper also presents an infrastructure to demonstrate how dynamic weaving of aspects can be used to enhance the security of service composition. An application of performing user-defined access control dynamically at run-time is given to exemplify the dynamic extension to service composition","2164-7151","0-7695-2528-8","10.1109/ISDA.2006.137","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4021576","","Weaving;Web services;Security;Educational institutions;Mechanical engineering;Service oriented architecture;Dynamic programming;Scattering;Functional programming;Access control","object-oriented programming;security of data;software architecture;software reusability;Web services","Web service composition;service component;self-contained unit of service construction;aspect-oriented programming;security control;software development;software comprehensibility;software adaptability;software reusability;security policy;service-oriented architecture;dynamic weaving","","4","1","16","IEEE","11 Dec 2006","","","IEEE","IEEE Conferences"
"The Conceptual Coupling Metrics for Object-Oriented Systems","D. Poshyvanyk; A. Marcus","Department of Computer Science, Wayne State University, Detroit, MI, USA; Department of Computer Science, Wayne State University, Detroit, MI, USA","2006 22nd IEEE International Conference on Software Maintenance","11 Dec 2006","2006","","","469","478","Coupling in software has been linked with maintainability and existing metrics are used as predictors of external software quality attributes such as fault-proneness, impact analysis, ripple effects of changes, changeability, etc. Many coupling measures for object-oriented (OO) software have been proposed, each of them capturing specific dimensions of coupling. This paper presents a new set of coupling measures for OO systems - named conceptual coupling, based on the semantic information obtained from the source code, encoded in identifiers and comments. A case study on open source software systems is performed to compare the new measures with existing structural coupling measures. The case study shows that the conceptual coupling captures new dimensions of coupling, which are not captured by existing coupling measures; hence it can be used to complement the existing metrics","1063-6773","0-7695-2354-4","10.1109/ICSM.2006.67","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4021375","","Software measurement;Software quality;Software maintenance;Software systems;Open source software;Information analysis;Object oriented modeling;Application software;Software design;Computer science","object-oriented programming;software maintenance;software metrics;software quality","conceptual coupling metrics;software maintainability;software metrics;software quality;object-oriented software;object-oriented system coupling measures;source code semantic information;open source software systems","","84","1","38","IEEE","11 Dec 2006","","","IEEE","IEEE Conferences"
"Refactoring Practice: How it is and How it Should be Supported - An Eclipse Case Study","Z. Xing; E. Stroulia","Computing Science Department, University of Alberta, Edmonton, AB, Canada; Computing Science Department, University of Alberta, Edmonton, AB, Canada","2006 22nd IEEE International Conference on Software Maintenance","11 Dec 2006","2006","","","458","468","Refactoring is an important activity in the evolutionary development of object-oriented software systems. Yet, several questions about the practice of refactoring remain unanswered, such as what fraction of code modifications are refactorings and what are the most frequent types of refactorings. To gain some insight in this matter, we conducted a detailed case study on the structural evolution of Eclipse, an integrated-development environment (IDE) and a plugin-based framework. Our study indicates that: 1) about 70% of structural changes may be due to refactorings; 2) for about 60% of these changes, the references to the affected entities in a component-based application can be automatically updated by a refactoring-migration tool if the relevant information of refactored components can be gathered through the refactoring engine; and 3) state-of-the-art IDEs, such as Eclipse, support only a subset of commonly applied low-level refactorings and lack support for more complex ones, which are also frequent. Based on our findings, we draw some conclusions on high-level design requirements for a refactoring-based development environment","1063-6773","0-7695-2354-4","10.1109/ICSM.2006.52","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4021374","","Software systems;Application software;Engines;Object oriented modeling;Software design;Costs;Documentation;Large-scale systems;Algorithm design and analysis;Software packages","object-oriented programming;software libraries;software tools","software refactoring practice;Eclipse case study;evolutionary development;object-oriented software systems;integrated-development environment;plugin-based framework;component-based application;refactoring-migration tool;refactored components;refactoring engine;refactoring-based development environment","","54","","19","IEEE","11 Dec 2006","","","IEEE","IEEE Conferences"
"On the Use of Line Co-change for Identifying Crosscutting Concern Code","G. Canfora; L. Cerulo; M. Di Penta","RCOST - Research Centre on Software Technology, University of Sannio Viale Traiano, Benevento, Italy; RCOST - Research Centre on Software Technology, University of Sannio Viale Traiano, Benevento, Italy; RCOST - Research Centre on Software Technology, University of Sannio Viale Traiano, Benevento, Italy","2006 22nd IEEE International Conference on Software Maintenance","11 Dec 2006","2006","","","213","222","Crosscutting concerns are software system features whose implementation is spread across many modules as tangled and scattered code. Identifying such code helps developers to change the concern and/or re-factor it to an aspect. This paper evaluates the suitability of line co-change as a technique for the identification of crosscutting concerns. A line co-change aim at identifying source code lines that have been changed together in a commit transaction performed using a versioning system such as CVS. Promising results have been obtained by evaluating the approach to identify four crosscutting concerns present in an open-source system, JHotDraw. The paper also shows that line co-change can be effectively complemented with clone detection to improve the performance achieved by the separate approaches","1063-6773","0-7695-2354-4","10.1109/ICSM.2006.43","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4021340","","Cloning;Scattering;History;Software systems;Pattern analysis;Automation;Programming profession;Performance analysis;Interference;Software maintenance","configuration management;public domain software;software maintenance","line cochange;crosscutting concern code;software system features;source code lines;versioning system;open-source system;JHotDraw;clone detection","","22","","32","IEEE","11 Dec 2006","","","IEEE","IEEE Conferences"
"A Feedback Based Quality Assessment to Support Open Source Software Evolution: the GRASS Case Study","M. Neteler; E. Merlo; G. Antoniol; S. Bouktif; M. Neteler; E. Merlo; G. Antoniol; S. Bouktif","Department of Computer Science, École Polytechnique de Montréal, Montreal, Québec, Canada; Department of Computer Science, École Polytechnique de Montréal, Montreal, Québec, Canada; Department of Computer Science, École Polytechnique de Montréal, Montreal, Québec, Canada; ITC-irst – Istituto Trentino di Cultura Via Sommarive, Povo(Trento), Italy; Dept. of Comput. Sci., Ecole Polytechnique de Montreal, Que.; Dept. of Comput. Sci., Ecole Polytechnique de Montreal, Que.; Dept. of Comput. Sci., Ecole Polytechnique de Montreal, Que.; Dept. of Comput. Sci., Ecole Polytechnique de Montreal, Que.","2006 22nd IEEE International Conference on Software Maintenance","11 Dec 2006","2006","","","155","165","Managing the software evolution for large open source software is a major challenge. Some factors that make software hard to maintain are geographically distributed development teams, frequent and rapid turnover of volunteers, absence of a formal means, and lack of documentation and explicit project planning. In this paper we propose remote and continuous analysis of open source software to monitor evolution using available resources such as CVS code repository, commitment log files and exchanged mail. Evolution monitoring relies on three principal services. The first service analyzes and monitors the increase in complexity and the decline in quality; the second supports distributed developers by sending them a feedback report after each contribution; the third allows developers to gain insight into the ""big picture"" of software by providing a dashboard of project evolution. Besides the description of provided services, the paper presents a prototype environment for continuous analysis of the evolution of GRASS, an open source software.","1063-6773","0-7695-2354-4","10.1109/ICSM.2006.5","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4021333","","Feedback;Quality assessment;Open source software;Remote monitoring;Software maintenance;Linux;Kernel;Software engineering;Software quality;Guidelines","program diagnostics;public domain software;software maintenance;software management;software quality","feedback based quality assessment;open source software evolution;GRASS case study;software evolution management;software maintenance;remote software analysis;continuous software analysis;evolution monitoring","","11","","23","IEEE","11 Dec 2006","","","IEEE","IEEE Conferences"
"Identifying Refactorings from Source-Code Changes","P. Weissgerber; S. Diehl","Computer Science, University of Trier, Trier, Germany; Computer Science, University of Trier, Trier, Germany","21st IEEE/ACM International Conference on Automated Software Engineering (ASE'06)","4 Dec 2006","2006","","","231","240","Software has been and is still mostly refactored without tool support. Moreover, as we found in our case studies, programmers tend not to document these changes as refactorings, or even worse label changes as refactorings, although they are not. In this paper we present a technique to detect changes that are likely to be refactorings and rank them according to the likelihood. The evaluation shows that the method has both a high recall and a high precision - it finds most of the refactorings, and most of the found refactoring candidates are really refactorings","1938-4300","0-7695-2579-2","10.1109/ASE.2006.41","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4019578","","Programming profession;Data mining;Computer science;Computer errors;Open source software;Software tools;History;Documentation;Application software;Databases","configuration management;data mining","refactoring identification;source-code changes;software changes","","99","3","20","IEEE","4 Dec 2006","","","IEEE","IEEE Conferences"
"Mining Aspects from Version History","S. Breu; T. Zimmermann","Computer Laboratory, University of Cambridge, UK; Department of Computer Science, University of Saarland, Germany","21st IEEE/ACM International Conference on Automated Software Engineering (ASE'06)","4 Dec 2006","2006","","","221","230","Aspect raining identifies cross-culling concerns in a program, to help migrating it to an aspect-oriented design. Such concerns may not exist from the beginning, but emerge over time. By analysing where developers add code to a program, our history-based aspect mining (BAM) identifies and ranks cross-cutting concerns. We evaluated the effectiveness of our approach with the history of three open-source projects. BAM scales up to Industrial-sized projects: for example, we were able to identify a locking concern that cross-cuts 1284 methods in Eclipse. Additionally, the precision of HAM increases with project size and history: for Eclipse, it reaches 90% for the top-10 candidates","1938-4300","0-7695-2579-2","10.1109/ASE.2006.50","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4019577","","History;Lab-on-a-chip;Open source software;Laboratories;Computer science;System recovery;Helium;Java;Scattering;Weaving","configuration management;data mining;Java;object-oriented programming;public domain software","version history;aspect-oriented design;history-based aspect mining;open-source projects;Eclipse","","50","","26","IEEE","4 Dec 2006","","","IEEE","IEEE Conferences"
"Parameterized Looped Schedules for Compact Representationof Execution Sequences","M. -y. Ko; C. Zissulescu; S. Puthenpurayil","Dept. of Electrical and Computer Engineering, Institute for Advanced Computer Studies University of Maryland, College Park, USA; Leiden Institute of Advanced Computer Science Leiden University, The Netherlands; University of Maryland at College Park, USA","IEEE 17th International Conference on Application-specific Systems, Architectures and Processors (ASAP'06)","4 Dec 2006","2006","","","223","230","This paper is concerned with the compact representation of execution sequences in terms of efficient looping constructs. Here, by a looping construct, we mean a compact way of specifying a finite repetition of a set of execution primitives. Such compaction, which can be viewed as a form of hierarchical run-length encoding (RLE), has application in many DSP system synthesis contexts, including efficient control generation for Kahn processes on FPGAs, and software synthesis for static dataflow models of computation. In this paper, we significantly generalize previous models for loop-based code compaction of DSP programs to yield a configurable code compression methodology that exhibits a broad range of achievable trade-offs. Specifically, we formally develop and apply to DSP hardware and software implementation a parameterizable loop scheduling approach with compact format, dynamic reconfigurability, and low-overhead decompression. In our experiments, this new approach demonstrates up to 99% storage saving (versus RLE) and up to 46% frequency enhancement (versus another parameterized approach) in FPGA synthesis, and an average of 11% code size reduction in software synthesis compared to existing methods for code size reduction.","1063-6862","0-7695-2682-9","10.1109/ASAP.2006.51","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4019520","","Digital signal processing;Compaction;Control system synthesis;Field programmable gate arrays;Encoding;Application software;Computational modeling;Context modeling;Hardware;Processor scheduling","","","","2","","15","IEEE","4 Dec 2006","","","IEEE","IEEE Conferences"
"An Exploratory Study of How Developers Seek, Relate, and Collect Relevant Information during Software Maintenance Tasks","A. J. Ko; B. A. Myers; M. J. Coblenz; H. H. Aung","Human-Computer Interaction Institute, School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, USA; Human-Computer Interaction Institute, School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, USA; Human-Computer Interaction Institute, School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, USA; Human-Computer Interaction Institute, School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, USA","IEEE Transactions on Software Engineering","30 Nov 2006","2006","32","12","971","987","Much of software developers' time is spent understanding unfamiliar code. To better understand how developers gain this understanding and how software development environments might be involved, a study was performed in which developers were given an unfamiliar program and asked to work on two debugging tasks and three enhancement tasks for 70 minutes. The study found that developers interleaved three activities. They began by searching for relevant code both manually and using search tools; however, they based their searches on limited and misrepresentative cues in the code, environment, and executing program, often leading to failed searches. When developers found relevant code, they followed its incoming and outgoing dependencies, often returning to it and navigating its other dependencies; while doing so, however, Eclipse's navigational tools caused significant overhead. Developers collected code and other information that they believed would be necessary to edit, duplicate, or otherwise refer to later by encoding it in the interactive state of Eclipse's package explorer, file tabs, and scroll bars. However, developers lost track of relevant code as these interfaces were used for other tasks, and developers were forced to find it again. These issues caused developers to spend, on average, 35 percent of their time performing the mechanics of navigation within and between source files. These observations suggest a new model of program understanding grounded in theories of information foraging and suggest ideas for tools that help developers seek, relate, and collect information in a more effective and explicit manner.","1939-3520","","10.1109/TSE.2006.116","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4016573","Program investigation;program understanding;program comprehension;empirical software engineering;information foraging;information scent.","Software maintenance;Programming;Navigation;Software engineering;Software tools;Performance gain;Debugging;Encoding;Packaging;Bars","program debugging;software maintenance","software maintenance tasks;software development environment;debugging task;search tool;Eclipse package explorer;file tabs;scroll bars;source files;program understanding;information foraging","","381","1","51","IEEE","30 Nov 2006","","","IEEE","IEEE Journals"
"The Detection and Classification of Non-Functional Requirements with Application to Early Aspects","J. Cleland-Huang; R. Settimi; X. Zou; P. Solc","Center of Requirements Engineering, School of Computer Science, Telecommunications, and Information Systems, De Paul University, USA; Center of Requirements Engineering, School of Computer Science, Telecommunications, and Information Systems, De Paul University, USA; Center of Requirements Engineering, School of Computer Science, Telecommunications, and Information Systems, De Paul University, USA; Center of Requirements Engineering, School of Computer Science, Telecommunications, and Information Systems, De Paul University, USA","14th IEEE International Requirements Engineering Conference (RE'06)","16 Oct 2006","2006","","","39","48","This paper introduces an information retrieval based approach for automating the detection and classification of non-functional requirements (NFRs). Early detection of NFRs is useful because it enables system level constraints to be considered and incorporated into early architectural designs as opposed to being refactored in at a later time. Candidate NFRs can be detected in both structured and unstructured documents, including requirements specifications that contain scattered and non-categorized NFRs, and freeform documents such as meeting minutes, interview notes, and memos containing stakeholder comments documenting their NFR related needs. This paper describes the classification algorithm and then evaluates its effectiveness in an experiment based on fifteen requirements specifications developed as term projects by MS students at DePaul University. An additional case study is also described in which the approach is used to classifying NFRs from a large free form requirements document obtained from Siemens Logistics and Automotive Organization","2332-6441","978-0-7695-2555-6","10.1109/RE.2006.65","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1704047","","","formal specification;formal verification","nonfunctional requirements;information retrieval based approach;freeform documents;classification algorithm","","107","1","19","IEEE","16 Oct 2006","","","IEEE","IEEE Conferences"
"Measuring Source Code Similarity Using Reference Vectors","A. Ohno; H. Murao","Graduate School of Cultural Studies and Human Science, Kobe University Nada, Kobe, Japan; Graduate School of Cultural Studies and Human Science, Kobe University Nada, Kobe, Japan","First International Conference on Innovative Computing, Information and Control - Volume I (ICICIC'06)","16 Oct 2006","2006","2","","92","95","This paper discusses on a method of measuring similarities between program source codes. Unlike many of existing similarity measuring method we do not compare a pair of source codes directly but compare them indirectly with using reference source codes. Using reference vectors calculated from each source codes and reference source codes reduced considerable amount of computation time for similarity measurement. To examine our method, we built a system implemented this algorithm and made computational experiments on Java program source codes submitted as assignments for a programming class. From results, we confirmed there are evident similarities between program source codes have close reference vectors each other","","0-7695-2616-0","10.1109/ICICIC.2006.308","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1691936","","Cloning;Large-scale systems;Software systems;Time measurement;Java;Cultural differences;Humans;Software measurement;Software maintenance;Open source software","Java;software metrics;vectors","source code similarity measuring method;reference source codes;reference vectors;Java program source codes","","1","1","7","IEEE","16 Oct 2006","","","IEEE","IEEE Conferences"
"TRex - The Refactoring and Metrics Tool for TTCN-3 Test Specifications","P. Baker; D. Evans; J. Grabowski; H. Neukirchen; B. Zeiss","Motorola Research Laboratories, Hampshire, UK; Motorola Research Laboratories, Hampshire, UK; Software Engineering for Distributed Systems Group, Institute for Informatics, University of Göttingen, Gottingen, Germany; Software Engineering for Distributed Systems Group, Institute for Informatics, University of Göttingen, Gottingen, Germany; Software Engineering for Distributed Systems Group, Institute for Informatics, University of Göttingen, Gottingen, Germany","Testing: Academic & Industrial Conference - Practice And Research Techniques (TAIC PART'06)","16 Oct 2006","2006","","","90","94","Comprehensive testing of modern communication systems often requires large and complex test suites which then have to be maintained throughout the system life-cycle. Industrial experience, with those written in the standardised Testing and Test Control Notation (TTCN-3), has shown that this maintenance is a non-trivial task and its burden could be reduced if appropriate tool support existed. To this aim, Motorola has collaborated with the University of G¨ottingen to develop TRex, a TTCN-3 development environment published under the Eclipse Public License, which notably provides suitable metrics and refactorings to enable the assessment and automatic restructuring of test suites. In this paper we present the TRex tool, which will make it far easier to construct and maintain TTCN-3 tests that are concise and optimally balanced with respect to readability, usability, and maintainability.","","0-7695-2672-1","10.1109/TAIC-PART.2006.35","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1691674","","Aerospace testing;System testing;Life testing;Software testing;Usability;Telecommunication standards;Signal processing;Communication industry;Computer industry;Software engineering","formal specification;program testing;software maintenance;software metrics;software process improvement;software quality;telecommunication computing","TRex tool;refactoring tool;metrics tool;TTCN-3 test specification;communication system testing;software maintenance;system life-cycle;standardised testing and test control notation;TTCN-3 development environment;Eclipse Public License;test suite assessment;test suite automatic restructuring;software readability;software usability","","10","","14","IEEE","16 Oct 2006","","","IEEE","IEEE Conferences"
"Tool-Supported Refactoring of Existing Object-Oriented Code into Aspects","D. Binkley; M. Ceccato; M. Harman; F. Ricca; P. Tonella","Loyola College, Baltimore, MD, USA; ITC IRST, Trento, Italy; King''s College, London, UK; ITC IRST, Trento, Italy; ITC IRST, Trento, Italy","IEEE Transactions on Software Engineering","9 Oct 2006","2006","32","9","698","717","Aspect-oriented programming (AOP) provides mechanisms for the separation of crosscutting concerns - functionalities scattered through the system and tangled with the base code. Existing systems are a natural testbed for the AOP approach since they often contain several crosscutting concerns which could not be modularized using traditional programming constructs. This paper presents an automated approach to the problem of migrating systems developed according to the object-oriented programming (OOP) paradigm into aspect-oriented programming (AOP). A simple set of six refactorings has been defined to transform OOP to AOP and has been implemented in the AOP-migrator tool, an Eclipse plug-in. A set of enabling transformations from OOP to OOP complement the initial set of refactorings. The paper presents the results of four case studies, which use the approach to migrate selected crosscutting concerns from medium-sized Java programs (in the range of 10K to 40K lines of code) into equivalent programs in AspectJ. The case study results show the feasibility of the migration and indicate the importance of the enabling transformations as a preprocessing step","1939-3520","","10.1109/TSE.2006.95","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1707668","Aspect-oriented software development;refactoring;program transformation.","Object oriented programming;Scattering;System testing;Automatic programming;Java;Contracts;Software engineering;Automatic control;Costs;Humans","Java;object-oriented programming;program compilers;software quality;software tools","aspect-oriented programming;crosscutting concern;migrating system;object-oriented programming;Java program;AspectJ;tool-supported refactoring;program transformation","","42","1","36","IEEE","9 Oct 2006","","","IEEE","IEEE Journals"
"Experiences with product line development of embedded systems at Testo AG","R. Kolb; I. John; J. Knodel; D. Muthig; U. Haury; G. Meier","Fraunhofer Institute of Experimental Software Engineering (IESE), Kaiserslautern, Germany; Fraunhofer Institute of Experimental Software Engineering (IESE), Kaiserslautern, Germany; Fraunhofer Institute of Experimental Software Engineering (IESE), Kaiserslautern, Germany; Fraunhofer Institute of Experimental Software Engineering (IESE), Kaiserslautern, Germany; Testo AG, Lenzkirch, Germany; Testo AG, Lenzkirch, Germany","10th International Software Product Line Conference (SPLC'06)","11 Sep 2006","2006","","","10 pp.","181","Product line practices are increasingly becoming popular in the domain of embedded software systems. This paper presents results of assessing success, consistency, and quality of Testo's product line of climate and flue gas measurement devices after its construction and the delivery of three commercial products. The results of the assessment showed that the incremental introduction of architecture-centric product line development can be considered successful even though there is no quantifiable reduction of time-to-market as well as development and maintenance costs so far. The success is mainly shown by the ability of Testo to develop more complex products and the satisfaction of the involved developers. A major issue encountered is ensuring the quality of reusable components and the conformance of the products to the architecture during development and maintenance","","0-7695-2599-7","10.1109/SPLINE.2006.1691589","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1691589","","Embedded system;System testing;Software testing;Costs;Investments;Business;Temperature measurement;Software engineering;Embedded software;Flue gases","DP industry;embedded systems;software engineering","product line development;Testo AG;embedded software systems;reusable components quality","","13","","21","IEEE","11 Sep 2006","","","IEEE","IEEE Conferences"
"Software Source Code Correlation","R. Zeidman","Zeidman Consulting, Cupertino, CA, USA","5th IEEE/ACIS International Conference on Computer and Information Science and 1st IEEE/ACIS International Workshop on Component-Based Software Engineering,Software Architecture and Reuse (ICIS-COMSAR'06)","24 Jul 2006","2006","","","383","392","The degree of correlation between the source codes of different software programs is important for uncovering plagiarism, trade secret theft, copyright infringement, and patent infringement. Other uses include locating open source code within a proprietary program and determining common authorship of different programs. Measurement of source code correlation is an important factor in any punitive determination of rights infringement. Existing measures of source code correlation tend to focus on only one or two types of correlation. This paper presents a theoretical basis for a measure of source code correlation predicated on various uses and requirements. The paper also describes a software tool that uses multiple algorithms to determine this correlation measure. At the conclusion the paper compares the results produced by this tool against results produced by other tools when examining a controlled set of correlated source code files and finds that the new tool is more accurate than other tools in determining all types of source code correlation","","0-7695-2613-6","10.1109/ICIS-COMSAR.2006.79","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1652022","","Plagiarism;Logic programming;Software tools;Formal languages;Computer languages;Intellectual property;Open source software;Software algorithms;Software measurement;Reasoning about programs","computer crime;copyright;patents;program diagnostics;software metrics;software tools","software source code correlation measurement;software program;program plagiarism;trade secret theft;copyright infringement;patent infringement;open source code;software tool","","2","3","20","IEEE","24 Jul 2006","","","IEEE","IEEE Conferences"
"Memory-Conscious Reliable Execution on Embedded Chip Multiprocessors","G. Chen; M. Kandemir; I. Kolcu","Department of Computer Science and Engineering, Pennsylvania State University, University Park, PA, USA; Department of Computer Science and Engineering, Pennsylvania State University, University Park, PA, USA; Computation Department, University of Manchester, Institute of Science and Technology, Manchester, UK","International Conference on Dependable Systems and Networks (DSN'06)","10 Jul 2006","2006","","","13","22","Code and data duplication has been identified as one of the important mechanisms for improving reliability. In a chip multiprocessor-based execution environment, while it is possible to hide the overhead of code duplication through parallelism, hiding the memory space overhead incurred by data duplication is more difficult. This paper presents a compiler-directed memory-conscious data duplication scheme that tries to minimize the extra memory space required by duplicate execution. The proposed approach achieves this goal by using the memory locations that hold dead data to store the duplicates of the actively-used data. In this way, instead of using extra memory storage for duplicate elements, we use the existing memory locations to the extent allowed by usage patterns of data. The results collected from our experiments clearly show that the proposed approach saves significant memory space, as compared to a straightforward approach that implements full duplication","2158-3927","0-7695-2607-1","10.1109/DSN.2006.51","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1633491","","Parallel processing;Embedded computing;Optimizing compilers;Computer science;Data engineering;Reliability engineering;Network-on-a-chip;Silicon;Computer architecture;Sun","computer architecture;embedded systems;microprocessor chips;multiprocessing systems;program compilers","memory-conscious reliable execution;code duplication;embedded chip multiprocessor-based execution environment;compiler-directed memory-conscious data duplication scheme;extra memory storage;CMP architecture","","1","","32","IEEE","10 Jul 2006","","","IEEE","IEEE Conferences"
"Measuring, monitoring and controlling software maintenance efforts","M. Zanker; S. Gordea","University of Klagenfurt, Austria; University of Klagenfurt, Austria","Thirteenth International Symposium on Temporal Representation and Reasoning (TIME'06)","26 Jun 2006","2006","","","103","110","Launching a new software product on the market and maximizing the profit obtained from it is already an art considering the high expectations and conflicting requirements of the software market. Product managers have to take tough decisions regarding the product life cycle like choosing the right moment for a new release, modernization or system replacement. Under these conditions they have to continually monitor the time evolution of efforts and costs required for implementing and maintaining the software product. Software tools that are able to assess these activities constitute a great value for those who need to take product management decisions. In this paper we present an approach for measuring and monitoring maintenance efforts by focusing on measurements of coding related activities. We employ data mining techniques for classifying coding related effort and present a preliminary evaluation of using this approach","2332-6468","0-7695-2617-9","10.1109/TIME.2006.21","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1635988","","Software measurement;Monitoring;Software maintenance;Costs;Software engineering;Project management;Knowledge management;Engineering management;Information systems;Art","data mining;product life cycle management;software maintenance;software metrics;system monitoring","software maintenance effort measurment;software maintenance effort monitoring;software maintenance effort control;software product maintenance;product life cycle;software tool;product management decision;data mining","","3","","20","IEEE","26 Jun 2006","","","IEEE","IEEE Conferences"
"Experimental Settings in Program Comprehension: Challenges and Open Issues","G. A. Di Lucca; M. Di Penta","RCOST-Research Centre on Software Technology, University of Sannio, Benevento, Italy; RCOST-Research Centre on Software Technology, University of Sannio, Benevento, Italy","14th IEEE International Conference on Program Comprehension (ICPC'06)","26 Jun 2006","2006","","","229","234","Several approaches to program comprehension have been proposed along the years, ranging from fact extraction to sophisticated visualization tools. In order to effectively assess the benefits of each approach, or to properly compare different techniques, it is necessary to carry out a proper, well-defined experimentation. This work session aims to discuss the main issues in preparing experimental settings related to the evaluation of approaches and tools supporting program comprehension, as well as to promote networking aiming to carry on collaborative experimentations","1092-8138","0-7695-2601-2","10.1109/ICPC.2006.23","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631125","Empirical studies;program comprehension","Software tools;Visualization;Collaborative tools;Collaborative work;Human factors;Software maintenance;Instruments;Software systems;Performance evaluation;Packaging","program visualisation;reverse engineering;software maintenance","program comprehension;program visualization tool","","5","","11","IEEE","26 Jun 2006","","","IEEE","IEEE Conferences"
"Digging the Development Dust for Refactorings","C. Schofield; B. Tansey; Zhenchang Xing; E. Stroulia","Computing Science Department, University of Alberta, Edmonton, AB, Canada; Computing Science Department, University of Alberta, Edmonton, AB, Canada; Computing Science Department, University of Alberta, Edmonton, AB, Canada; Computing Science Department, University of Alberta, Edmonton, AB, Canada","14th IEEE International Conference on Program Comprehension (ICPC'06)","26 Jun 2006","2006","","","23","34","Software repositories are rich sources of information about the software development process. Mining the information stored in them has been shown to provide interesting insights into the history of the software development and evolution. Several different types of information have been extracted and analyzed from different points of view. However, these types of information have not been sufficiently cross-examined to understand how they might complement each other. In this paper, we present a systematic analysis of four aspects of the software repository of an open source project - source-code metrics, identifiers, return-on-investment estimates, and design differencing - to collect evidence about refactorings that may have happened during the project development. In the context of this case study, we comparatively examine how informative each piece of information is towards understanding the refactoring history of the project and how costly it is to obtain.","1092-8138","0-7695-2601-2","10.1109/ICPC.2006.18","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631102","","History;Data mining;Information analysis;Open source software;Information resources;Programming;Chaos;Pattern recognition;Algorithm design and analysis;Merging","configuration management;data mining;project management;public domain software;software cost estimation;software metrics;software prototyping;systems re-engineering","software repository;software project development process;information mining;software evolution;open source project;source-code metrics;program identifiers;return-on-investment estimates;software project refactoring history;software cost estimation","","9","","21","IEEE","26 Jun 2006","","","IEEE","IEEE Conferences"
"How Developers Copy","M. Balint; R. Marinescu; T. Girba","LOOSE Research Group, Politehnica University of Timişoara, Romania; Software Composition Group, University of Bern, Switzerland; LOOSE Research Group, Politehnica University of Timişoara, Romania","14th IEEE International Conference on Program Comprehension (ICPC'06)","26 Jun 2006","2006","","","56","68","Copy-paste programming is dangerous as it may lead to hidden dependencies between different parts of the system. Modifying clones is not always straight forward, because we might not know all the places that need modification. This is even more of a problem when several developers need to know about how to change the clones. In this paper, we correlate the code clones with the time of the modification and with the developer that performed the modification to detect patterns of how developers copy from one another. We develop visualization, named clone evolution view, to represent the evolution of the duplicated code. We show the relevance of our approach on several large case studies and we distill our experience in forms of interesting copy patterns","1092-8138","0-7695-2601-2","10.1109/ICPC.2006.25","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631105","","Cloning;Visualization;Reverse engineering;Computer languages;Shape;Information analysis;Quality assurance;Risk management;Pattern analysis;Displays","program diagnostics;program visualisation;reverse engineering;software maintenance;software prototyping","copy-paste programming;code clone modification;clone evolution view;program visualization;duplicated code evolution","","17","","23","IEEE","26 Jun 2006","","","IEEE","IEEE Conferences"
"Classifying Change Types for Qualifying Change Couplings","B. Fluri; H. C. Gall","S.e.a.l.-software evolution and architecture Laboratory, Department of Informatics, University of Zurich, Switzerland; S.e.a.l.-software evolution and architecture Laboratory, Department of Informatics, University of Zurich, Switzerland","14th IEEE International Conference on Program Comprehension (ICPC'06)","26 Jun 2006","2006","","","35","45","Current change history analysis approaches rely on information provided by versioning systems such as CVS. Therefore, changes are not related to particular source code entities such as classes or methods but rather to text lines added and/or removed. For analyzing whether some change coupling between source code entities is significant or only minor textual adjustments have been checked in, it is essential to reflect the changes to the source code entities. We have developed an approach for analyzing and classifying change types based on code revisions. We can differentiate between several types of changes on the method or class level and assess their significance in terms of the impact of the change types on other source code entities and whether a change may be functionality-modifying or functionality-preserving. We applied our change taxonomy to a case study and found out that in many cases large numbers of lines added and/or deleted are not accompanied by significant changes but small textual adaptations (such as indentation, etc.). Furthermore, our approach allows us to relate all change couplings to the significance of the identified change types. As a result, change couplings between code entities can be qualified and less relevant couplings can be filtered out","1092-8138","0-7695-2601-2","10.1109/ICPC.2006.16","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631103","","Taxonomy;History;Information analysis;Computer architecture;Informatics;Aging;Classification tree analysis;Pattern analysis;Programming profession","configuration management;software maintenance;software prototyping;systems re-engineering","change type classification;change couplings;change history analysis;versioning system;source code entity;code revision;functionality-modifying change;functionality-preserving change;change taxonomy","","91","","28","IEEE","26 Jun 2006","","","IEEE","IEEE Conferences"
"Heterogeneous ClustersWith OSCAR: Infrastructure and Administration","E. Focht","NEC High Performance Computing Europe, Stuttgart, Germany","20th International Symposium on High-Performance Computing in an Advanced Collaborative Environment (HPCS'06)","30 May 2006","2006","","","37","37","The paper explains recent changes in the OSCAR [1],[2] infrastructure which extend it to deal with heterogeneous clusters. It discusses design considerations for heterogeneous clusters, sketches the installation procedure and briefly describes administration issues with complex heterogeneous configurations.","1550-5243","0-7695-2582-2","10.1109/HPCS.2006.27","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1628228","","Packaging;Switches;Computer architecture;Resource management;Environmental management;Linux;Operating systems;Monitoring;National electric code;High performance computing","","","","","","6","IEEE","30 May 2006","","","IEEE","IEEE Conferences"
"Modularizing variability and scalability concerns in distributed real-time and embedded systems with modeling tools and component middleware","Gan Deng; D. C. Schmidt; A. Gokhale; A. Nechypurenko","EECS Dept, Vanderbilt University, Nashville, TN, USA; EECS Dept, Vanderbilt University, Nashville, TN, USA; EECS Dept, Vanderbilt University, Nashville, TN, USA; Corporate Technology, Siemens AG, Munich, Germany","Ninth IEEE International Symposium on Object and Component-Oriented Real-Time Distributed Computing (ISORC'06)","15 May 2006","2006","","","8 pp.","","Developing real-time software for large-scale distributed real-time and embedded (DRE) systems is hard due to variabilities that arise from (I) integration with various subsystems based on different programming languages and hardware, OS, middleware platforms, (2) fine tuning the system to satisfy a range of customer requirements, such as various quality-of-service (QoS) properties, and (3) changing functional and QoS properties of the system based on available system resources. This paper describes our experience applying model-driven development (MDD) tools and QoS-enabled component middleware technologies to address domain- and middleware-specific variability challenges in an inventory tracking system, which manages the storage and flow of items in warehouses. Our results show that (I) coherent integration of MDD tools and component middleware can provide a productive software process for developing DRE systems by modularizing and composing variability concerns and (2) significant challenges remain that must be overcome to apply these technologies to a broader range of DRE systems.","2375-5261","0-7695-2561-X","10.1109/ISORC.2006.57","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1630497","Model-Driven Development;Domain-;Specific Modeling Languages;Component Middleware","Scalability;Real time systems;Embedded system;Middleware;Embedded software;Software quality;Large scale integration;Computer languages;Hardware;Quality of service","middleware;object-oriented programming;embedded systems;formal specification;warehouse automation;inventory management","distributed real-time systems;embedded systems;component middleware;large-scale systems;requirement satisfaction;quality of service;model-driven development;domain-specific variability;middleware-specific variability;warehouse inventory tracking system;domain-specific modeling languages","","1","","21","IEEE","15 May 2006","","","IEEE","IEEE Conferences"
"Evaluating software refactoring tool support","E. Mealy; P. Strooper","School of Information Technology and Electrical Engineering, University of Queensland, QLD, Australia; School of Information Technology and Electrical Engineering, University of Queensland, QLD, Australia","Australian Software Engineering Conference (ASWEC'06)","8 May 2006","2006","","","10 pp.","340","Up to 75% of the costs associated with the development of software systems occur post-deployment during maintenance and evolution. Software refactoring is a process that can significantly reduce the costs associated with software evolution. Refactoring is defined as internal modification of source code to improve system quality, without change to observable behaviour. Tool support for software refactoring attempts to further reduce evolution costs by automating manual, error-prone and tedious tasks. Although the process of refactoring is well-defined, tools supporting refactoring do not support the full process. Existing tools suffer from issues associated with the level of automation, the stages of the refactoring process supported or automated, the subset of refactorings that can be applied, and complexity of the supported refactorings. This paper presents a framework for evaluating software refactoring tool support based on the DESMET method. For the DESMET application, a functional analysis of the requirements for supporting software refactoring is used in conjunction with a case study. This evaluation was completed to assess the support provided by six Java refactoring tools and to evaluate the efficacy of using the DESMET method for evaluating refactoring tools.","2377-5408","0-7695-2551-2","10.1109/ASWEC.2006.26","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1615066","","Software tools;Costs;Software systems;Application software;Software engineering;Australia;Automation;Java;Information technology;Functional analysis","software tools;software maintenance;software prototyping;software quality;formal specification;Java","software refactoring tool;software maintenance;software evolution;source code modification;system quality;DESMET method;Java refactoring tool","","19","","26","IEEE","8 May 2006","","","IEEE","IEEE Conferences"
"The value of architecturally significant information extracted from patterns for architecture evaluation: a controlled experiment","M. A. Babar; B. Kitchenham; Piyush Maheshwari","University of New South Wales, Australia; University of New South Wales, Australia; University of New South Wales, Australia","Australian Software Engineering Conference (ASWEC'06)","8 May 2006","2006","","","10 pp.","390","We have developed an approach to identify and capture architecturally significant information from patterns (ASIP), which can be used to improve architecture design and evaluation. Our experimental goal was to evaluate whether the use of the ASIP improves the quality of scenarios developed to evaluate software architecture. Out of 24 subjects 21 were experienced software engineers who had returned to University for a postgraduate studies and remaining 3 were fourth year undergraduate students. All participants were taking a course in software architecture. The participants were randomly assigned to two groups of equal size. Both groups developed scenarios for architecture evaluation. One group (treatment group) was given ASIP information the other (control group) was not. The outcome variable was the quality of the scenarios produced by each participant working individually. The treatment group participants also completed a post-experiment questionnaire. Our results support the hypothesis that ASIP information assists scenario development in the context of architecture evaluation.","2377-5408","0-7695-2551-2","10.1109/ASWEC.2006.52","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1615071","","Data mining;Computer architecture;Application specific processors;Software architecture;Software quality;Australia;Performance analysis;Programming;Concrete;Documentation","software architecture;software performance evaluation;software quality","software architecture evaluation;architecturally significant information from pattern;ASIP information;software architecture design","","1","","25","IEEE","8 May 2006","","","IEEE","IEEE Conferences"
"A Comparative Analysis of Maintainability Approaches for Web Applications","E. Ghosheh; J. Qaddour; M. Kuofie; S. Black","IBM-Global Services, Kansas City, MO, USA; School of Information Technology, Illinois State University, Normal, IL, USA; School of Information Technology, Illinois State University, Normal, IL, USA; School of Business, Computing and Information Management, London South Bank University, London, UK","IEEE International Conference on Computer Systems and Applications, 2006.","18 Apr 2006","2006","","","1155","1158","","2161-5330","1-4244-0211-5","10.1109/AICCSA.2006.205235","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1618500","","Application software;Costs;Software systems;Software maintenance;Measurement units;HTML;Object oriented modeling;Web and internet services;Information technology;Preventive maintenance","","","","9","","28","IEEE","18 Apr 2006","","","IEEE","IEEE Conferences"
"Experiences with multi-threading and dynamic class loading in a Java just-in-time compiler","V. Sundaresan; D. Maier; P. Ramarao; M. Stoodley","IBM Canada Limited, Markham, ONT, Canada; IBM Canada Limited, Markham, ONT, Canada; IBM Canada Limited, Markham, ONT, Canada; IBM Canada Limited, Markham, ONT, Canada","International Symposium on Code Generation and Optimization (CGO'06)","10 Apr 2006","2006","","","11 pp.","97","In this paper, we describe the techniques that have been implemented in the IBM TestaRossa (TR) just-in-time (JIT) compiler to safely perform aggressive code patching and collect accurate profiles in the context of a Java application employing multiple threads and dynamic class loading and unloading. Previous work in these areas either did not account for the synchronization cost of safety or dynamic class loading/unloading effects in a heavily multithreaded program or did not consider how different patching techniques may be required for different platforms where instruction cache coherence guarantees vary. We evaluate the space and time overhead to make our profiling framework correct, showing that privatizing the profiling variables to achieve correctness impacts execution time only minimally but it can grow the stack frames for profiled methods by less than 15% on average for the SPECjvm98 and SPECjbb2000 benchmarks. Since methods are profiled for only a brief time and the stack frames themselves are not large, we do not consider this growth to be prohibitive. The techniques reported in this paper are implemented in the 1.5.0 release of the IBM Developer Kit for Java targeting 12 different processor-operating system platforms.","","0-7695-2499-0","10.1109/CGO.2006.16","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1611532","","Java;Costs;Testing;Production;Yarn;Program processors;Performance evaluation;Safety;Computer languages;Software design","program compilers;Java;multi-threading;object-oriented programming","multithreading;dynamic class loading;Java just-in-time compiler;IBM TestaRossa just-in-time compiler;aggressive code patching;dynamic class unloading;IBM Developer Kit;processor-operating system platforms","","26","4","15","IEEE","10 Apr 2006","","","IEEE","IEEE Conferences"
"Reconstructing higher level change information from versioning data","F. Van Rysselberghe","Lab On Re-Engineering, University Of Antwerp, Belgium","Conference on Software Maintenance and Reengineering (CSMR'06)","10 Apr 2006","2006","","","3 pp.","333","Change is an essential element of the software development cycle, certainly since systems which do not change, perish. Despite the importance of changes, most evolution studies evaluate the impact of changes by comparing two or more snapshots of a system over time instead of reconstructing and evaluating the actual change operations. Therefore we propose a number of techniques which are capable of reconstructing change-operations from the low-level data stored in versioning systems in order to learn more about the current system as well as the change process. More specifically, we show how these techniques can be used to study the use of move-operations","1534-5351","0-7695-2536-9","10.1109/CSMR.2006.44","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1602390","","Visualization;Software systems;Programming;Data mining;Software maintenance;Application software","configuration management;software maintenance","higher level change information;versioning data;software development cycle;versioning systems","","","","4","IEEE","10 Apr 2006","","","IEEE","IEEE Conferences"
"Static evaluation of software architectures","J. Knodel; M. Lindvall; D. Muthig; M. Naab","Fraunhofer Institute of Experimental Software Engineering (IESE), Kaiserslautern, Germany; Fraunhofer USA슠-슠Center for Experimental Software Engineering, College Park, MD, USA; Fraunhofer Institute of Experimental Software Engineering (IESE), Kaiserslautern, Germany; Fraunhofer Institute of Experimental Software Engineering (IESE), Kaiserslautern, Germany","Conference on Software Maintenance and Reengineering (CSMR'06)","10 Apr 2006","2006","","","10 pp.","294","The software architecture is one of the most crucial artifacts within the lifecycle of a software system. Decisions made at the architectural level directly enable, facilitate, hamper, or interfere with the achievement of business goals, functional and quality requirements. Architecture evaluations play an important role in the development and evolution of software systems since they determine how adequate the architecture is for its intended usage. This paper summarizes our practical experience with using architecture evaluations and gives an overview on when and how static architecture evaluations contribute to architecture development. We identify ten distinct purposes and needs for static architecture evaluations and illustrate them using a set of industrial and academic case studies. In particular, we show how subsequent steps in architecture development are influenced by the results from architecture evaluations","1534-5351","0-7695-2536-9","10.1109/CSMR.2006.53","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1602379","ADORE;architecture;architecture evaluation;product line;PuLSE-DSSA;reverse engineering.","Computer architecture;Software engineering;Reverse engineering;Software architecture;Software systems;Educational institutions;Acoustical engineering;Instruments;Computer industry;Programming","reverse engineering;software architecture;software performance evaluation","software architecture static evaluation;software architecture development;reverse engineering","","45","","28","IEEE","10 Apr 2006","","","IEEE","IEEE Conferences"
"Case studies of visual language based design patterns recovery","G. Costagliola; A. De Lucia; V. Deufemia; C. Gravino; M. Risi","Dipartimento di Matematica e Informatica, Università di Salerno, Fisciano, SA, Italy; Dipartimento di Matematica e Informatica, Università di Salerno, Fisciano, SA, Italy; Dipartimento di Matematica e Informatica, Università di Salerno, Fisciano, SA, Italy; Dipartimento di Matematica e Informatica, Università di Salerno, Fisciano, SA, Italy; Dipartimento di Matematica e Informatica, Università di Salerno, Fisciano, SA, Italy","Conference on Software Maintenance and Reengineering (CSMR'06)","10 Apr 2006","2006","","","10 pp.","174","In this paper, we present case studies of recovering structural design patterns from object-oriented source code. The proposed recovery technique is based on the use of visual language parsing techniques, and is supported by a visual environment automatically produced by a grammar based visual environment generator. We have applied the recovery technique to public-domain programs and libraries obtaining encouraging results. In particular, for the considered software our recovery approach is characterized by higher recall and precision values with respect to other recovery techniques","1534-5351","0-7695-2536-9","10.1109/CSMR.2006.14","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1602368","","Computer aided software engineering;Software libraries;Design engineering;Knowledge engineering;Reverse engineering;Software systems;Data mining;Object oriented modeling;Unified modeling language;Software maintenance","automatic programming;formal languages;object-oriented programming;public domain software;software maintenance;visual languages","structural design patterns recovery;object-oriented source code;visual language parsing techniques;grammar based visual environment generator;public-domain program","","10","","37","IEEE","10 Apr 2006","","","IEEE","IEEE Conferences"
"Detecting move operations in versioning information","F. Van Rysselberghe; M. Rieger; S. Demeyer","Lab On Re-Engineering, University of Antwerp, Belgium; Lab On Re-Engineering, University of Antwerp, Belgium; Lab On Re-Engineering, University of Antwerp, Belgium","Conference on Software Maintenance and Reengineering (CSMR'06)","10 Apr 2006","2006","","","8 pp.","278","Recently, there is an increasing research interest in mining versioning information, i.e. the analysis of the transactions made on version systems to understand how and when a software system evolves. One particular area of interest is the identification of move operations as these are key indicators for refactorings. Unfortunately, there exists no evaluation which identifies the quality (expressed in precision and recall) of the most commonly used detection technique and its underlying principle of name identity. To overcome this problem, the paper compares the precision and recall values of the name-based technique with two alternative techniques, one based on line matching and one based on identifier matching, by means of two case studies. From the results of these studies we conclude that the name-based technique is very precise, yet misses a significant number of move operations (low recall value). To improve the trade-off it is worthwhile to consider the line-based technique since it detects more matches with a slightly worse precision, or to use the number of overlapping identifiers when combined with an additional filter","1534-5351","0-7695-2536-9","10.1109/CSMR.2006.23","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1602378","","Software systems;Degradation;Information analysis;Matched filters;History;Software maintenance","configuration management;software maintenance;software quality","version system;software system;name-based technique;line matching;identifier matching;software refactoring","","4","","25","IEEE","10 Apr 2006","","","IEEE","IEEE Conferences"
"CP-Miner: finding copy-paste and related bugs in large-scale software code","Z. Li; S. Lu; S. Myagmar; Y. Zhou","Department of Computer Science, University of Illinois, Urbana-Champaign, IL, USA; Department of Computer Science, University of Illinois, Urbana-Champaign, IL, USA; Department of Computer Science, University of Illinois, Urbana-Champaign, IL, USA; Department of Computer Science, University of Illinois, Urbana-Champaign, IL, USA","IEEE Transactions on Software Engineering","27 Mar 2006","2006","32","3","176","192","Recent studies have shown that large software suites contain significant amounts of replicated code. It is assumed that some of this replication is due to copy-and-paste activity and that a significant proportion of bugs in operating systems are due to copy-paste errors. Existing static code analyzers are either not scalable to large software suites or do not perform robustly where replicated code is modified with insertions and deletions. Furthermore, the existing tools do not detect copy-paste related bugs. In this paper, we propose a tool, CP-Miner, that uses data mining techniques to efficiently identify copy-pasted code in large software suites and detects copy-paste bugs. Specifically, it takes less than 20 minutes for CP-Miner to identify 190,000 copy-pasted segments in Linux and 150,000 in FreeBSD. Moreover, CP-Miner has detected many new bugs in popular operating systems, 49 in Linux and 31 in FreeBSD, most of which have since been confirmed by the corresponding developers and have been rectified in the following releases. In addition, we have found some interesting characteristics of copy-paste in operating system code. Specifically, we analyze the distribution of copy-pasted code by size (number lines of code), granularity (basic blocks and functions), and modification within copy-pasted code. We also analyze copy-paste across different modules and various software versions.","1939-3520","","10.1109/TSE.2006.28","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1610609","Software analysis;code reuse;code duplication;debugging aids;data mining.","Computer bugs;Large-scale systems;Linux;Operating systems;Data mining;Cloning;Programming profession;Kernel;Performance analysis;Software performance","program debugging;program diagnostics;operating systems (computers);data mining;software tools;software reusability;software maintenance","CP-Miner tool;debugging aids;large-scale software code;replicated code;copy-paste bugs;operating system code bugs;static code analyzer;data mining technique;Linux;FreeBSD;code reuse;code duplication","","351","3","39","IEEE","27 Mar 2006","","","IEEE","IEEE Journals"
"A Tutorial on Design Patterns for Music Notation Software","S. Brandorff; M. Lindholm; H. B. Christensen","Institute of Information and Media Studies, Aarhus University, Helsingforsgade 14, DK-8200 Aarhus N, Denmark, sbrand@daimi.au.dk; Department of Computer Science, Aarhus University, Aabogade 34, DK-8200 Aarhus N, Denmark; Department of Computer Science, Aarhus University, Aabogade 34, DK-8200 Aarhus N, Denmark","Computer Music Journal","19 May 2014","2005","29","3","42","54","","0148-9267","","10.1162/0148926054798179","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6788577","","","","","","","","","","19 May 2014","","","MIT Press","MIT Press Journals"
"Teaching an Advanced Design, Team-Oriented Software Project Course","S. Jarzabek; P. -K. Eng","Department of Computer Science, School of Computing, National University of Singapore, Singapore; Department of Computer Science, School of Computing, National University of Singapore, Singapore","18th Conference on Software Engineering Education & Training (CSEET'05)","8 Dec 2008","2005","","","223","230","Students learn about design principles and ""best practices"" in many courses. However, small scale assignments do not give enough opportunity for students to appreciate the value of software design principles or even to learn how to apply principles in practice. To fill the gap between theoretical and experiential knowledge, we introduced a team-based project course focused on design and implementation phases of the software development lifecycle. We teach design principles and team work in problem-based way, through architectural concepts and iterative development process. The product students build must meet stated quality requirements in terms of reliability, reusability and documentation. We trust this kind of the course is essential in curricula as it allows students better absorb knowledge learned in other software engineering courses. Such course also plays a role in better preparing students for industrial work. We describe a teaching method, course infrastructure and lessons learned over three years of teaching of our course. Based on experiences, we postulate and motivate the need for teaching at least two project courses in undergraduate curricula, one dealing with design and process issues, and the other focused on unstable requirements","2377-570X","0-7695-2324-2","10.1109/CSEET.2005.34","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4698927","","Education;Software design;Best practices;Software engineering;Programming;Process design;Communication industry;Computer science;Documentation;Computer industry","computer science education;educational courses;software architecture;software management;software quality;software reliability;software reusability;student experiments;system documentation;team working","software design;team-oriented software project course;students learning;educational courses;student assignments;software development lifecycle;team work;architectural concepts;iterative development process;quality requirements;software reliability;software reusability;software documentation;software engineering courses;teaching method;course infrastructure;undergraduate curricula","","11","","15","IEEE","8 Dec 2008","","","IEEE","IEEE Conferences"
