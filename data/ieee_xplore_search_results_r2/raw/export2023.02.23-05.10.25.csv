"Document Title",Authors,"Author Affiliations","Publication Title",Date Added To Xplore,"Publication Year","Volume","Issue","Start Page","End Page","Abstract","ISSN",ISBNs,"DOI",Funding Information,PDF Link,"Author Keywords","IEEE Terms","INSPEC Controlled Terms","INSPEC Non-Controlled Terms","Mesh_Terms",Article Citation Count,Patent Citation Count,"Reference Count","License",Online Date,Issue Date,"Meeting Date","Publisher",Document Identifier
"Privacy-preserving clone detection for RFID-enabled supply chains","D. Zanetti; L. Fellmann; S. Capkun; S. čapkun","Dept. of Computer Science, ETHZ, Zurich, Zurich, Switzerland; Dept. of Computer Science, ETHZ, Zurich, Zurich, Switzerland; Dept. of Computer Science, ETHZ, Zurich, Zurich, Switzerland; Dept. of Computer Science, ETHZ, Zurich, Switzerland","2010 IEEE International Conference on RFID (IEEE RFID 2010)","20 May 2010","2010","","","37","44","Counterfeit products cause financial losses and represent a health risk. Within RFID-enabled supply chains, where products are equipped with RFID tags, clone detection mechanisms based on tag traces can help in detecting counterfeits. These mechanisms assume that supply chain partners share (private) information to run trace analysis, and may suffer from supply chain dynamics, tag misreads, product recalls, and misdeliveries. In this work, we present a novel, effective, privacy-preserving clone detection mechanism for RFID-enabled supply chains. Our mechanism does not rely on global knowledge of supply chain structures or products flow, it is robust to recalls and misdeliveries, and considers tag misreads while evaluating the presence of counterfeits. We propose privacy-preserving implementations of our mechanism that show better performance when compared to similar implementations based on existing secure multi-party computation frameworks.","2374-0221","978-1-4244-5743-4","10.1109/RFID.2010.5467257","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5467257","","Cloning;Supply chains;Radiofrequency identification;Counterfeiting;Cryptography;Sliding mode control;RFID tags;Robustness;Law;Legal factors","data privacy;radiofrequency identification;security of data;supply chain management","privacy-preserving clone detection;RFID-enabled supply chains;counterfeit products;financial loss;health risk;RFID tags;tag trace;counterfeit detection;private information;supply chain dynamics;tag misread;product recall;supply chain structure;product flow;secure multiparty computation framework","","27","4","37","IEEE","20 May 2010","","","IEEE","IEEE Conferences"
"Finding file clones in FreeBSD Ports Collection","Y. Sasaki; T. Yamamoto; Y. Hayase; K. Inoue","Graduate School of Information Science and Technology, Osaka University, Suita, Osaka, Japan; College of Information Science and Engineering, Ritsumeikan University, Kusatsu, Shiga, Japan; Graduate School of Information Science and Technology, Osaka University, Suita, Osaka, Japan; Graduate School of Information Science and Technology, Osaka University, Suita, Osaka, Japan","2010 7th IEEE Working Conference on Mining Software Repositories (MSR 2010)","13 May 2010","2010","","","102","105","In Open Source System (OSS) development, software components are often imported and reused; for this reason we might expect that files are copied in multiple projects (file clones). In this paper, we propose a file clone detection tool called FCFinder and show the analysis performed with it on the FreeBSD Ports Collection, a large OSS project collection. We found many file clones among similar or related projects, which are systematically introduced from base projects.","2160-1860","978-1-4244-6803-4","10.1109/MSR.2010.5463293","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5463293","File clone;hashing;power law;open source system","Cloning;Information science;Performance analysis;Educational institutions;Open source software;Software systems;Plagiarism;Laboratories;Large-scale systems;Visualization","file organisation;public domain software","FreeBSD ports collection;open source system;software component;file clone detection tool;FCFinder;OSS project collection","","19","","10","IEEE","13 May 2010","","","IEEE","IEEE Conferences"
"Clones: What is that smell?","F. Rahman; C. Bird; P. Devanbu","Department of Computer Science, University of California,슠Davis, Davis, CA, USA; Department of Computer Science, University of California Davis, Davis, CA, USA; Department of Computer Science, University of California,슠Davis, Davis, CA, USA","2010 7th IEEE Working Conference on Mining Software Repositories (MSR 2010)","13 May 2010","2010","","","72","81","Clones are generally considered bad programming practice in software engineering folklore. They are identified as a bad smell and a major contributor to project maintenance difficulties. Clones inherently cause code bloat, thus increasing project size and maintenance costs. In this work, we try to validate the conventional wisdom empirically to see whether cloning makes code more defect prone. This paper analyses relationship between cloning and defect proneness. We find that, first, the great majority of bugs are not significantly associated with clones. Second, we find that clones may be less defect prone than non-cloned code. Finally, we find little evidence that clones with more copies are actually more error prone. Our findings do not support the claim that clones are really a ¿bad smell¿. Perhaps we can clone, and breathe easy, at the same time.","2160-1860","978-1-4244-6803-4","10.1109/MSR.2010.5463343","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5463343","software clone;empirical software engineering;software maintenance;software evolution","Cloning;Costs;Computer bugs;Software maintenance;Software engineering;Productivity;Birds;Computer science;Programming;Taxonomy","program debugging;software maintenance","clones;software engineering;project maintenance;code bloat;defect proneness;bugs","","52","","32","IEEE","13 May 2010","","","IEEE","IEEE Conferences"
"Identifying licensing of jar archives using a code-search approach","M. Di Penta; D. M. German; G. Antoniol","Department of Engineering, University of Sannio, Italy; Department of Computer Science, University of Victoria, Canada; SOCCER Laboratory-DGIGL, École Polytechnique de Montréal, QUE, Canada","2010 7th IEEE Working Conference on Mining Software Repositories (MSR 2010)","13 May 2010","2010","","","151","160","Free and open source software strongly promotes the reuse of source code. Some open source Java components/libraries are distributed as jar archives only containing the bytecode and some additional information. For whoever wanting to integrate this jar in her own project, it is important to determine the license(s) of the code from which the jar archive was produced, as this affects the way that such component can be used. This paper proposes an automatic approach to determine the license of jar archives, combining the use of a code-search engine with the automatic classification of licenses contained in textual flies enclosed in the jar. Results of an empirical study performed on 37 jars - from 17 different systems - indicate that this approach is able to successfully infer the jar licenses in over 95% of the cases, but that in many cases the license in textual flies may differ from the one of the classes contained in the jar.","2160-1860","978-1-4244-6803-4","10.1109/MSR.2010.5463282","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5463282","","Licenses;Java;Open source software;Computer science;Software libraries;Engines;Decoding;Uniform resource locators;Documentation;Web search","Java;public domain software;search engines;text analysis","open source software;free software;code-search approach;open source Java components;open source Java libraries;jar archive license identification;code-search engine;textual flies","","17","","19","IEEE","13 May 2010","","","IEEE","IEEE Conferences"
"Cloning and copying between GNOME projects","J. Krinke; N. Gold; Y. Jia; D. Binkley","Centre for Research on Evolution, Search and Testing (CREST), King''s College, UK; Centre for Research on Evolution, Search and Testing (CREST), King''s College, UK; Centre for Research on Evolution, Search and Testing (CREST), King''s College, UK; Loyola University Maryland, Baltimore, MD, USA","2010 7th IEEE Working Conference on Mining Software Repositories (MSR 2010)","13 May 2010","2010","","","98","101","This paper presents an approach to automatically distinguish the copied clone from the original in a pair of clones. It matches the line-by-line version information of a clone to the pair's other clone. A case study on the GNOME Desktop Suite revealed a complex flow of reused code between the different subprojects. In particular, it showed that the majority of larger clones (with a minimal size of 28 lines or higher) exist between the subprojects and more than 60% of the clone pairs can be automatically separated into original and copy.","2160-1860","978-1-4244-6803-4","10.1109/MSR.2010.5463290","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5463290","","Cloning;Control systems;Programming;Information retrieval;Gold;Educational institutions;Automatic testing;Software maintenance;Data mining","biocomputing;software engineering","GNOME projects cloning;GNOME projects copying;copied clone;line-by-line version information","","23","","21","IEEE","13 May 2010","","","IEEE","IEEE Conferences"
"Detection of Type-1 and Type-2 Code Clones Using Textual Analysis and Metrics","E. Kodhai; S. Kanmani; A. Kamatchi; R. Radhika; B. V. Saranya","Department of IT, SMVEC, Puducherry, India; Department of IT, SMVEC, Puducherry, India; Department of IT, SMVEC, Puducherry, India; Department of IT, SMVEC, Puducherry, India; Department of IT, SMVEC, Puducherry, India","2010 International Conference on Recent Trends in Information, Telecommunication and Computing","6 May 2010","2010","","","241","243","Clone Detection has considerably evolved over the last decade, leading to approaches with better results but with increasing complexity. Most of the existing approaches are limited to finding program fragments similar in their syntax or semantics, while the fraction of candidates that are actually clones and fraction of actual clones identified as candidates on the average remain similar. In this paper, a metric-based approach combined with the textual comparison of the source code for the detection of functional Clones in C source code has been proposed. Various metrics had been formulated and their values were utilized during the detection process. Compared to the other approaches, this method is considered to be the least complex and is to provide a more accurate and efficient way of Clone Detection. The results obtained had been compared with the two other existing tools for the open source project Weltab.","","978-1-4244-5957-5","10.1109/ITC.2010.55","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5460547","Clone Detection;Functional Clones;Software Metrics;Text-based Comparison;String-matching","Cloning;Software systems;Java;Telecommunication computing;Information analysis;Software metrics;Software maintenance;Programming profession;Application software;Plagiarism","software maintenance;software metrics","Type-1code clone;Type-2 code clone;textual analysis;textual metrics;C source code;functional clone","","21","","11","IEEE","6 May 2010","","","IEEE","IEEE Conferences"
"An ontological identification of relationships between anti-patterns and code smells","Yixin Luo; A. Hoss; D. L. Carver","Software Engineering Laboratory, Louisiana State University, USA; Software Engineering Laboratory, Louisiana State University, USA; Software Engineering Laboratory, Louisiana State University, USA","2010 IEEE Aerospace Conference","15 Apr 2010","2010","","","1","10","Ensuring quality in software development is a challenging process. The concepts of anti-patterns and code smells utilize the knowledge of known problems to improve the quality of current and future software development. However, the knowledge and understanding of these indicators of low quality software is still insufficient to resolve many of the problems they represent. The identification and definition of anti-patterns is a heuristic process. Additionally, minimal research exists addressing the relationships between or among code smells and anti-patterns. Software quality issues such as understandability and maintainability can be improved by identifying and resolving anti-patterns associated with code smells as well as preventing code smells before coding begins. We present an ontological representation of the relationships between anti-patterns and code smells to enhance the understanding of these concepts with the goal of improving software quality.","1095-323X","978-1-4244-3887-7","10.1109/AERO.2010.5446811","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5446811","","Ontologies;Software quality;Software design;Software maintenance;Application software;Programming;Software systems;Software measurement;Software engineering;Software testing","object-oriented methods;ontologies (artificial intelligence);software quality","ontological relationships identification;anti patterns;code smells;software development;software quality","","","","24","IEEE","15 Apr 2010","","","IEEE","IEEE Conferences"
"Interactive, Evolutionary Search in Upstream Object-Oriented Class Design","C. L. Simons; I. C. Parmee; R. Gwynllyw","Department of Computer Science, University of West of England, Bristol, UK; Department of Computer Science, University of West of England, Bristol, UK; Department of Mathematics and Statistics, University of West of England, Bristol, UK","IEEE Transactions on Software Engineering","29 Nov 2010","2010","36","6","798","816","Although much evidence exists to suggest that early life cycle software engineering design is a difficult task for software engineers to perform, current computational tool support for software engineers is limited. To address this limitation, interactive search-based approaches using evolutionary computation and software agents are investigated in experimental upstream design episodes for two example design domains. Results show that interactive evolutionary search, supported by software agents, appears highly promising. As an open system, search is steered jointly by designer preferences and software agents. Directly traceable to the design problem domain, a mass of useful and interesting class designs is arrived at which may be visualized by the designer with quantitative measures of structural integrity, such as design coupling and class cohesion. The class designs are found to be of equivalent or better coupling and cohesion when compared to a manual class design for the example design domains, and by exploiting concurrent execution, the runtime performance of the software agents is highly favorable.","1939-3520","","10.1109/TSE.2010.34","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5432223","Software design;evolutionary computation;interactive search.","Software agents;Software design;Software performance;Software tools;Design engineering;Software engineering;Evolutionary computation;Open systems;Visualization;Runtime","evolutionary computation;interactive systems;object-oriented methods;open systems;search problems;software agents;software engineering","upstream object oriented class design;life cycle software engineering design;software agent;interactive evolutionary search;open system;design problem domain;structural integrity;concurrent execution;runtime performance","","58","2","66","IEEE","18 Mar 2010","","","IEEE","IEEE Journals"
"Software Entropy in Agile Product Evolution","G. Hanssen; A. F. Yamashita; R. Conradi; L. Moonen","NTNU IDI/SINTEF ICT, Norway; Simula Research Laboratory, Norway; NTNU IDI; Simula Research Laboratory","2010 43rd Hawaii International Conference on System Sciences","11 Mar 2010","2010","","","1","10","As agile software development principles and methods are being adopted by large software product organizations it is important to understand the role of software entropy. That is, how the maintainability of a system may degrade over time due to continuous change. This may on one side affect the ability to act agile in planning and development. On the other side, an agile process may affect growth of entropy. We report from a case study of a successful software product line organization that has adopted the agile development method Evo, showing how agility and entropy are negatively related. We conclude this study by suggesting a two-step approach to manage entropy while maintaining process agility. First, the system needs to be restructured to establish a level of manageable entropy, and then, that the agile process must be complemented with continuous semi-automated quality monitoring and refactoring support.","1530-1605","978-1-4244-5510-2","10.1109/HICSS.2010.344","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5428534","","Entropy;Programming;Product development;Laboratories;Research and development;Decision making;Degradation;Quality management;Monitoring;Software packages","DP industry;entropy;software development management;software maintenance;software prototyping;software quality","agile product evolution;software entropy;large software product organizations;system maintainability;software product line organization;agile development method;Evo;continuous semiautomated quality monitoring;continuous refactoring support;agile software development","","6","","55","IEEE","11 Mar 2010","","","IEEE","IEEE Conferences"
"DECOR: A Method for the Specification and Detection of Code and Design Smells","N. Moha; Y. -G. Gueheneuc; L. Duchien; A. -F. Le Meur","INRIA Rennes Bretagne Atlantique Campus de Beaulieu, Triskell Team, IRISA Université Rennes 1, Rennes, France; Département de Génie Informatique et Génie Logiciel, École Polytechnique de Montréal, Montreal, QUE, Canada; Parc Scientifique de la Haute Borne, INRIA Lille Nord Europe, Villeneuve d'Ascq, France; Parc Scientifique de la Haute Borne, INRIA Lille Nord Europe, Villeneuve d'Ascq, France","IEEE Transactions on Software Engineering","29 Jan 2010","2010","36","1","20","36","Code and design smells are poor solutions to recurring implementation and design problems. They may hinder the evolution of a system by making it hard for software engineers to carry out changes. We propose three contributions to the research field related to code and design smells: (1) DECOR, a method that embodies and defines all the steps necessary for the specification and detection of code and design smells, (2) DETEX, a detection technique that instantiates this method, and (3) an empirical validation in terms of precision and recall of DETEX. The originality of DETEX stems from the ability for software engineers to specify smells at a high level of abstraction using a consistent vocabulary and domain-specific language for automatically generating detection algorithms. Using DETEX, we specify four well-known design smells: the antipatterns Blob, Functional Decomposition, Spaghetti Code, and Swiss Army Knife, and their 15 underlying code smells, and we automatically generate their detection algorithms. We apply and validate the detection algorithms in terms of precision and recall on XERCES v2.7.0, and discuss the precision of these algorithms on 11 open-source systems.","1939-3520","","10.1109/TSE.2009.50","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5196681","Antipatterns;design smells;code smells;specification;metamodeling;detection;Java.","Detection algorithms;Vocabulary;Domain specific languages;Algorithm design and analysis;Metamodeling;Java;Design engineering;Object oriented programming;Phase detection;Costs","formal specification;program verification;software quality","code specification;code detection;design smells;DECOR;DETEX;antipatterns Blob;functional decomposition;Spaghetti code;Swiss army knife;empirical validation;domain-specific language;open-source systems","","506","","66","IEEE","7 Aug 2009","","","IEEE","IEEE Journals"
"Test automation: Flexible way","A. Ieshin; M. Gerenko; V. Dmitriev",NA; NA; NA,"2009 5th Central and Eastern European Software Engineering Conference in Russia (CEE-SECR)","1 Jul 2010","2009","","","249","252","F-Secure is a global leader in providing security as a service through ISP's and mobile operators [1]. The company first used Agile more than 5 years ago and is still in the transition and building the true Agile culture. Test automation (TA) is one of Agile practices that the company has been focusing on and improving lately [2]. This paper describes how TA has been implemented in the company, benefits and drawbacks of different approaches, and key learnings. Our findings may be of interest and help for other Agile teams using or building a automation test system.","","978-1-4244-5665-9","10.1109/CEE-SECR.2009.5501151","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5501151","F-Secure;Agile;test automation;test automation framework","Automatic testing;Software testing;System testing;Instruments;Automatic control;Security;Software quality;Programming;Design automation;Product development","automatic test software;program testing;software prototyping","F-Secure;security as a service;ISP;mobile operators;automation test system;agile practices","","2","","6","IEEE","1 Jul 2010","","","IEEE","IEEE Conferences"
"Simulation and Analysis of Coarse Acquisition Code Generation Algorithm in GPS System","W. Zhang; H. Suh; K. Zhang","Dept. of Electron. Commun. Eng., Chonnam Nat. Univ., Yeosu, South Korea; Dept. of Electron. Commun. Eng., Chonnam Nat. Univ., Yeosu, South Korea; Coll. of Inf. Eng., Beijing Inst. of Petrochem. Technol., Beijing, China","2009 First International Conference on Information Science and Engineering","26 Apr 2010","2009","","","2726","2729","In this paper, the coarse acquisition code (C/A code), which is for civil navigation, of the ranging codes for Global Positioning System (GPS) is studied, simulated and analyzed by the Use of Matlab. With the simulation results we can confirm the correctness of the method and feasibility, which is at simulation platform to further study on the real environment of GPS signal, so That it can capture the complexity of tracking the satellite signal environment, and improve the performance of satellite receiver.","2160-1291","978-1-4244-5728-1","10.1109/ICISE.2009.1063","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5454483","","Analytical models;Algorithm design and analysis;Global Positioning System;Satellites;Ionosphere;Frequency estimation;Clocks;Delay effects;Information analysis;Frequency modulation","Global Positioning System;mathematics computing;satellite tracking","coarse acquisition code;Global Positioning System;GPS;Matlab simulation;satellite receiver;tracking","","","","5","IEEE","26 Apr 2010","","","IEEE","IEEE Conferences"
"Clone-Aware Configuration Management","T. T. Nguyen; H. A. Nguyen; N. H. Pham; J. M. Al-Kofahi; T. N. Nguyen","Electrical and Computer Engineering Department, Iowa State University, USA; Electrical and Computer Engineering Department, Iowa State University, USA; Electrical and Computer Engineering Department, Iowa State University, USA; Electrical and Computer Engineering Department, Iowa State University, USA; Electrical and Computer Engineering Department, Iowa State University, USA","2009 IEEE/ACM International Conference on Automated Software Engineering","18 Mar 2010","2009","","","123","134","Recent research results show several benefits of the management of code clones. In this paper, we introduce Clever, a novel clone-aware software configuration management (SCM) system. In addition to traditional SCM functionality, Clever provides clone management support, including clone detection and update, clone change management, clone consistency validating, clone synchronizing, and clone merging. Clever represents source code and clones as (sub)trees in Abstract Syntax Trees (ASTs), measures code similarity based on structural characteristic vectors, and describes code changes as tree editing scripts. The key techniques of Clever include the algorithms to compute tree editing scripts; to detect and update code clones and their groups; and to analyze the changes of cloned code to validate their consistency and recommend the relevant synchronization. Our empirical study on many real-world programs shows that Clever is highly efficient and accurate in clone detection and updating, and provides useful analysis of clone changes.","1938-4300","978-1-4244-5259-0","10.1109/ASE.2009.90","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5431776","clone-aware;clone management;tree edit;clone synchronization;clone editing consistency","Cloning;Collaborative software;Conference management;Engineering management;Merging;Software systems;Software engineering;Change detection algorithms;Algorithm design and analysis;Collaboration","configuration management;software management","clone-aware software configuration management;code clones;SCM system;clone management support;clone detection;clone change management;clone consistency validating;clone synchronizing;clone merging;abstract syntax trees;AST;tree editing scripts;real-world programs;Clever","","34","1","39","IEEE","18 Mar 2010","","","IEEE","IEEE Conferences"
"Improving API Usage through Automatic Detection of Redundant Code","D. Kawrykow; M. P. Robillard","School of Computer Science, McGill University, Montreal, QUE, Canada; School of Computer Science, McGill University, Montreal, QUE, Canada","2009 IEEE/ACM International Conference on Automated Software Engineering","18 Mar 2010","2009","","","111","122","Software projects often rely on third-party libraries made accessible through Application Programming Interfaces (APIs). We have observed many cases where APIs are used in ways that are not the most effective. We developed a technique and tool support to automatically detect such patterns of API usage in software projects. The main hypothesis underlying our technique is that client code imitating the behavior of an API method without calling it may not be using the API effectively because it could instead call the method it imitates. Our technique involves analyzing software systems to detect cases of API method imitations. In addition to warning developers of potentially re-implemented API methods, we also indicate how to improve the use of the API. Applying our approach on 10 Java systems revealed over 400 actual cases of potentially suboptimal API usage, leading to many improvements to the quality of the code we studied.","1938-4300","978-1-4244-5259-0","10.1109/ASE.2009.62","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5431779","API usage;code quality;code analysis;recommendation system","Software libraries;Java;Application software;Software systems;Software engineering;Computer science;Automatic programming;Software tools;Functional programming;Degradation","Java;software tools;user interfaces","API usage;automatic detection;redundant code;software projects;Java systems","","26","2","21","IEEE","18 Mar 2010","","","IEEE","IEEE Conferences"
"Explicit Concern-Driven Development with ArchEvol","E. C. Nistor; A. van der Hoek","Eugen is now with Google Inc., Irvine, CA, USA; Dept. of Inf., Univ. of California, Irvine, Irvine, CA, USA","2009 IEEE/ACM International Conference on Automated Software Engineering","18 Mar 2010","2009","","","185","196","Supporting developers in examining and evolving a software system in terms of concerns is considered a critical capability in the face of the scale and complexity of today's software. A number of existing approaches make an inroad to providing this support, but they fall short in key ways. This paper introduces ArchEvol, a new programming environment that embodies a new kind of approach, one we term explicit concern-driven development. The vision is threefold: (1) a fine-grained concern model maps concerns to code, (2) concerns are visualized at both the code level, to assist in the actual act of making changes, and the architectural level, to assist in gauging levels of scattering and tangling, and (3) automated support assists developers in maintaining the concern mapping over time. Developers, then, continuously examine, structure, and modify the software they produce in terms of concerns. We introduce our approach, discuss how we have realized it in ArchEvol, and present the results of a first set of evaluations that demonstrate its potential.","1938-4300","978-1-4244-5259-0","10.1109/ASE.2009.70","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5431773","software concerns;development environments;software evolution","Software systems;Scattering;Software engineering;Informatics;USA Councils;Face detection;Programming environments;Visualization;Weaving","software engineering","ArchEvol;concern-driven development;programming environment;fine-grained concern model;gauging levels;automated support","","2","","34","IEEE","18 Mar 2010","","","IEEE","IEEE Conferences"
"Classification and detection of metamorphic malware using value set analysis","F. Leder; B. Steinbock; P. Martini","Institute of Computer Science IV, University of Bonn, Bonn, Germany; Institute of Computer Science IV, University of Bonn, Bonn, Germany; Institute of Computer Science IV, University of Bonn, Bonn, Germany","2009 4th International Conference on Malicious and Unwanted Software (MALWARE)","2 Feb 2010","2009","","","39","46","Metamorphic malware changes the structure of its code from infection to infection. This makes it very hard to classify or to detect. While the byte-sequence of two variants may be completely different, the core functionality of the malware has to stay the same. This includes the use of flags and constants that have to be consistent at specific points. We present a novel approach that allows us to detect metamorphic variants. Based on this detection, it is also possible to classify new samples to a metamorphic family. Our approach identifies variants by tracking the use of consistent values throughout the malware. Our evaluation shows a 100% detection rate with 0 false positives for all metamorphic samples that do not change their behavior.","","978-1-4244-5787-8","10.1109/MALWARE.2009.5403019","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5403019","","Computer science;Counting circuits;Libraries;Protocols;Sockets;Statistics;Cryptography","invasive software;pattern classification","metamorphic malware classification;value set analysis;byte sequence;metamorphic variant detection","","33","","22","IEEE","2 Feb 2010","","","IEEE","IEEE Conferences"
"A quantitative approach for evaluating the effectiveness of refactoring in software development process","K. Usha; N. Poonguzhali; E. Kavitha","MIT, Puducherry, India; MIT, Puducherry, India; V. R. S College of Engineering, Tamil Nadu, India","2009 Proceeding of International Conference on Methods and Models in Computer Science (ICM2CS)","22 Jan 2010","2009","","","1","7","Software development is a mentally complicated task. Different software development methodologies and quality assurance methods are used in order to attain high quality, reliable, and bug free software. Extreme programming (XP) is a software development discipline in the family of agile methodologies that contributes towards quality improvement using dozen practices. One of the important practices in XP is refactoring. Refactoring which can be defined as ¿a change made to the internal structure of software to make it easier to understand and cheaper to modify without changing its observable behavior¿. Although there has been a large amount of research investigations for this concept, but there has been little work done in quantitative approach. The main objective of the research is to develop a software development model using refactoring practices. The software development model proposed in such a way that refactoring activity accompanies all the phases of software development. This work also shows the evaluation of effectiveness of the proposed software development model.","","978-1-4244-5051-0","10.1109/ICM2CS.2009.5397935","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5397935","refactoring;software development;eXtreme programming (XP)","Programming;Software maintenance;Software quality;Object oriented modeling;Software reusability;Software systems;Q factor;System analysis and design;System testing;Computer science","software maintenance;software performance evaluation;software prototyping;software quality;software reliability","quantitative approach;software development process;software refactoring;quality assurance methods;software reliability;software quality;extreme programming","","3","","18","IEEE","22 Jan 2010","","","IEEE","IEEE Conferences"
"Detecting Software Theft via System Call Based Birthmarks","X. Wang; Y. -C. Jhi; S. Zhu; P. Liu","Department of Computer Science and Engineering, Pennsylvania State University, PA, USA; Department of Computer Science and Engineering, Pennsylvania State University, PA, USA; Department of Computer Science and Engineering, Pennsylvania State University, PA, USA; College of Information Sciences and Technology, Pennsylvania State University, PA, USA","2009 Annual Computer Security Applications Conference","15 Jan 2010","2009","","","149","158","Along with the burst of open source projects, software theft (or plagiarism) has become a very serious threat to the healthiness of software industry. Software birthmark, which represents the unique characteristic of a program, can be used for software theft detection. We propose two system call based software birthmarks: SCSSB (system call short sequence birthmark) and IDSCSB (input dependant system call subsequence birthmark), and examine how well they reflect unique behavioral characteristics of a program. To our knowledge, our detection system based on SCSSB and IDSCSB is the first one that is capable of software component theft detection where only partial code is stolen. We demonstrate the strength of our birthmarks against various evasion techniques, including those based on different compilers and different compiler optimization levels as well as those based on very powerful obfuscation techniques supported by SandMark. Unlike the existing work that were evaluated through small or toy software, we also evaluate our birthmarks on a set of large software (Web browsers). Our results show that system call based birthmarks are very practical and effective in detecting software theft that even adopts advanced evasion techniques.","1063-9527","978-0-7695-3919-5","10.1109/ACSAC.2009.24","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5380505","detection;plagiarism;birthmark","Software systems;Open source software;Protection;Watermarking;Large-scale systems;Plagiarism;Computer industry;Resource description framework;Computer security;Application software","computer crime;DP industry;object-oriented programming;optimising compilers;public domain software","system call based birthmarks;open source projects;software plagiarism;software industry;software birthmark;system call short sequence birthmark;input dependant system call subsequence birthmark;behavioral characteristics;software component theft detection;evasion technique;compiler optimization;obfuscation technique;SandMark;Web browsers","","61","","26","IEEE","15 Jan 2010","","","IEEE","IEEE Conferences"
"Quick Similarity Measurement of Source Code Based on Suffix Array","J. -l. Huang; F. -p. Li","Coll. of Comput. & Software Sci., Shenzhen Univ., Shenzhen, China; Coll. of Math. & Comput. Sci., Shenzhen Univ., Shenzhen, China","2009 International Conference on Computational Intelligence and Security","12 Jan 2010","2009","2","","308","311","The automatic similarity measurement of source code can be applied to the detection of both plagiarism and code clone effectively. Suffix array is an effective way to construct the index of the full text, which has showed big applied potential in research areas such as genome analysis and character search currently. This paper introduces the relevant technologies of the similarity measurement of source code, especially the match algorithms for similar source code firstly, and then proposes a quick match algorithm that is applicable for quick similarity measurement of source code based on suffix array. Theory and experiments show that this new match algorithm for similar source code has the same similarity measurement result with current match algorithms, but it has obviously lower running time complexity.","","978-1-4244-5412-9","10.1109/CIS.2009.175","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5376091","similarity;plagiarism detection;code clone;suffix array","Software measurement;Plagiarism;Cloning;Current measurement;Educational institutions;Space technology;Software maintenance;Computational intelligence;Computer security;Genomics","educational technology;software engineering","source code;suffix array;automatic similarity measurement;code clone detection;genome analysis;match algorithm;time complexity;plagiarism detection","","1","","13","IEEE","12 Jan 2010","","","IEEE","IEEE Conferences"
"The Recent Development of Automated Programming Assessment","Y. Liang; Q. Liu; J. Xu; D. Wang","Department of Educational Information and Technology, South China Normal University, Guangzhou, China; Department of Educational Information and Technology, South China Normal University, Guangzhou, China; Department of Educational Information and Technology, South China Normal University, Guangzhou, China; Department of Educational Information and Technology, South China Normal University, Guangzhou, China","2009 International Conference on Computational Intelligence and Software Engineering","28 Dec 2009","2009","","","1","5","Nowadays computer programs are objectively tested and marked by automated programming assessment systems in computer science education. Dynamic analysis and static analysis are two major approaches in the field of automated programming assessment. Methods adopted by dynamic and static analysis have been emphasized and detailed in this paper. Advantages and disadvantages of them implemented in instruction have been analyzed when taking instructional practice into consideration. Although many automated programming assessment systems have been proved to be of great help to both instructors and students in programming instruction, several problems remain unsolved, such as the security problem and algorithms for automatic generation of test data in dynamic analysis, low accuracy and precision of correctness and functionality assessment in static analysis, thus optimal approaches are still under research. The way of effective use of dynamic analysis and static analysis in instructional practice is also suggested in order that instructors can use the results of this study to choose the most appropriate approach in the context of a particular instructional goal. Finally, standardization of automated programming assessment systems, way to open source code and intelligent tutor system for automated programming assessment are expected to come into exist in the future.","","978-1-4244-4507-3","10.1109/CISE.2009.5365307","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5365307","","Automatic programming;Programming profession;Dynamic programming;Automatic testing;System testing;Functional programming;Algorithm design and analysis;Computer science education;Data security;Data analysis","automatic programming;computer science education;program diagnostics","automated programming assessment;computer programs;computer science education;dynamic analysis;static analysis","","11","","34","IEEE","28 Dec 2009","","","IEEE","IEEE Conferences"
"Mobile-Aware Web Services","G. Ortiz; A. G. De Prado","UEX, Quercus Software Engineering Group, Mérida, Spain; Res. Div., ADT, Zaragoza, Spain","2009 Third International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies","28 Dec 2009","2009","","","65","70","The increasing demand for services for mobile customers has resulted in the need to develop Web services clients that could be used from mobile devices as well as from PCs, which to date has been the main focus for developers. In this paper we propose an aspect-oriented approach which allows services to be invoked ubiquitously from different type of devices without modifying the structure and encapsulation of the offered service. The paper will show how this can be provided both at compile and at runtime.","","978-1-4244-5083-1","10.1109/UBICOMM.2009.13","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5361675","Mobile Devices;Web Services;Aspect-Oriented Prgramming;Model-Driven Development","Web services;Books;Personal digital assistants;Mobile computing;Mobile handsets;Bandwidth;Internet;Ubiquitous computing;Software engineering;Microcomputers","aspect-oriented programming;mobile computing;Web services","mobile-aware Web services;PC;ubiquitous computing;aspect-oriented programming","","6","","14","IEEE","28 Dec 2009","","","IEEE","IEEE Conferences"
"Code Clone Graph Metrics for Detecting Diffused Code Clones","Y. Fukushima; R. Kula; S. Kawaguchi; K. Fushida; M. Nagura; H. Iida","Graduate School of Information Science, Nara Institute of Science and Technology, Ikoma, Nara, Japan; Graduate School of Information Science, Nara Institute of Science and Technology, Ikoma, Nara, Japan; Graduate School of Information Science, Nara Institute of Science and Technology, Ikoma, Nara, Japan; Graduate School of Information Science, Nara Institute of Science and Technology, Ikoma, Nara, Japan; Graduate School of Information Science, Nara Institute of Science and Technology, Ikoma, Nara, Japan; Graduate School of Information Science, Nara Institute of Science and Technology, Ikoma, Nara, Japan","2009 16th Asia-Pacific Software Engineering Conference","28 Dec 2009","2009","","","373","380","Code clones (duplicated source code in a software system) are one of the major factors in decreasing maintainability. Many code clone detection methods have been proposed to find code clones automatically from large-scale software. However, it is still hard to find harmful code clones to improve maintainability because there are many code clones that should remain. Thus, to help find harmful code clones, we propose a code clone visualization method and a metrics application on the visualized information. Our method enables the location of harmful code clones diffused in a software system. We apply our method to three open source software programs and visualize their code clone information.","1530-1362","978-0-7695-3909-6","10.1109/APSEC.2009.53","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5358762","visualization;software maintenance;program comprehension","Cloning;Visualization;Software maintenance;Costs;Software systems;Large-scale systems;Open source software;Software engineering;Information science;Application software","data visualisation;program verification;software maintenance;software metrics","code clone graph metrics;diffused code clones detection;large-scale software;code clone visualization method;open source software programs","","7","","12","IEEE","28 Dec 2009","","","IEEE","IEEE Conferences"
"Problematic Code Clones Identification Using Multiple Detection Results","Y. Higo; K. -i. Sawa; S. Kusumoto","Graduate School of Information Science and Technology, Osaka University, Suita, Osaka, Japan; Graduate School of Information Science and Technology, Osaka University, Suita, Osaka, Japan; Graduate School of Information Science and Technology, Osaka University, Suita, Osaka, Japan","2009 16th Asia-Pacific Software Engineering Conference","28 Dec 2009","2009","","","365","372","Most code clones are generated by copy-and paste programming. Copy-and-paste programming shortens a time required for implementation because pasted code is a template of the required functionality. However, it sometimes brings on new bugs to the source code. After copy-and-paste, pasted code is somewhat changed fitting for the context of the region surrounding the pasted code. For example, some identifiers are replaced with other identifiers or a few statements are inserted, deleted, or changed. If such modifications are incorrectly performed, bugs occur in code clones. However, not all code clones are problematic, many code clones have decent reasons for their existence. Consequently, simple code clone detection is inefficient for identifying problematic code clones. Firstly, this paper proposes a classification scheme for dividing problematic code clones from non problematic ones. Secondly, it proposes a method for extracting specific code clones classified as problematic ones. Thirdly, it presents results of case studies conducted for evaluating the proposed method. The proposed method uses multiple code clone detection tools, and it doesn't directly analyze program source code. After multiple detections, simple operations are performed to extract code clones that are likely to be problematic. In the case studies conducted on an open source software system, the proposed method could actually identify 22 problematic code clones.","1530-1362","978-0-7695-3909-6","10.1109/APSEC.2009.30","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5358749","code clone;fault detection","Cloning;Computer bugs;Software engineering;Information science;Functional programming;Open source software;Fault detection;Fault diagnosis;Region 2;Software maintenance","open systems;public domain software;software maintenance;source coding","problematic code clones identification;copy-and paste programming;paste code;multiple code clone detection tools;program source code;open source software system;fault detection","","6","","14","IEEE","28 Dec 2009","","","IEEE","IEEE Conferences"
"What Software Repositories Should Be Mined for Defect Predictors?","R. Ramler; S. Larndorfer; T. Natschläger","Software Competence Center Hagenberg GmbH, Hagenberg, Austria; Software Competence Center Hagenberg GmbH, Hagenberg, Austria; Software Competence Center Hagenberg GmbH, Hagenberg, Austria","2009 35th Euromicro Conference on Software Engineering and Advanced Applications","8 Dec 2009","2009","","","181","187","The information about which modules in a software system's future version are potentially defective is a valuable aid for quality managers and testers. Defect prediction promises to indicate these defect-prone modules. Constructing effective defect prediction models in an industrial setting involves the decision from what data source the defect predictors should be derived. In this paper we compare defect prediction results based on three different data sources of a large industrial software system to answer the question what repositories to mine. In addition, we investigate whether a combination of different data sources improves the prediction results. The findings indicate that predictors derived from static code and design analysis provide slightly yet still significant better results than predictors derived from version control, while a combination of all data sources showed no further improvement.","2376-9505","978-0-7695-3784-9","10.1109/SEAA.2009.65","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5349842","defect prediction;data mining;software repositories","Databases;Software systems;Software quality;Predictive models;Object oriented modeling;Data mining;Software testing;Computer industry;Electrical equipment industry;Programming","data mining;database management systems;software metrics","software repository;defect prone module;defect prediction model;industrial software system;software repository mining;data sources improvement","","5","","22","IEEE","8 Dec 2009","","","IEEE","IEEE Conferences"
"Design and realization of 3D character animation engine","G. Ying; L. Xuqing; W. Xiuliang; F. Yi; G. Shuxia","College of Marine, Northwestern Polytechnical University, Xi'an, China; College of Marine, Northwestern Polytechnical University, Xi'an, China; College of Marine, Northwestern Polytechnical University, Xi'an, China; College of Marine, Northwestern Polytechnical University, Xi'an, China; College of Marine, Northwestern Polytechnical University, Xi'an, China","2009 2nd IEEE International Conference on Broadband Network & Multimedia Technology","4 Dec 2009","2009","","","524","528","Character animation which is used to show human figure has been extensively applied in VR (Visual Reality) field. Because too much initial work is being repeated, it usually costs more than needed to make character animation, and the technical difficulty is also at a high level. Large game corporations incline to keep the core technologies of character animation as commercial secrets, thus block its development. In this paper, the main framework of a ldquo3D character animation enginerdquo is designed. Great emphasis is put on the principle of different types of character animation and their realization methods. The 3D character animation engine provides consistent APIs for key-frame animation, mixed animation and morph animation. It enable users make character animation through programming in a fast and easy way.","","978-1-4244-4590-5","10.1109/ICBNMT.2009.5347860","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5347860","Character Animation;Key-frame Animation;Mixed Animation;Morph Animation","Animation;Engines;Rendering (computer graphics);Biological system modeling;Humans;Costs;Skin;Joints;Educational institutions;Virtual reality","application program interfaces;computer animation;computer games;virtual reality","application program interface;3D character animation engine;visual reality;game corporation;core technology","","2","","5","IEEE","4 Dec 2009","","","IEEE","IEEE Conferences"
"Code clone detection using parsing actions","K. Maeda","Department of Business Administration and Information Science, Chubu University, Kasugai, Aichi, Japan","2009 9th International Symposium on Communications and Information Technology","1 Dec 2009","2009","","","762","763","This paper proposes a new technique to detect code clones from the lexical and syntactic point of view, which is based on PALEX source code representation. The PALEX code contains the recorded parsing actions and also lexical formatting information including white spaces and comments. We can record a list of parsing actions (shift, reduce, and reading a token) during a compiling process after a compiler finishes analyzing the source code. The proposed technique has advantages for syntax sensitive token-based approach and language independency.","","978-1-4244-4521-9","10.1109/ISCIT.2009.5341139","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5341139","","Cloning;Information analysis;White spaces;Arithmetic;XML;Software tools;Information science;Productivity;Testing;Computer bugs","computational linguistics;formal languages;grammars;program compilers;source coding;XML","code clone detection technique;parsing action;PALEX source code representation;lexical formatting information;syntactic point;syntax sensitive token-based approach;language independency;compiler process;XML","","1","","8","IEEE","1 Dec 2009","","","IEEE","IEEE Conferences"
"Mining Software Change History in an Industrial Environment","M. C. Júnior; M. Mendonça; F. Rodrigues","Software Engineering Laboratory - UFBA, Federal University of Bahia, Salvador, BA, Brazil; Software Engineering Laboratory - UFBA, Federal University of Bahia, Salvador, BA, Brazil; Software Engineering Laboratory - UFBA, Federal University of Bahia, Salvador, BA, Brazil","2009 XXIII Brazilian Symposium on Software Engineering","17 Nov 2009","2009","","","54","61","Version control systems are among the type of repositories that are frequently explored as sources of software change history. They can be mined to identify associations between software module modifications. This information is useful to support software modification activities, indicating to software engineers which modules are usually modified together during software maintenance or evolution. Previous works published on the subject focused on mining associations from open source software projects. This article presents the use of association mining in an industrial environment. The study was set up as a formal experiment and studied 18 systems developed in a large Brazilian beverage company. The results show that the precision of the rules obtained in this environment are even higher than its counterpart obtained in open source projects. This suggests that this approach is very useful in this type of environment.","","978-1-4244-5024-4","10.1109/SBES.2009.8","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5336147","closed-source projects;mining software repositories;experimentation;software data warehouse","History;Computer industry;Mining industry;Open source software;Data mining;Control systems;Association rules;Software engineering;Software maintenance;Electrical equipment industry","beverage industry;configuration management;data mining;software maintenance","software change history;software mining;industrial environment;version control systems;software module modifications;software engineers;software maintenance;software evolution;open source software projects;Brazilian beverage company","","","2","20","IEEE","17 Nov 2009","","","IEEE","IEEE Conferences"
"Assessing Intra-application Exception Handling Reuse with Aspects","J. C. Taveira; C. Queiroz; R. Lima; J. Saraiva; S. Soares; H. Oliveira; N. Temudo; A. Araujo; J. Amorim; F. Castor; E. Barreiros","Department of Computing and Systems, University of Pernambuco (UPE), Recife, Brazil; Department of Computing and Systems, University of Pernambuco (UPE), Recife, Brazil; Department of Computing and Systems, University of Pernambuco (UPE), Recife, Brazil; Department of Computing and Systems, University of Pernambuco (UPE), Recife, Brazil; Department of Computing and Systems, University of Pernambuco (UPE), Recife, Brazil; Department of Computing and Systems, University of Pernambuco (UPE), Recife, Brazil; Department of Computing and Systems, University of Pernambuco (UPE), Recife, Brazil; Department of Computing and Systems, University of Pernambuco (UPE), Recife, Brazil; Department of Computing and Systems, University of Pernambuco (UPE), Recife, Brazil; Informatics Center, Federal University of Pernambuco (UFPE), Recife, Brazil; Informatics Center, Federal University of Pernambuco (UFPE), Recife, Brazil","2009 XXIII Brazilian Symposium on Software Engineering","17 Nov 2009","2009","","","22","31","Recent studies have attempted to evaluate the benefits and drawbacks of using aspect-oriented programming to modularize exception handling code. In spite of their many interesting findings, these studies have not reached a consensus when it comes to the impact of aspectization on exception handler reuse. In fact, their results are sometimes in direct contradiction.In this paper we describe a study aiming to answer the question of whether AOP really promotes the implementation of reusable exception handling. We analyze reuse in a specific context: in terms of the number of duplicated or very similar error handlers that can be removed from a program when extracting error handling code to aspects. Our study targets three industrial-strength, medium-size software systems from different domains and employs a comprehensive set of concern-specific metrics.","","978-1-4244-5024-4","10.1109/SBES.2009.21","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5336160","","Computer languages;Maintenance;Software engineering;Informatics;Computer industry;Software systems;Programming;Java;Scattering;Document handling","error handling;object-oriented programming;software engineering;software metrics","intra-application exception handling reuse;aspect-oriented programming;AOP;reusable exception handling;error handling code;industrial-strength software systems;medium-size software systems;concern-specific metrics","","8","1","28","IEEE","17 Nov 2009","","","IEEE","IEEE Conferences"
"Enhancing Quality of Code Clone Detection with Program Dependency Graph","Y. Higo; S. Kusumoto","Graduate School of Information Science and Technology, Osaka University, Suita, Osaka, Japan; Graduate School of Information Science and Technology, Osaka University, Suita, Osaka, Japan","2009 16th Working Conference on Reverse Engineering","17 Nov 2009","2009","","","315","316","At present, there are various kinds of code clone detection techniques. PDG-based detection is suitable to detect non-contiguous code clones meanwhile other detection techniques are not suited to detect them. However, there is a tendency that it cannot detect contiguous code clones unlike string-based or token-based technique. This paper proposes two techniques to enhance the PDG-based detection for practical usage. The software tool, Scorpio has been developed based on the techniques.","2375-5369","978-0-7695-3867-9","10.1109/WCRE.2009.39","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5328754","code clone;program slice","Cloning;Software systems;Reverse engineering;Information science;Software tools;Flow graphs","codes;software tools","code clone detection;program dependency graph;software tool Scorpio","","18","","4","IEEE","17 Nov 2009","","","IEEE","IEEE Conferences"
"Computing Structural Types of Clone Syntactic Blocks","E. Merlo; T. Lavoie","Department of Computer and Software Engineering, École Polytechnique de Montréal, Montreal, QUE, Canada; Department of Computer and Software Engineering, École Polytechnique de Montréal, Montreal, QUE, Canada","2009 16th Working Conference on Reverse Engineering","17 Nov 2009","2009","","","274","278","A clone classification scheme is presented based on the structure of the abstract syntax tree (AST) of a system and on the similarity measures between syntactic blocks of source code. Syntactic blocks in a system may represent classes, methods, statement blocks, and so on. An inclusion relation may exist between the source code lines of some of these blocks, depending of the syntactic structure of the source code. For example, a block corresponding to a method body may contain several possibly nested statement blocks.This paper introduces an algorithm to identify different types of clone relations between blocks that are either method bodies or statement blocks. Clone relation types between these blocks are interesting because they indicate properties of the structural relation of these clones and may give hints on re-factoring opportunities. The proposed structural type clone classification scheme has been investigated on two open source Java systems, Tomcat and Eclipse. Experimental results are presented. Execution time performance of clone classification has been measured and reported. Results and further proposed research are discussed.","2375-5369","978-0-7695-3867-9","10.1109/WCRE.2009.33","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5328785","clone types;software similarity;clone detection;software re-factoring;open source analysis","Cloning;Java;Open source software;Labeling;Reverse engineering;Software engineering;Classification tree analysis;Software measurement;Time measurement;Lab-on-a-chip","abstract data types;software maintenance;software metrics","structural type computing;clone syntactic block;clone classification scheme;abstract syntax tree;similarity measure;source code;clone relation type;software refactoring;open source Java system;Tomcat;Eclipse;metrics-based clone detection","","5","","26","IEEE","17 Nov 2009","","","IEEE","IEEE Conferences"
"Domain Feature Model Recovery from Multiple Applications Using Data Access Semantics and Formal Concept Analysis","Y. Yang; X. Peng; W. Zhao","School of Computer Science, Fudan University, Shanghai, China; School of Computer Science, Fudan University, Shanghai, China; School of Computer Science, Fudan University, Shanghai, China","2009 16th Working Conference on Reverse Engineering","17 Nov 2009","2009","","","215","224","Feature models are widely employed in domain specific software development to specify the domain requirements with commonality and variability. A feature model is usually constructed by domain experts after comprehensive domain analysis. In this paper, we propose a method to recover an initial domain feature model from multiple existing domain applications using data access semantics and formal concept analysis (FCA). In the method, we first establish mappings among the database schemas of all the reference implementations. Then, we capture the data access semantics of each method in each reference implementation. Based on the pre-established data mapping, we can mix methods from different applications together and conduct formal concept analysis with the data access semantics as intention. After that,further concept merging/pruning and variability analysis are performed to produce the domain feature model. In order to evaluate the effectiveness of our method, we conduct a case study on three open-source forum applications and present comprehensive analysis and discussions on the results.","2375-5369","978-0-7695-3867-9","10.1109/WCRE.2009.15","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5328772","feature model recovery;FCA;data access semantics","Application software;Information analysis;Reverse engineering;Spatial databases;Merging;Open source software;Yarn;Erbium;Computer science;Programming","data analysis;database management systems;formal specification;merging;product development;software reusability","domain feature model recovery;multiple application;data access semantics;formal concept analysis;domain specific software development;domain requirement specification;domain expert;comprehensive domain analysis;FCA;database schema;reference implementation;data mapping;mix method;concept merging;concept pruning;variability analysis;open-source forum application;software product line","","20","","20","IEEE","17 Nov 2009","","","IEEE","IEEE Conferences"
"An Empirical Study on Inconsistent Changes to Code Clones at Release Level","N. Bettenburg; W. Shang; W. Ibrahim; B. Adams; Y. Zou; A. E. Hassan","Queen's University, Kingston, ONT, Canada; Queen's University, Kingston, ONT, Canada; Queen's University, Kingston, ONT, Canada; Queen's University, Kingston, ONT, Canada; Queen's University, Kingston, ONT, Canada; Queen's University, Kingston, ONT, Canada","2009 16th Working Conference on Reverse Engineering","17 Nov 2009","2009","","","85","94","Current research on code clones tries to address the question whether or not code clones are harmful for the quality of software. As most of these studies are based on the fine-grained analysis of inconsistent changes at the revision level, they capture much of the chaotic and experimental nature inherent to any ongoing software development process. Conclusions drawn from the inspection of highly fluctuating and short-lived clones are likely to exaggerate the ill effects of inconsistent changes. To gain a broader perspective, we perform an empirical study on the effect of inconsistent changes on software quality at the release level. Based on a case study on two open source software systems, we observe that only 1% to 3% of inconsistent changes to clones introduce software defects, as opposed to substantially higher percentages reported by other studies. Our findings suggest that developers are able to effectively manage and control the evolution of cloned code at the release level.","2375-5369","978-0-7695-3867-9","10.1109/WCRE.2009.51","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5328705","Software Engineering;Maintenance management;Reuse models;Scalability;Maintainability","Cloning;Programming;Open source software;Software systems;Software quality;Reverse engineering;Chaos;Inspection;Performance gain;Maintenance engineering","software maintenance;software quality","code clone;software quality;fine-grained analysis;software development process;software defect;software release;software maintenance","","37","","27","IEEE","17 Nov 2009","","","IEEE","IEEE Conferences"
"Tracking Design Smells: Lessons from a Study of God Classes","S. Vaucher; F. Khomh; N. Moha; Y. -G. Gueheneuc","Dépt. d'Informatique, GEODES / Ptidej Team, Université de Montreal, Montreal, Canada; Dépt. d'Informatique, GEODES / Ptidej Team, Université de Montreal, Montreal, Canada; Triskell Team, IRISA/Université de Rennes 1, Rennes, France; Ptidej Team, Dépt. de Génie Informatique, Ećole Polytechnique de Montréal, Montreal, Canada","2009 16th Working Conference on Reverse Engineering","17 Nov 2009","2009","","","145","154","""God class"" is a term used to describe a certain type of large classes which ""know too much or do too much"". Often a God class (GC) is created by accident as functionalities are incrementally added to a central class over the course of its evolution. GCs are generally thought to be examples of bad code that should be detected and removed to ensure software quality. However, in some cases, a GC is created by design as the best solution to a particular problem because, for example, the problem is not easily decomposable or strong requirements on efficiency exist. In this paper, we study in two open-source systems the ""life cycle"" of GCs: how they arise, how prevalent they are, and whether they remain or they are removed as the systems evolve over time, through a number of versions. We show how to detect the degree of ""godliness"" of classes automatically. Then, we show that by identifying the evolution of ""godliness"", we can distinguish between those classes that are so by design (good code) from those that occurred by accident (bad code). This methodology can guide software quality teams in their efforts to implement prevention and correction mechanisms.","2375-5369","978-0-7695-3867-9","10.1109/WCRE.2009.23","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5328806","Design smells;antipatterns;software evolution;empirical study","Accidents;Software quality;Open source software;Software maintenance;Bayesian methods;Reverse engineering;Kernel;Personnel;Risk analysis;Pattern analysis","configuration management;software maintenance;software quality","design smell tracking;GC;God class;software evolution;software quality;open-source system;systems version","","49","","42","IEEE","17 Nov 2009","","","IEEE","IEEE Conferences"
"Compare and contrast: Visual exploration of source code examples","R. Cottrell; B. Goyette; R. Holmes; R. J. Walker; J. Denzinger","Department of Computer Science, University of Calgary, Calgary, AB, Canada; Robotics Institute, Carnegie Mellon University, Pittsburgh, PA, USA; Department of Computer Science and Engineering, University of Washington, Seattle, WA, USA; Department of Computer Science, University of Calgary, Calgary, AB, Canada; Department of Computer Science, University of Calgary, Calgary, AB, Canada","2009 5th IEEE International Workshop on Visualizing Software for Understanding and Analysis","17 Nov 2009","2009","","","29","32","Understanding the commonalities and differences of a set of source code examples can help developers to understand or to evolve application programming interfaces (APIs). While several approaches exist to assist developers in locating source code examples, they often present their results only in a basic list view, with at most an indication of the relationship to the search query; unfortunately, they offer no information on how the results relate to one another. A developer is then faced with the highly manual task of exploring these examples to discern their similarities and differences. This paper describes our prototype tool (called Guido) for exploring source code examples, using their structural correspondences. The Guido tool uses multiple coordinated views to visualize the relationships between examples, in order to assist the developer in identifying common and unique traits between them.","","978-1-4244-5027-5","10.1109/VISSOF.2009.5336429","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5336429","","Prototypes;Visualization;Software systems;Cloning;Computer science;Application software;Image analysis;Software prototyping;Functional programming;Software tools","application program interfaces;program visualisation;software architecture;software prototyping;source coding","visual exploration;source code examples;application programming interfaces;search query;prototype tool;Guido","","7","","11","IEEE","17 Nov 2009","","","IEEE","IEEE Conferences"
"Case study: Visual analytics in software product assessments","A. Telea; L. Voinea","Institute of Mathematics and Computer Science, University of Groningam, Netherlands; SolidSource BV, Eindhoven, Netherlands","2009 5th IEEE International Workshop on Visualizing Software for Understanding and Analysis","17 Nov 2009","2009","","","65","72","We present how a combination of static source code analysis, repository analysis, and visualization techniques has been used to effectively get and communicate insight in the development and project management problems of a large industrial code base. This study is an example of how visual analytics can be effectively applied to answer maintenance questions and support decision making in the software industry. We comment on the relevant findings during the study both in terms of used technique and applied methodology and outline the favorable factors that were essential in making this type of assessment successful within tight time and budget constraints.","","978-1-4244-5027-5","10.1109/VISSOF.2009.5336417","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5336417","","Visual analytics;Project management;Computer industry;Data visualization;Concrete;Data analysis;Documentation;Computer architecture;Cement industry;Embedded software","data visualisation;decision making;program diagnostics;program visualisation;project management;software maintenance","visual analytics;software product assessment;static source code analysis;repository analysis;visualization techniques;project management problems;industrial code base;decision making;software industry;software maintenance","","6","1","18","IEEE","17 Nov 2009","","","IEEE","IEEE Conferences"
"Computational model for trust management in RFID supply chains","M. Mahinderjit-Singh; X. Li","School of Information Technology and Electrical Engineering, University of Queensland, Australia; School of Information Technology and Electrical Engineering, University of Queensland, Australia","2009 IEEE 6th International Conference on Mobile Adhoc and Sensor Systems","17 Nov 2009","2009","","","734","740","Trust management in an open RFID system environment is a nontrivial problem, where different organizations have different business workflows and operate on different standards and protocols. Open RFID systems can only be effective if the systems can trust each other and be collaborative. The open system environment is also constantly evolving. So the trust and the collaborations need to be constantly maintained to cope with changes. RFID is becoming a ubiquitous computing technology imposing security and privacy threats. Counterfeiting in supply chain management is an attack with cloned and fraud RFID tags in order to gain illegal benefits. In this paper we will extend our previous work on a trust framework and construct a computational model for the trust management. The trust evaluation is built into the process of transactions of the data exchange and authorization in order to facilitate a better data sharing and access control. An example of wine counterfeiting will be presented and we will show how our computational trust model helps in reducing fraud brand of wines in supply chain management (SCM).","2155-6814","978-1-4244-5113-5","10.1109/MOBHOC.2009.5336926","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5336926","RFID;Trust Management (TM);Supply Chain Management (SCM);Computational Trust Management (CTM)","Computational modeling;Supply chain management;Radiofrequency identification;Supply chains;Collaborative work;Counterfeiting;Environmental management;Standards organizations;Protocols;Open systems","copy protection;electronic data interchange;radiofrequency identification;security of data;supply chain management;ubiquitous computing;wine industry","trust management;RFID supply chains;RFID system;organizations;ubiquitous computing technology;data exchange;computational trust model;fraud brand;supply chain management;wine counterfeiting","","5","","25","IEEE","17 Nov 2009","","","IEEE","IEEE Conferences"
"Adapting Web Services for Multiple Devices: A Model-Driven, Aspect-Oriented Approach","G. Ortiz; A. G. d. Prado","Quercus Software Engineering Group, UEX, Mérida, Spain; NA","2009 Congress on Services - I","10 Nov 2009","2009","","","754","761","Mobile devices have become an essential element in our daily lives, even for connecting to the Internet. Web Services have become extremely important when offering services through the Internet. However, current Web Services are very inflexible as regards their invocation from different types of device, especially if we consider the need for them to be adaptable when being invoked from a mobile device. In this paper, we will propose several alternatives for the creation of flexible web services which can be invoked from different types of device, and compare the different proposed approaches. Aspect-Oriented Programming and Model-Driven Development have been used in all proposals to reduce the impact of service adaption, not only for the service developer, but also to maintain the correct code structure.","2378-3818","978-0-7695-3708-5","10.1109/SERVICES-I.2009.21","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5190702","Web Services;Mobile Devices;Aspect-Oriented Programming;Model-Driven Development","Web services;Simple object access protocol;Context-aware services;Portable computers","mobile computing;object-oriented programming;Web services","mobile device application;Internet;flexible Web service;aspect oriented programming;model driven development","","9","2","21","IEEE","10 Nov 2009","","","IEEE","IEEE Conferences"
"The curse of copy&paste — Cloning in requirements specifications","C. Domann; E. Juergens; J. Streit","Itestra GmbH, Kaufering, Germany; Institut für Informatik, Technische Universität München, Germany; Itestra GmbH, Kaufering, Germany","2009 3rd International Symposium on Empirical Software Engineering and Measurement","6 Nov 2009","2009","","","443","446","Cloning in source code is a well known quality defect that negatively affects software maintenance. In contrast, little is known about cloning in requirements specifications. We present a study on cloning in 11 real-world requirements specifications comprising 2,500 pages. For specification clone detection, an existing code clone detection tool is adapted and its precision analyzed. The study shows that a considerable amount of cloning exists, although the large variation between specifications suggests that some authors manage to avoid cloning. Examples of frequent types of clones are given and the negative consequences of cloning, particularly the obliteration of commonalities and variations, are discussed.","1949-3789","978-1-4244-4842-5","10.1109/ESEM.2009.5315992","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5315992","","Cloning;Software maintenance;Automotive engineering;History;Software engineering;Inspection;Detection algorithms;Data mining;Information systems;Companies","formal specification;software maintenance","copy & paste;requirements specifications;source code;software maintenance;specification clone detection","","3","","13","IEEE","6 Nov 2009","","","IEEE","IEEE Conferences"
"How to mitigate hardware obsolescence in next-generation test systems","N. Tacha; A. McCarthy; B. Powell; A. Veeramani","National Instruments Corporation, Austin, TX, USA; National Instruments Corporation, Austin, TX, USA; National Instruments Corporation, Austin, TX, USA; National Instruments Corporation, Austin, TX, USA","2009 IEEE AUTOTESTCON","6 Nov 2009","2009","","","229","234","Automatic test engineers are faced with replacing obsolete software and hardware in systems that remain in operation longer than individual components are supported. Replacing obsolete hardware can be especially challenging because of the need to modify test software in order to support new instrumentation. Changes to test software in order to support new instrumentation might affect multiple areas of the application and require time-consuming development or costly revalidation. This paper explains how you can mitigate hardware obsolescence with the use of well-designed hardware abstraction layers.","1558-4550","978-1-4244-4980-4","10.1109/AUTEST.2009.5314087","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5314087","obsolescence;re-hosting;life-cycle mismatch;migration;user-defined;object-oriented programming","Hardware;System testing;Instruments;Software testing;Life testing;Application software;Costs;Automatic testing;Object oriented modeling;Logic testing","program testing","automatic test engineer;hardware obsolescence;next-generation test system;time-consuming development;hardware abstraction layer;software testing","","5","","","IEEE","6 Nov 2009","","","IEEE","IEEE Conferences"
"Towards High Quality Software Development with Extreme Programming Methodology: Practices from Real Software Projects","B. Xu","College of Computer Science & Information Engineering, Zhejiang Gongshang University, Hangzhou, China","2009 International Conference on Management and Service Science","30 Oct 2009","2009","","","1","4","Software quality is essential to software development projects, from the aspects of the customer, sponsor, development team and quality assurance team. Though there are kinds of test tools which help us to find the defect more efficiently, many researchers agreed that it is not enough nor efficient to validate the software product after it is produced. At the other hand, some agile software processes such as extreme programming enable us to produce high quality product but with too much different requirement to the project management. This paper introduces extreme programming (XP) practices in some real software projects, which can be helpful for project stakeholders to manage the quality efficiently and with less risk.","","978-1-4244-4638-4","10.1109/ICMSS.2009.5302042","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5302042","","Software quality;Quality management;Project management;Programming profession;Feedback;Logic testing;Educational institutions;Computer science;Quality assurance;Software testing","program testing;program verification;project management;quality assurance;software development management;software quality","high quality software development;extreme programming methodology;real software project;quality assurance team;software product validation;project management;software testing","","5","","12","IEEE","30 Oct 2009","","","IEEE","IEEE Conferences"
"Detection and analysis of near-miss software clones","C. K. Roy","School of Computing, Queen's University, Kingston, ONT, Canada","2009 IEEE International Conference on Software Maintenance","30 Oct 2009","2009","","","447","450","Software clones are considered harmful in software maintenance and evolution. However, despite a decade of active research, there is a marked lack of work in the detection and analysis of near-miss software clones, those where minor to extensive modifications have been made to the copied fragments. In this thesis, we advance the state-of-the-art in clone detection and analysis in several ways. First, we develop a hybrid clone detection method. Second, we address the decade of vagueness in clone definition by proposing a metamodel of clone types. Third, we conduct a scenario-based comparison and evaluation of all of the currently available clone detection techniques and tools. Fourth, in order to evaluate and compare the available tools in a realistic setting, we develop a mutation-based framework that automatically and efficiently measures (and compares) the recall and precision of clone detection tools. Fifth, we conduct a large scale empirical study of cloning in open source systems.","1063-6773","978-1-4244-4897-5","10.1109/ICSM.2009.5306301","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5306301","","Cloning;Software maintenance;Software systems;Software quality;Large-scale systems;Programming;Open source software;Software engineering;Plagiarism;Compaction","public domain software;software maintenance","near-miss software clones;software maintenance;software evolution;clone analysis;hybrid clone detection method;clone definition;open source systems","","36","","13","IEEE","30 Oct 2009","","","IEEE","IEEE Conferences"
"Managing code clones using dynamic change tracking and resolution","M. de Wit; A. Zaidman; A. van Deursen","Delft University of Technnology, Netherlands; Delft University of Technnology, Netherlands; Delft University of Technnology, Netherlands","2009 IEEE International Conference on Software Maintenance","30 Oct 2009","2009","","","169","178","Code cloning is widely recognized as a threat to the maintainability of source code. As such, many clone detection and removal strategies have been proposed. However, some clones can often not be removed easily so other strategies, based on clone management need to be developed. In this paper we describe a clone management strategy based on dynamically inferring clone relations by monitoring clipboard activity. We introduce CLONEBOARD, our Eclipse plug-in implementation that is able to track live changes to clones and offers several resolution strategies for inconsistently modified clones. We perform a user study with seven subjects to assess the adequacy, usability and effectiveness of CLONEBOARD, the results of which show that developers actually see the added value of such a tool but have strict requirements with respect to its usability.","1063-6773","978-1-4244-4897-5","10.1109/ICSM.2009.5306336","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5306336","","Cloning;Usability;Software maintenance;Technology management;Monitoring;Software performance;Software tools;Computer bugs","software development management;software maintenance","code cloning management;dynamic change tracking;dynamic resolution;source code maintainability;CLONEBOARD program;clipboard activity monitoring","","33","1","28","IEEE","30 Oct 2009","","","IEEE","IEEE Conferences"
"Scalable and incremental clone detection for evolving software","T. T. Nguyen; H. A. Nguyen; J. M. Al-Kofahi; N. H. Pham; T. N. Nguyen","Iowa State University, USA; Iowa State University, USA; Iowa State University, USA; Iowa State University, USA; Iowa State University, USA","2009 IEEE International Conference on Software Maintenance","30 Oct 2009","2009","","","491","494","Code clone management has been shown to have several benefits for software developers. When source code evolves, clone management requires a mechanism to efficiently and incrementally detect code clones in the new revision. This paper introduces an incremental clone detection tool, called ClemanX. Our tool represents code fragments as subtrees of abstract syntax trees (ASTs), measures their similarity levels based on their characteristic vectors of structural features, and solves the task of incrementally detecting similar code as an incremental distance based clustering problem. Our empirical evaluation on large-scale software projects shows the usefulness and good performance of ClemanX.","1063-6773","978-1-4244-4897-5","10.1109/ICSM.2009.5306283","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5306283","","Cloning;Feature extraction;Software development management;Large-scale systems;Software performance;Project management","computer aided software engineering","incremental clone detection;evolving software;code clone management;source code evolution;ClemanX clone detection tool;abstract syntax trees;structural feature characteristic vector;distance based clustering problem;large-scale software project","","18","","4","IEEE","30 Oct 2009","","","IEEE","IEEE Conferences"
"Proactively managing copy-and-paste induced code clones","D. Hou; F. Jacob; P. Jablonski","Electrical and Computer Engineering, Clarkson University, Potsdam, NY, USA; Electrical and Computer Engineering, Clarkson University, Potsdam, NY, USA; Electrical and Computer Engineering, Clarkson University, Potsdam, NY, USA","2009 IEEE International Conference on Software Maintenance","30 Oct 2009","2009","","","391","392","Programmers copy and paste code. As a result, similar code fragments (clones) are added into software systems. Like other software artifacts, clones require attention and effort from programmers so that they can be found, understood, and correctly adapted and evolved. In addition to what clone-detection-based tools can offer, other automated support can be developed to better assist programmers in these activities, for example, to compare and contrast code clones, or help edit (a group of) clones consistently and quickly. We describe several such features currently being developed in the CnP project on top of Eclipse and for Java.","1063-6773","978-1-4244-4897-5","10.1109/ICSM.2009.5306284","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5306284","","Cloning;Programming profession;Jacobian matrices;Software systems;Java;Visualization;Engineering management;Computer vision;Bars;Collaborative work","software maintenance","code fragments;software systems;software artifacts;clone-detection-based tools","","5","","6","IEEE","30 Oct 2009","","","IEEE","IEEE Conferences"
"Characterization of DBT overhead","E. Borin; Y. Wu","PSL, Intel Corporation, Santa Clara, CA, USA; PSL, Intel Corporation, Santa Clara, CA, USA","2009 IEEE International Symposium on Workload Characterization (IISWC)","30 Oct 2009","2009","","","178","187","In recent years, dynamic binary translation has emerged as an important tool with many real world applications. Besides supporting legacy binary code and ISA virtualization, it enables innovative co-designed microarchitectures and allows transparent binary instrumentation. The dynamic nature of the translation usually incurs extra execution overhead and many research works had proposed software and hardware solutions to minimize the overhead. In this paper, we analyze our dynamic binary translator performance and depict the main sources of overhead in details. We classify the translation operations and associated overhead into five major categories, and quantify their contribution to the overall overhead. Based on the analysis and detailed evaluation, we identify and point out the most promising solutions to address the overhead problem. We believe this study is an important first step toward the grand goal of zero-overhead dynamic binary translation.","","978-1-4244-5156-2","10.1109/IISWC.2009.5306785","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5306785","","Table lookup;Educational institutions;Binary codes;Instruction sets;Microarchitecture;Instruments;Hardware;Runtime;Application software;Performance analysis","binary codes","legacy binary code;ISA virtualization;microarchitectures;transparent binary instrumentation;dynamic binary translator performance;zero-overhead dynamic binary translation","","14","","30","IEEE","30 Oct 2009","","","IEEE","IEEE Conferences"
"Architectural studies of games engines — The quake series","J. Munro; C. Boldyreff; A. Capiluppi","Centre of Research on Open Source Software, Department of Computing, University of Lincoln, UK; School of Computing, Information Technology and Engineering, University of East London, UK; School of Computing, Information Technology and Engineering, University of East London, UK","2009 International IEEE Consumer Electronics Society's Games Innovations Conference","23 Oct 2009","2009","","","246","255","The presented approach constitutes a useful resource for games developers who wish to contribute to the further evolution of these games engines; and it provides insights into how the Quake engine architecture has evolved in practice since it was released as an open source project.","2166-675X","978-1-4244-4459-5","10.1109/ICEGIC.2009.5293600","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5293600","","Engines;Open source software;Computer architecture;Performance analysis;Software engineering;Application software;Information technology;Pattern analysis;Software architecture;Middleware","computer games;public domain software;software architecture","architectural studies;games engine;Quake series;open source communities;OSS game engine;Quake engine architecture","","5","","20","IEEE","23 Oct 2009","","","IEEE","IEEE Conferences"
"Software product line development: A review on practical issues and challenges","O. Dura; A. E. Yilmaz","S.T.M. Savunma Teknolojileri Muhendislik ve Ticaret, Ankara, Turkey; Department of Electronics Engineering, Faculty of Engineering, Ankara University, Ankara, Turkey","2009 24th International Symposium on Computer and Information Sciences","23 Oct 2009","2009","","","736","742","Software product line concept has been a key area of concern due to its impacts on reducing the costs and increasing the productivity by means of reuse maximization. The literature has a plethora of success stories about the software product lines. On the other hand, success in product line development requires specific techniques and methodologies at every step of the software development process. Moreover, a defect introduced in any step might have abnormally negative impact due to diffusion, if special care is not devoted. In this paper, with a different point of view, potential risks and hazards in case of `careless product line development' are discussed rather than the benefits of the product line.","","978-1-4244-5021-3","10.1109/ISCIS.2009.5291917","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5291917","","Project management;Product development;Costs;Personnel;Design engineering;Application software;Productivity;Programming;Hazards;Time to market","product development;software reusability","software product line development;reuse maximization;software development process","","1","","36","IEEE","23 Oct 2009","","","IEEE","IEEE Conferences"
"Lightweight Techniques for Tracking Unique Program Statements","J. Spacco; C. Williams","Department of Computer Science, Colgate University, Hamilton, NY, USA; Department of Computer Science, Pacific University, Forest Grove, OR, USA","2009 Ninth IEEE International Working Conference on Source Code Analysis and Manipulation","6 Oct 2009","2009","","","99","108","Previous work on tracking source locations has focused on tracking lines through multiple revisions of software. In this paper, we explore a new technique for tracking statements, rather than lines, across multiple revisions of Java source code. We show that our statement-tracking technique achieves comparable accuracy for source code than the most accurate line-tracking techniques, while also safely handling all non-executable formatting changes, such as breaking a single statement across many lines, adding or removing whitespace, moving brackets, or re-ordering methods. Finally, we compare the performance of three of the current state-of-the-art techniques for tracking lines across revisions on a series of benchmarks, and discuss the strengths and weaknesses of each technique.","","978-0-7695-3793-1","10.1109/SCAM.2009.19","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5279964","diff;line-tracking;levenshtein;differencing tools;mining software archives","Software tools;Computer science;Software debugging;Visualization;USA Councils;Position measurement;Java;Software standards;Robust control;Spine","Java","lightweight technique;unique program statement tracking;Java source code;line-tracking technique","","4","","18","IEEE","6 Oct 2009","","","IEEE","IEEE Conferences"
"Evolution of Type-1 Clones","N. Göde","University of Brethemen, Bremen, Germany","2009 Ninth IEEE International Working Conference on Source Code Analysis and Manipulation","6 Oct 2009","2009","","","77","86","It is useful to study the evolution of code clones to better understand the nature, effects, and reasons of cloning. There are different approaches that investigate multiple versions of a program and detect patterns in the evolution of clones. The shortcomings of these methods are that they require significant computational effort, are limited to detecting predefined patterns and are mostly based on heuristics. This paper presents an approach that models clone evolution based on the source code changes that were made between consecutive program versions. Instead of relating clone classes by predefined patterns, the focus is on how individual cloned fragments evolve. The model has been used to analyze different aspects of type-1 clone evolution in nine open-source systems. The empirical results show that the ratio of clones decreased in the majority of the systems and cloned fragments survived more than a year on average. It was found that -- depending on the system -- either consistent or inconsistent changes to clone classes were more frequent. Overall, the peculiarity of clone evolution is significantly different for each system, making general conclusions difficult.","","978-0-7695-3793-1","10.1109/SCAM.2009.17","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5279977","software clones;clone mapping;evolution model","Cloning;Open source software;Pattern analysis;Detectors;Algorithm design and analysis;History","configuration management;program diagnostics;software maintenance;software prototyping","type-1 clone;source code clone evolution;multiple program version;patterns;program pattern detection;source code change","","32","","18","IEEE","6 Oct 2009","","","IEEE","IEEE Conferences"
"Maintaining Fine-Grained Code Metadata Regardless of Moving, Copying and Merging","C. R. Prause","Schloss Birlinghoven, Fraunhofer FIT, Saint Petersburg, Russia","2009 Ninth IEEE International Working Conference on Source Code Analysis and Manipulation","6 Oct 2009","2009","","","109","118","Source code metadata on a file-level granularity is too coarse for certain applications. But fine-grained metadata (e.g. line-by-line authorship) easily gets lost due to changes like merging, moving or copying code. Enabling metadata to survive code evolution provides valuable insights into program source code. This helps developers to understand the sources and opens up opportunities for advanced tools. We present a concept that utilizes different search heuristics to identify probable ancestors of source documents, and pair this with clone detection to locate origins of inserted code. Arbitrary kinds of metadata can then be linked to code sections and be preserved automatically while code evolves. We evaluate our approach using code from the Hydra and FreeCol projects, and sketch prospective applications.","","978-0-7695-3793-1","10.1109/SCAM.2009.20","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5279957","code metadata;code evolution;document similarity;clone detection;code ownership","Merging;Databases;Cloning;Collaboration;History;Nearest neighbor searches;Open source software;Testing","meta data;programming","fine grained code metadata;source code metadata;file-level granularity;fine-grained metadata;code evolution;program source code;search heuristics;source documents;Hydra project;FreeCol project;sketch prospective application","","5","1","23","IEEE","6 Oct 2009","","","IEEE","IEEE Conferences"
"An Assessment of Type-3 Clones as Detected by State-of-the-Art Tools","R. Tiarks; R. Koschke; R. Falke","University of Brethemen, Bremen, Germany; University of Brethemen, Bremen, Germany; University of Brethemen, Bremen, Germany","2009 Ninth IEEE International Working Conference on Source Code Analysis and Manipulation","6 Oct 2009","2009","","","67","76","Code reuse through copying and pasting leads to so-called software clones. These clones can be roughly categorized into identical fragments (type-1 clones), fragments with parameter substitution (type-2 clones), and similar fragments that differ through modified,deleted, or added statements (type-3 clones). Although there has been extensive research on detecting clones, detection of type-3 clones is still an open research issue due to the inherent vaguenessin their definition. In this paper, we analyze type-3 clones detected by state-of-the-art tools and investigate type-3 clones in terms of their syntactic differences. Then, we derive their underlying semantic abstractions from their syntactic differences. Finally, we investigate whether there are any additional code characteristics that indicate that a tool-suggested clone candidate is a real type-3 clone from a human's perspective. Our findings can help developers of clone detectors to improve their tools.","","978-0-7695-3793-1","10.1109/SCAM.2009.16","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5279980","software clones;clone categorization;type-3 clones","Cloning;Detectors;Open source software;Software tools;Terminology;Stress;Taxonomy","programming;software reusability","type-3 clones;code reuse;software clones;identical fragments;type-1 clones;parameter substitution;type-2 clones;syntactic difference;semantic abstraction;code characteristics;clone detector","","21","","20","IEEE","6 Oct 2009","","","IEEE","IEEE Conferences"
"Concepts as Syntactic Sugar","V. David; M. Haveraaen","Institutt of Informatikk, Universitetet i Bergen, Norway; Institutt of Informatikk, Universitetet i Bergen, Norway","2009 Ninth IEEE International Working Conference on Source Code Analysis and Manipulation","6 Oct 2009","2009","","","147","156","The coming standard for C++ will contain language extensions. It can be expected that there will be some years between the release of the new standard and the time when most compilers will be compliant, like it happened for the 1998 standard. Concepts are an extension proposed for the new standard. We show how we can translate ConceptC++ code into pure C++03 using the C++ template mechanism. Such a translation tool could be used for example to port software written using a ConceptC++ compiler to architectures having only older compilers. Or a library written using concepts could be used by a project written in pure C++. The goal of this transformation is not to provide all capabilities of ConceptC++, but with restrictions we can afford, to be as simple as possible.","","978-0-7695-3793-1","10.1109/SCAM.2009.26","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5279923","","Concrete;Code standards;Software tools;Computer architecture;Software libraries;Writing;Object oriented programming;Dynamic programming","C++ language;program compilers","ConceptC++ code;C++03;ConceptC++ compiler;code translation tool","","3","","21","IEEE","6 Oct 2009","","","IEEE","IEEE Conferences"
"Automated Refactoring Suggestions Using the Results of Code Analysis Tools","S. Herbold; J. Grabowski; H. Neukirchen","Institute of Computer Science, University of Göttingen, Gottingen, Germany; Institute of Computer Science, University of Göttingen, Gottingen, Germany; Faculty of Industrial Engineering, Mechanical Engineering and Computer Science, University of Iceland, Reykjavik, Iceland","2009 First International Conference on Advances in System Testing and Validation Lifecycle","6 Oct 2009","2009","","","104","109","Static analysis tools are used for the detection of errors and other problems on . The detected problems related to the internal structure of a software can be removed by source code transformations called refactorings. To automate such source code transformations, refactoring tools are available. In modern integrated development environments, there is a gap between the static analysis tools and the refactoring tools. This paper presents an automated approach for the improvement of the internal quality of software by using the results of code analysis tools to call a refactoring tool to remove detected problems. The approach is generic, thus allowing the combination of arbitrary tools. As a proof of concept, this approach is implemented as a plug-in for the integrated development environment Eclipse.","","978-1-4244-4862-3","10.1109/VALID.2009.12","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5279916","Software verification and validation;Software inspection techniques;Software testing tools;Refactoring;Tool integration","Software tools;Java;Computer science;Inspection;Software metrics;System testing;Industrial engineering;Mechanical engineering;Computer errors;Software quality","program diagnostics;program verification;software maintenance;software quality;software tools","static code analysis tool;error detection;source code transformation;integrated development environment;refactoring tool;software internal quality;software verification;software validation","","1","3","20","IEEE","6 Oct 2009","","","IEEE","IEEE Conferences"
"Exploiting refactoring in formal verification","X. Yin; J. Knight; W. Weimer","Department of Computer Science, University of Virginia, USA; Department of Computer Science, University of Virginia, USA; Department of Computer Science, University of Virginia, USA","2009 IEEE/IFIP International Conference on Dependable Systems & Networks","29 Sep 2009","2009","","","53","62","In previous work, we introduced Echo, a new approach to the formal verification of the functional correctness of software. Part of what makes Echo practical is a technique called verification refactoring. The program to be verified is mechanically refactored specifically to facilitate verification. After refactoring, the program is documented with low-level annotations, and a specification is extracted mechanically. Proofs that the semantics of the refactored program are equivalent to those of the original program, that the code conforms to the annotations, and that the extracted specification implies the program's original specification constitute the verification argument. In this paper, we discuss verification refactoring and illustrate it with a case study of the verification of an optimized implementation of the advanced encryption standard (AES) against its official specification. We compare the practicality of verification using refactoring with traditional correctness proofs and refinement, and we assess its efficacy using seeded defects.","2158-3927","978-1-4244-4422-9","10.1109/DSN.2009.5270355","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5270355","","Formal verification;Programming;Cryptography;Application software;Computer science;Timing;Software systems;Humans;Software tools;Concrete","cryptography;formal specification;program verification;software maintenance","echo approach;formal verification;software refactoring;formal specification;AES;advanced encryption standard;official specification","","10","","17","IEEE","29 Sep 2009","","","IEEE","IEEE Conferences"
"Chainsaw: Using Binary Matching for Relative Instruction Mix Comparison","T. Moseley; D. Grunwald; R. Peri","Department of Computer Science, University of Colorado, Boulder, CO, USA; Department of Computer Science, University of Colorado, Boulder, CO, USA; Intel Corporation, Austin, TX, USA","2009 18th International Conference on Parallel Architectures and Compilation Techniques","25 Sep 2009","2009","","","125","135","With advances in hardware, instruction set architectures are undergoing continual evolution. As a result, compilers are under constant pressure to adapt and take full advantage of available features. However, current techniques for evaluating relative compiler performance only compare profiles at the application level, ignoring relative performance differences at finer granularities. To ensure that new features are put to good use, a more rigorous approach is necessary. A fundamental step in tuning compiler performance is identifying the specific examples that can be improved. To solve this problem, we present a compiler-independent binary matching technique to compare executions of differently compiled programs and identify intervals where the behavior can be meaningfully compared. Matched intervals can be automatically analyzed to identify anomalous segments of execution where one version performs significantly differently versus another. We present case studies using Chainsaw to identify significant performance anomalies between differently compiled codes.","1089-795X","978-0-7695-3771-9","10.1109/PACT.2009.12","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5260556","compilers;profiling;binary matching","Optimizing compilers;Program processors;Testing;Hardware;Instruction sets;Parallel architectures;Computer science;Computer architecture;Performance analysis;Frequency","instruction sets;pattern matching;program compilers;software architecture","Chainsaw;binary matching;relative instruction mix comparison;instruction set architectures;compilers","","1","1","24","IEEE","25 Sep 2009","","","IEEE","IEEE Conferences"
"Block-Based In-Place Replacement Strategy for x86 Sensitive Instructions in Virtual Machine","Y. Tan; W. Zhang; Q. Wu","Coll. of Comput., NUDT, Changsha, China; Coll. of Comput., NUDT, Changsha, China; Coll. of Comput., NUDT, Changsha, China","2009 IEEE International Symposium on Parallel and Distributed Processing with Applications","18 Aug 2009","2009","","","531","536","It is trendy that virtualization technology is adopted by server and desktop computers recently. Binary translation is an important method to implement full virtualization supporting any guest operating system without modification. Traditional methods use trap or interrupt to catch sensitive instruction's execution. Its performance is influenced by trap's context switch overhead. This article proposes a novel code scanning and replacing strategy, named as Block-based In-Place Replacement. BIPR tries to find a code block whose length is longer than 5 bytes and replaces the block with 5-bytes JMP instruction. The translated code block has same run-time mode as original code. As a result, BIPR's cost is lower than traditional trap methods. Moreover, it gives an optimize strategy, i.e. Super Block-based In-Place Replacement, to reduce unnecessary translation overhead of BIPR and get better performances. Experiment results prove that SBIPR performs pretty.","2158-9208","978-0-7695-3747-4","10.1109/ISPA.2009.33","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5207886","Binary Translation;Hypervisor;Block-based In-Place Replacement","Virtual machining;Switches;Virtual machine monitors;Computer aided instruction;Concurrent computing;Distributed computing;Operating systems;Educational institutions;Costs;Isolation technology","operating systems (computers);virtual machines","block-based inplace replacement strategy;x86 sensitive instructions;virtual machine;virtualization technology;binary translation;guest operating system;instruction execution;code scanning;code replacing strategy;translated code block","","","1","9","IEEE","18 Aug 2009","","","IEEE","IEEE Conferences"
"Detecting computer code plagiarism in higher education","M. Konecki; T. Orehovacki; A. Lovrencic","Faculty of Organization and Informatics, Croatia; Faculty of Organization and Informatics, Croatia; Faculty of Organization and Informatics, Croatia","Proceedings of the ITI 2009 31st International Conference on Information Technology Interfaces","7 Aug 2009","2009","","","409","414","Rapid development of industry and economy requires quick and efficient education of large amount of theoretical knowledge and practical skills. In computer science, especially in programming, this trend is very noticeable and real experts are needed and hard to create. But new problem has emerged in higher education and its name is plagiarism. In order to prevent this one would have to check all students program codes to find similarities. To do this efficiently a procedure has been designed upon which a certain prototype was developed and tested. We discuss efficiency of this solution and we also mention some other methods and algorithms. We also discuss some other possible usages of this solution and we mention further actions and steps in our research.","1330-1012","978-953-7138-15-8","10.1109/ITI.2009.5196118","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5196118","plagiarism detection;program code;comparison;higher education","Plagiarism;Computer science education;Programming profession;Educational programs;Fingerprint recognition;Cloning;Informatics;Computer science;Prototypes;Testing","computer science education;copyright;further education;programming","computer code plagiarism detection;higher education;computer science;program codes","","1","","14","","7 Aug 2009","","","IEEE","IEEE Conferences"
"Using Declarative Meta Programming for Design Flaws Detection in Object-Oriented Software","S. Mekruksavanich; P. Muenchaisri","Center of Excellence in Software Engineering, Department of Computer Engineering, Faculty of Engineering, Chulalongkom University, Bangkok, Thailand; Center of Excellence in Software Engineering, Department of Computer Engineering, Faculty of Engineering, Chulalongkom University, Bangkok, Thailand","2009 International Conference on Signal Processing Systems","17 Jul 2009","2009","","","502","507","Nowadays, many software developers and maintainers encounter with incomprehensible, unexpandable and unchangeable program structures that consequently reduce software quality. Such problems come from poor design and poor programming called design flaws. Design flaws are program properties that indicate a potentially deficient design of a software system. It can increase the software maintenance cost drastically. Therefore detection of these flaws is necessary. This paper proposes a declarative-based approach in which the design flaws of an object-oriented system can be detected at the meta-level in the declarative meta programming. We apply our approach to detect some well-known design flaws, and the results show that the proposed approach is able to detect those flaws.","","978-0-7695-3654-5","10.1109/ICSPS.2009.143","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5166838","Object-oriented design;Design flaws;Declarative Meta Programming;Software maintenance","Object oriented programming;Software quality;Software maintenance;Logic programming;Software design;Software systems;Maintenance engineering;Design engineering;Inspection;Signal processing","object-oriented programming;software quality","declarative meta programming;design flaws detection;object-oriented software;software quality;software system design","","14","","16","IEEE","17 Jul 2009","","","IEEE","IEEE Conferences"
"Embedded software compression with Split Echo Instructions","Iver Stubdal; Arda Karaduman; Hideharu Amano","Amano Laboratory, Keio University, Tokyo, Japan; Amano Laboratory, Keio University, Tokyo, Japan; Amano Laboratory, Keio University, Tokyo, Japan","2009 IEEE 13th International Symposium on Consumer Electronics","6 Jul 2009","2009","","","816","818","Program code size is a continuing concern in modern embedded devices. Echo instructions have been proposed as a hardware-supported method for reducing code size. This paper presents a new type of Echo Instruction, Split Echo, and evaluates an implementation based on the MIPS R3000 architecture.","2159-1423","978-1-4244-2975-2","10.1109/ISCE.2009.5157058","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5157058","","Embedded software;Linear discriminant analysis;Laboratories;Pervasive computing;Consumer electronics;Embedded computing;Embedded system;Instruction sets;Binary codes;Computer architecture","data compression;embedded systems;program compilers","embedded software compression;split echo instruction;program code size;embedded device;hardware-supported method;code size reduction;MIPS R3000 architecture","","","","12","IEEE","6 Jul 2009","","","IEEE","IEEE Conferences"
"Predictive Simulation of HPC Applications","S. D. Hammond; J. A. Smith; G. R. Mudalige; S. A. Jarvis","High Performance Systems Group, University of Warwick, Coventry, UK; High Performance Systems Group, University of Warwick, Coventry, UK; High Performance Systems Group, University of Warwick, Coventry, UK; High Performance Systems Group, University of Warwick, Coventry, UK","2009 International Conference on Advanced Information Networking and Applications","19 Jun 2009","2009","","","33","40","The architectures which support modern supercomputing machinery are as diverse today, as at any point during the last twenty years. The variety of processor core arrangements, threading strategies and the arrival of heterogeneous computation nodes are driving modern-day solutions to petaflop speeds. The increasing complexity of such systems, as well as codes written to take advantage of the new computational abilities, pose significant frustrations for existing techniques which aim to model and analyze the performance of such hardware and software. In this paper we demonstrate the use of post-execution analysis on trace-based profiles to support the construction of simulation-based models. This involves combining the runtime capture of call-graph information with computational timings, which in turn allows representative models of code behavior to be extracted. The main advantage of this technique is that it largely automates performance model development, a burden associated with existing techniques. We demonstrate the capabilities of our approach using both the NAS Parallel Benchmark suite and a real-world supercomputing benchmark developed by the United Kingdom Atomic Weapons Establishment. The resulting models, developed in less than two hours per code, have a good degree of predictive accuracy. We also show how one of these models can be used to explore the performance of the code on over 16,000 cores, demonstrating the scalability of our solution.","2332-5658","978-1-4244-4000-9","10.1109/AINA.2009.95","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5076178","Performance Prediction;Simulation;High Performance Computing;Profiling;Trace-Driven","Predictive models;Computational modeling;Computer architecture;Machinery;Performance analysis;Hardware;Software performance;Analytical models;Runtime;Timing","parallel architectures;parallel machines;program processors","predictive simulation;HPC applications;supercomputing;processor core arrangements;threading strategies;heterogeneous computation nodes;petaflop speeds;post-execution analysis;trace-based profiles;call-graph information","","1","","26","IEEE","19 Jun 2009","","","IEEE","IEEE Conferences"
"Vector space analysis of software clones","S. Grant; J. R. Cordy","School of Computing, Queen's University, Kingston, ONT, Canada; School of Computing, Queen's University, Kingston, ONT, Canada","2009 IEEE 17th International Conference on Program Comprehension","19 Jun 2009","2009","","","233","237","In this paper, we introduce a technique for applying independent component analysis to vector space representations of software code fragments such as methods or blocks. The distance between these points can be determined, and used as a measure of the similarity between the original source code fragments they represent. It can be reasoned that if the initial matrix representation contains enough information about the syntactic structure of the source code, the vector space representation will be sufficient to predict the similarity of fragments to one another, and can provide the likelihood that the code is a clone.","1092-8138","978-1-4244-3998-0","10.1109/ICPC.2009.5090048","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5090048","","Functional analysis;Cloning;Independent component analysis;Indexing;Large scale integration;Blind source separation;Data mining;Microphones;Decorrelation;Software maintenance","independent component analysis;software engineering;source coding;vectors","vector space analysis;software clones;independent component analysis;software code fragment;source code fragments;vector space representation","","13","","17","IEEE","19 Jun 2009","","","IEEE","IEEE Conferences"
"Syntax tree fingerprinting for source code similarity detection","M. Chilowicz; E. Duris; G. Roussel","Laboratoire d'Informatique de l'Institut Gaspard-Monge, UMR CNRS 8049, Université Paris-Est, Marne-la-Vallee, France; Laboratoire d'Informatique de l'Institut Gaspard-Monge, UMR CNRS 8049, Université Paris-Est, Marne-la-Vallee, France; Laboratoire d'Informatique de l'Institut Gaspard-Monge, UMR CNRS 8049, Université Paris-Est, Marne-la-Vallee, France","2009 IEEE 17th International Conference on Program Comprehension","19 Jun 2009","2009","","","243","247","Numerous approaches based on metrics, token sequence pattern-matching, abstract syntax tree (AST) or program dependency graph (PDG) analysis have already been proposed to highlight similarities in source code: in this paper we present a simple and scalable architecture based on AST fingerprinting. Thanks to a study of several hashing strategies reducing false-positive collisions, we propose a framework that efficiently indexes AST representations in a database, that quickly detects exact (w.r.t source code abstraction) clone clusters and that easily retrieves their corresponding ASTs. Our aim is to allow further processing of neighboring exact matches in order to identify the larger approximate matches, dealing with the common modification patterns seen in the intra-project copy-pastes and in the plagiarism cases.","1092-8138","978-1-4244-3998-0","10.1109/ICPC.2009.5090050","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5090050","","Fingerprint recognition;Cloning;Databases;Plagiarism;Software maintenance;Scalability;Pattern analysis;Indexes;Information retrieval;Pattern matching","cryptography;database indexing;pattern matching;program diagnostics;software metrics;tree data structures","source code similarity detection;software metrics;token sequence pattern-matching;abstract syntax tree fingerprinting;program dependency graph analysis;hash strategy;false-positive collision;database indexing;source code abstraction;clone cluster;plagiarism;intra-project copy-paste","","48","2","24","IEEE","19 Jun 2009","","","IEEE","IEEE Conferences"
"CnP: Towards an environment for the proactive management of copy-and-paste programming","D. Hou; P. Jablonski; F. Jacob","Electrical and Computer Engineering, Clarkson University, Potsdam, NY, USA; Electrical and Computer Engineering, Clarkson University, Potsdam, NY, USA; Electrical and Computer Engineering, Clarkson University, Potsdam, NY, USA","2009 IEEE 17th International Conference on Program Comprehension","19 Jun 2009","2009","","","238","242","Programmers copy and paste code for many reasons. Regardless of the specific reasons, similar code fragments (clones) are introduced into software systems. Like other software artifacts, clones may require attention and effort from programmers so that they can be understood, and correctly adapted and evolved. More specifically, when understanding and maintaining clones, programmers need to know where the clones are. Programmers also need to compare and contrast code clones in order to figure out how they correspond and differ. Finally, they also need to edit or remove clones. In addition to what clone detection-based tools can offer, more automated support is needed to better assist programmers in these activities. In this paper, we introduce a toolkit CnP that is aimed to support and manage clones proactively as they are created and evolved. We describe the initial features and the design decisions taken in CnP. We also discuss possible future design extension.","1092-8138","978-1-4244-3998-0","10.1109/ICPC.2009.5090049","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5090049","","Environmental management;Cloning;Programming profession;Jacobian matrices;Software systems;Engineering management","programming;software maintenance;software management","CnP toolkit;copy-and-paste programming;proactive management;software system;software artifact;clone maintenance;clone detection-based tool","","22","3","18","IEEE","19 Jun 2009","","","IEEE","IEEE Conferences"
"Crosscutting patterns and design stability: An exploratory analysis","E. Figueiredo; B. Silva; C. Sant'Anna; A. Garcia; J. Whittle; D. Nunes","Computing Department, Lancaster University, United Kingdom; Institute of Informatics, Federal University of Rio Grande do Sul, Brazil; Computer Science Department, Federal University of Bahia (UFBA), Brazil; Software Engineering Laboratory, Catholic University of Rio de Janeiro, Brazil; Computing Department, Lancaster University, United Kingdom; Institute of Informatics, Federal University of Rio Grande do Sul, Brazil","2009 IEEE 17th International Conference on Program Comprehension","19 Jun 2009","2009","","","138","147","It is often claimed that inaccurate modularisation of crosscutting concerns hinders program comprehension and, as a consequence, leads to harmful software instabilities. However, recent studies have pointed out that crosscutting concerns are not always harmful to design stability. Hence, software maintainers would benefit from well documented patterns of crosscutting concerns and a better understanding about their actual impact on design stability. This paper presents a catalogue of crosscutting concern patterns recurrently observed in software systems. These patterns are described and classified based on an intuitive vocabulary that facilitates their recognition by software engineers. We analysed instances of the crosscutting patterns in object-oriented and aspect-oriented versions of three evolving programs. The outcomes of our exploratory evaluation indicated that: (i) a certain category of crosscutting patterns seems to be good indicator of harmful instabilities, and (ii) aspect-oriented solutions were unable to modularise concerns matching some crosscutting patterns.","1092-8138","978-1-4244-3998-0","10.1109/ICPC.2009.5090037","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5090037","","Stability analysis;Pattern analysis;Software systems;Software maintenance;Scattering;Informatics;Computer science;Software engineering;Laboratories;Vocabulary","object-oriented programming;software engineering","crosscutting patterns;design stability;exploratory analysis;software instabilities;intuitive vocabulary;aspect-oriented solutions","","20","","24","IEEE","19 Jun 2009","","","IEEE","IEEE Conferences"
"Towards Adapting Web Services for Multiple Devices","G. Ortiz; A. G. de Prado","Quercus Software Engineering Group, UEX, Mérida, Spain; NA","2009 Fourth International Conference on Internet and Web Applications and Services","12 Jun 2009","2009","","","292","297","Web services have become extremely important when offering services through the Internet. However, current Web Services are very inflexible as regards their invocation from different types of device, especially when taking into account their adaptation when being invoked from a mobile device. In this paper, we propose several alternatives for the creation of flexible Web services which can be invoked from different types of device. Besides, in order to reduce the impact of service adaption aspect-oriented programming has been used in all proposalspsila implementation.","","978-1-4244-3851-8","10.1109/ICIW.2009.49","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5072534","Web Services;Mobile Devices;Aspect-Oriented Programming","Web services;Books;Personal digital assistants;Mobile handsets;Portable computers;Web and internet services;Proposals;Mobile computing;Computer displays;Runtime environment","Internet;mobile computing;mobile radio;object-oriented programming","Web service;Internet;mobile device;aspect-oriented programming","","3","","20","IEEE","12 Jun 2009","","","IEEE","IEEE Conferences"
"ClemanX: Incremental clone detection tool for evolving software","T. T. Nguyen; H. A. Nguyen; N. H. Pham; J. M. Al-Kofahi; T. N. Nguyen","Iowa State University, USA; Iowa State University, USA; Iowa State University, USA; Iowa State University, USA; Iowa State University, USA","2009 31st International Conference on Software Engineering - Companion Volume","12 Jun 2009","2009","","","437","438","Recent research results have shown more benefits of the management of code clones, rather than detecting and removing them. However, existing clone management approaches are still unsatisfactory, and either incomplete or inefficient, due to the lack of incremental clone detection tool supports. In this paper, we introduce such an incremental clone detection tool, called ClemanX. Our empirical evaluation on real-world software projects shows that ClemanX is highly efficient, complete, precise, and is capable of working incrementally when the code changes.","","978-1-4244-3495-4","10.1109/ICSE-COMPANION.2009.5071050","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5071050","","Cloning;Software tools;Feature extraction;Project management;Character generation","program diagnostics;software maintenance","ClemanX incremental clone detection tool;software evolution analysis;code clone management;real-world software project","","3","","8","IEEE","12 Jun 2009","","","IEEE","IEEE Conferences"
"Visual exploration of large-scale evolving software","R. Wettel","REVEAL at Faculty of Informatics, University of Lugano, Switzerland","2009 31st International Conference on Software Engineering - Companion Volume","12 Jun 2009","2009","","","391","394","The comprehensive understanding of today's software systems is a daunting activity, because of the sheer size and complexity that such systems exhibit. Moreover, software systems evolve, which dramatically increases the amount of data one needs to analyze in order to gain insights into such systems. Indeed, software complexity is recognized as one of the major challenges to the development and maintenance of industrial-size software projects. Our vision is a 3D visualization approach which helps software engineers build knowledge about their systems. We settled on an intuitive metaphor, which depicts software systems as cities. To validate the ideas emerging from our research, we implemented a tool called CodeCity. We devised a set of visualization techniques to support tasks related to program comprehension, design quality assessment, and evolution analysis, and applied them on large open-source systems written in Java, C++, or Smalltalk. Our next research goals are enriching our metaphor with meaningful representations for relations and encoding higher-level information.","","978-1-4244-3495-4","10.1109/ICSE-COMPANION.2009.5071029","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5071029","","Large-scale systems;Software systems;Software maintenance;Computer industry;Data visualization;Knowledge engineering;Cities and towns;Quality assessment;Open source software;Java","C++ language;Java;program visualisation;project management;public domain software;reverse engineering;Smalltalk;software maintenance;software metrics;software quality","software system;software complexity;software development;software maintenance;industrial-size software project;3D visualization;CodeCity;program comprehension;design quality assessment;software evolution;open-source system;Java;C++ language;Smalltalk","","9","","21","IEEE","12 Jun 2009","","","IEEE","IEEE Conferences"
"Codebook: Social networking over code","A. Begel; R. DeLine","Microsoft Research Limited, USA; Microsoft Research Limited, USA","2009 31st International Conference on Software Engineering - Companion Volume","12 Jun 2009","2009","","","263","266","Social networking systems help people maintain connections to their friends, enabling awareness, communication, and collaboration, especially at a distance. In many studies of coordination in software engineering, the work artifacts, e.g. code, bugs, specifications, are themselves the objects that link engineers together. In this paper, we introduce Codebook, a social networking Web service in which people can be ldquofriendsrdquo not only with other people but with the work artifacts they share with them. Providing a Web interface to the graph of these connections will enable software engineers to keep track of task dependencies, discover and maintain connections to other teams, and understand the history and rationale behind the code that they work on and use.","","978-1-4244-3495-4","10.1109/ICSE-COMPANION.2009.5070997","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5070997","","Bridges;Computer bugs;Electronic mail;Software;Social network services;History;Data mining","social networking (online);software engineering;user interfaces;Web services","social networking system;software engineering;Codebook;Web service;work artifact;Web interface;task dependency","","15","1","12","IEEE","12 Jun 2009","","","IEEE","IEEE Conferences"
"Detecting inefficient API usage","D. Kawrykow; M. P. Robillard","School of Computer Science, McGill University, Montreal, QUE, Canada; School of Computer Science, McGill University, Montreal, QUE, Canada","2009 31st International Conference on Software Engineering - Companion Volume","12 Jun 2009","2009","","","183","186","Large software projects often rely on third-party libraries, made accessible through application programming interfaces (APIs). We have observed many cases where APIs are used in ways that are not efficient. We developed a technique to automatically detect inefficient API usage in software projects. The main hypothesis underlying the technique is that client code that imitates the behavior of a library method without calling it is likely not to use the library as efficiently as possible. In addition to warning developers of potentially inefficient API usage, our technique also indicates how to improve the use of the API. Application of the technique on Java open-source systems revealed many cases of inefficient API usage, and corresponding recommendations that led to code improvements.","","978-1-4244-3495-4","10.1109/ICSE-COMPANION.2009.5070977","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5070977","","Software libraries;Java;Application software;Open source software;Uniform resource locators;Computer science;Software systems;Functional programming;Runtime library;Computer languages","application program interfaces;Java","application programming interface;API;software project;Java open-source system","","5","","10","IEEE","12 Jun 2009","","","IEEE","IEEE Conferences"
"COMPASS: A Community-driven Parallelization Advisor for Sequential Software","S. Sethumadhavan; N. Arora; R. B. Ganapathi; J. Demme; G. E. Kaiser","Department of Computer Science, Columbia University, NY, USA; Department of Computer Science, Columbia University, NY, USA; Department of Computer Science, Columbia University, NY, USA; Department of Computer Science, Columbia University, NY, USA; Department of Computer Science, Columbia University, NY, USA","2009 ICSE Workshop on Multicore Software Engineering","12 Jun 2009","2009","","","41","48","The widespread adoption of multicores has renewed the emphasis on the use of parallelism to improve performance. The present and growing diversity in hardware architectures and software environments, however, continues to pose difficulties in the effective use of parallelism thus delaying a quick and smooth transition to the concurrency era. In this paper, we describe the research being conducted at Columbia University on a system called COMPASS that aims to simplify this transition by providing advice to programmers while they reengineer their code for parallelism. The advice proffered to the programmer is based on the wisdom collected from programmers who have already parallelized some similar code. The utility of COMPASS rests, not only on its ability to collect the wisdom unintrusively but also on its ability to automatically seek, find and synthesize this wisdom into advice that is tailored to the task at hand, i.e., the code the user is considering parallelizing and the environment in which the optimized program is planned to execute. COMPASS provides a platform and an extensible framework for sharing human expertise about code parallelization - widely, and on diverse hardware and software. By leveraging the ldquowisdom of crowdsrdquo model [30], which has been conjectured to scale exponentially and which has successfully worked for wikis, COMPASS aims to enable rapid propagation of knowledge about code parallelization in the context of the actual parallelization reengineering, and thus continue to extend the benefits of Moores law scaling to science and society.","","978-1-4244-3718-4","10.1109/IWMSE.2009.5071382","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5071382","","Programming profession;Parallel processing;Multicore processing;Hardware;Parallel programming;Databases;Software performance;Computer science;Computer architecture;Delay effects","optimising compilers;parallel programming;parallelising compilers;systems re-engineering","COMPASS;community-driven parallelization advisor;sequential software;optimized program;sequential code parallelization reengineering;Moores law","","3","","30","IEEE","12 Jun 2009","","","IEEE","IEEE Conferences"
"Using Open Source Tools to Prevent Write-Only Code","S. Loveland","Department of Computer Science, Adams State College, USA","2009 Sixth International Conference on Information Technology: New Generations","10 Jun 2009","2009","","","671","677","This paper describes how the open-source tools Checkstyle, PMD, FindBugs, and Jupiter have been incorporated into the beginning programming course at Adams State College. The tools have helped students develop better software development skills and have improved the performance of the instructor in the code evaluation process which in turn helps students become better software engineers.","","978-1-4244-3770-2","10.1109/ITNG.2009.75","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5070697","","Educational institutions;Testing;Open source software;Education;Software engineering;Programming;Software tools;Writing;Robustness;Computer industry","computer science education;educational courses;educational institutions;program debugging;public domain software;software tools","open source tools;write-only code prevention;Checkstyle;PMD;FindBugs;Jupiter;beginning programming course;Adams State College;software development skills;code evaluation process;software engineers","","2","","25","IEEE","10 Jun 2009","","","IEEE","IEEE Conferences"
"Complete and accurate clone detection in graph-based models","N. H. Pham; H. A. Nguyen; T. T. Nguyen; J. M. Al-Kofahi; T. N. Nguyen","Electrical and Computer Engineering Department, Iowa State University, USA; Electrical and Computer Engineering Department, Iowa State University; Electrical and Computer Engineering Department, Iowa State University; Electrical and Computer Engineering Department, Iowa State University, USA; Electrical and Computer Engineering Department, Iowa State University, USA","2009 IEEE 31st International Conference on Software Engineering","10 Jun 2009","2009","","","276","286","Model-Driven Engineering (MDE) has become an important development framework for many large-scale software. Previous research has reported that as in traditional code-based development, cloning also occurs in MDE. However, there has been little work on clone detection in models with the limitations on detection precision and completeness. This paper presents ModelCD, a novel clone detection tool for Matlab/Simulink models, that is able to efficiently and accurately detect both exactly matched and approximate model clones. The core of ModelCD is two novel graph-based clone detection algorithms that are able to systematically and incrementally discover clones with a high degree of completeness, accuracy, and scalability. We have conducted an empirical evaluation with various experimental studies on many real-world systems to demonstrate the usefulness of our approach and to compare the performance of ModelCD with existing tools.","1558-1225","978-1-4244-3453-4","10.1109/ICSE.2009.5070528","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5070528","","Cloning;Mathematical model;Model driven engineering;Large-scale systems;Detection algorithms;Software tools;Costs;Scalability;Software design;Aerospace electronics","graph theory;mathematics computing;software engineering;software tools","clone detection;graph-based models;model-driven engineering;code-based development;ModelCD;Matlab-Simulink models","","63","3","30","IEEE","10 Jun 2009","","","IEEE","IEEE Conferences"
"Discovering and representing systematic code changes","M. Kim; D. Notkin","Electrical and Computer Engineering, University of Texas, Austin, Austin, TX, USA; Computer Science & Engineering, University of Washington, Seattle, WA, USA","2009 IEEE 31st International Conference on Software Engineering","10 Jun 2009","2009","","","309","319","Software engineers often inspect program differences when reviewing others' code changes, when writing check-in comments, or when determining why a program behaves differently from expected behavior after modification. Program differencing tools that support these tasks are limited in their ability to group related code changes or to detect potential inconsistencies in those changes. To overcome these limitations and to complement existing approaches, we built Logical Structural Diff (LSdiff), a tool that infers systematic structural differences as logic rules. LSdiff notes anomalies from systematic changes as exceptions to the logic rules. We conducted a focus group study with professional software engineers in a large E-commerce company; we also compared LSdiff's results with textual differences and with structural differences without rules. Our evaluation suggests that LSdiff complements existing differencing tools by grouping code changes that form systematic change patterns regardless of their distribution throughout the code, and its ability to discover anomalies shows promise in detecting inconsistent changes.","1558-1225","978-1-4244-3453-4","10.1109/ICSE.2009.5070531","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5070531","","Programming profession;Logic;Computer science;Pervasive computing;Tree graphs;Flow graphs;Packaging;Writing;Software tools;Computer bugs","software maintenance","systematic code change discovery;software engineering;check-in comment;program differencing tool;logical structural diff tool;logic rule","","111","2","33","IEEE","10 Jun 2009","","","IEEE","IEEE Conferences"
"Listening to programmers — Taxonomies and characteristics of comments in operating system code","Y. Padioleau; Lin Tan; Y. Zhou","University of Illinois, Urbana-Champaign, USA; University of Illinois, Urbana-Champaign, USA; University of Illinois, Urbana-Champaign, USA","2009 IEEE 31st International Conference on Software Engineering","10 Jun 2009","2009","","","331","341","Innovations from multiple directions have been proposed to improve software reliability. Unfortunately, many of the innovations are not fully exploited by programmers. To bridge the gap, this paper proposes a new approach to “listen” to thousands of programmers: studying their programming comments. Since comments express programmers' assumptions and intentions, comments can reveal programmers' needs, which can provide guidance (1) for language/-tool designers on where they should develop new techniques or enhance the usability of existing ones, and (2) for programmers on what problems are most pervasive and important so that they should take initiatives to adopt some existing tools or language extensions. We studied 1050 comments randomly sampled from the latest versions of Linux, FreeBSD, and OpenSolaris. We found that 52.6% of these comments could be leveraged by existing or to-be-proposed tools for improving reliability. Our findings include: (1) many comments describe code relationships, code evolutions, or the usage and meaning of integers and integer macros, (2) a significant amount of comments could be expressed by existing annotation languages, and (3) many comments express synchronization related concerns but are not well supported by annotation languages.","1558-1225","978-1-4244-3453-4","10.1109/ICSE.2009.5070533","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5070533","","Programming profession;Taxonomy;Operating systems;Computer languages;Technological innovation;Software reliability;Usability;Linux;Bridges;Computer bugs","Linux;operating systems (computers);software reliability","operating system code;software reliability;Linux;FreeBSD;OpenSolaris","","45","","37","IEEE","10 Jun 2009","","","IEEE","IEEE Conferences"
"CloneDetective - A workbench for clone detection research","E. Juergens; F. Deissenboeck; B. Hummel","Institut für Informatik, Technische Universität München, Munchen, Germany; Institut für Informatik, Technische Universität München, Munchen, Germany; Institut für Informatik, Technische Universität München, Munchen, Germany","2009 IEEE 31st International Conference on Software Engineering","10 Jun 2009","2009","","","603","606","The area of clone detection has considerably evolved over the last decade, leading to approaches with better results, but at the same time using more elaborate algorithms and tool chains. In our opinion a level has been reached, where the initial investment required to setup a clone detection tool chain and the code infrastructure required for experimenting with new heuristics and algorithms seriously hampers the exploration of novel solutions or specific case studies. As a solution, this paper presents CloneDetective, an open source framework and tool chain for clone detection, which is especially geared towards configurability and extendability and thus supports the preparation and conduction of clone detection research.","1558-1225","978-1-4244-3453-4","10.1109/ICSE.2009.5070566","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5070566","","Cloning;Phase detection;Software maintenance;Detectors;Plagiarism;Investments;Heuristic algorithms;Filtering;Recommender systems;Detection algorithms","program verification;software maintenance","CloneDetective workbench;clone detection tool chain;code infrastructure;open source framework;software maintenance;software evolution;program correctness","","63","","18","IEEE","10 Jun 2009","","","IEEE","IEEE Conferences"
"Do code clones matter?","E. Juergens; F. Deissenboeck; B. Hummel; S. Wagner","Institut für Informatik, Technische Universität München, Garching, Germany; Institut für Informatik, Technische Universität München, Garching, Germany; Institut für Informatik, Technische Universität München, Garching, Germany; Institut für Informatik, Technische Universität München, Garching, Germany","2009 IEEE 31st International Conference on Software Engineering","10 Jun 2009","2009","","","485","495","Code cloning is not only assumed to inflate maintenance costs but also considered defect-prone as inconsistent changes to code duplicates can lead to unexpected behavior. Consequently, the identification of duplicated code, clone detection, has been a very active area of research in recent years. Up to now, however, no substantial investigation of the consequences of code cloning on program correctness has been carried out. To remedy this shortcoming, this paper presents the results of a large-scale case study that was undertaken to find out if inconsistent changes to cloned code can indicate faults. For the analyzed commercial and open source systems we not only found that inconsistent changes to clones are very frequent but also identified a significant number of faults induced by such changes. The clone detection tool used in the case study implements a novel algorithm for the detection of inconsistent clones. It is available as open source to enable other researchers to use it as basis for further investigations.","1558-1225","978-1-4244-3453-4","10.1109/ICSE.2009.5070547","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5070547","","Cloning;Costs;Large-scale systems;Fault diagnosis;Software maintenance;Open source software;Java;Detection algorithms;Software quality;Software engineering","program compilers;program verification;public domain software;software fault tolerance;software maintenance","maintenance cost;defect-prone;code cloning;code duplication;clone detection;program correctness;commercial system;open source system;system faults","","242","","34","IEEE","10 Jun 2009","","","IEEE","IEEE Conferences"
"Improving software quality via code searching and mining","M. R. Marri; S. Thummalapenta; T. Xie","Department of Computer Science, North Carolina State University, USA; Department of Computer Science, North Carolina State University, USA; Department of Computer Science, North Carolina State University, USA","2009 ICSE Workshop on Search-Driven Development-Users, Infrastructure, Tools and Evaluation","10 Jun 2009","2009","","","33","36","Enormous amount of open source code is available on the Internet and various code search engines (CSE) are available to serve as a means for searching in open source code. However, usage of CSEs is often limited to simple tasks such as searching for relevant code examples. In this paper, we present a generic life-cycle model that can be used to improve software quality by exploiting CSEs. We present three example software development tasks that can be assisted by our life-cycle model and show how these three tasks can contribute to improve the software quality. We also show the application of our life-cycle model with a preliminary evaluation.","","978-1-4244-3740-5","10.1109/SUITE.2009.5070018","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5070018","","Software quality;Internet;Search engines;Computer science;Application software;Programming profession;Open source software;Automatic programming;Pattern analysis;Large-scale systems","Internet;public domain software;search engines;software quality","software quality;open source code;code search engines;generic life-cycle model;software development tasks","","8","","10","IEEE","10 Jun 2009","","","IEEE","IEEE Conferences"
"On the evaluation of recommender systems with recorded interactions","R. Robbes","REVEAL Faculty of Informatics, University of Lugano, Switzerland","2009 ICSE Workshop on Search-Driven Development-Users, Infrastructure, Tools and Evaluation","10 Jun 2009","2009","","","45","48","Recommender systems are Integrated Development Environment (IDE) extensions which assist developers in the task of coding. However, since they assist specific aspects of the general activity of programming, their impact is hard to assess. In previous work, we used with success an evaluation strategy using automated benchmarks to automatically and precisely evaluate several recommender systems, based on recording and replaying developer interactions. In this paper, we highlight the challenges we expect to encounter while applying this approach to other recommender systems.","","978-1-4244-3740-5","10.1109/SUITE.2009.5070021","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5070021","","Recommender systems;Protocols;Error correction codes;Productivity;Software systems;Informatics;Navigation;Programming profession;Performance evaluation;Computer languages","information filters","recommender systems;recorded interactions;integrated development environment","","2","","13","IEEE","10 Jun 2009","","","IEEE","IEEE Conferences"
"Code siblings: Technical and legal implications of copying code between applications","D. M. German; M. Di Penta; Y. -G. Gueheneuc; G. Antoniol","University of Victoria, Victoria, BC, Canada; RCOST, University of Sannio, Benevento, Italy; PTIDEJ Team-SOCCER Laboratory, DGIGL, École Polytechnique de Montréal, QUE, Canada; PTIDEJ Team-SOCCER Laboratory, DGIGL, École Polytechnique de Montréal, QUE, Canada","2009 6th IEEE International Working Conference on Mining Software Repositories","5 Jun 2009","2009","","","81","90","Source code cloning does not happen within a single system only. It can also occur between one system and another. We use the term code sibling to refer to a code clone that evolves in a different system than the code from which it originates. Code siblings can only occur when the source code copyright owner allows it and when the conditions imposed by such license are not incompatible with the license of the destination system. In some situations copying of source code fragments are allowed—legally—in one direction, but not in the other. In this paper, we use clone detection, license mining and classification, and change history techniques to understand how code siblings—under different licenses—flow in one direction or the other between Linux and two BSD Unixes, FreeBSD and OpenBSD. Our results show that, in most cases, this migration appears to happen according to the terms of the license of the original code being copied, favoring always copying from less restrictive licenses towards more restrictive ones. We also discovered that sometimes code is inserted to the kernels from an outside source.","2160-1860","978-1-4244-3493-0","10.1109/MSR.2009.5069483","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5069483","Code licensing;software evolution;clone detection","Law;Legal factors;Licenses;Cloning;Kernel;Linux;History;Software debugging;Robustness;Hardware","Linux;source coding","code siblings;source code cloning;source code fragments;clone detection;license mining;Linux;BSD Unixes;FreeBSD;OpenBSD","","52","","26","IEEE","5 Jun 2009","","","IEEE","IEEE Conferences"
"MapReduce as a general framework to support research in Mining Software Repositories (MSR)","Weiyi Shang; Zhen Ming Jiang; B. Adams; A. E. Hassan","Software Analysis and Intelligence Laboratory (SAIL, Queen''s University, Kingston, Canada; Software Analysis and Intelligence Laboratory (SAIL, Queen''s University, Kingston, Canada; Software Analysis and Intelligence Laboratory (SAIL, Queen''s University, Kingston, Canada; Software Analysis and Intelligence Laboratory (SAIL, Queen''s University, Kingston, Canada","2009 6th IEEE International Working Conference on Mining Software Repositories","5 Jun 2009","2009","","","21","30","Researchers continue to demonstrate the benefits of Mining Software Repositories (MSR) for supporting software development and research activities. However, as the mining process is time and resource intensive, they often create their own distributed platforms and use various optimizations to speed up and scale up their analysis. These platforms are project-specific, hard to reuse, and offer minimal debugging and deployment support. In this paper, we propose the use of MapReduce, a distributed computing platform, to support research in MSR. As a proof-of-concept, we migrate J-REX, an optimized evolutionary code extractor, to run on Hadoop, an open source implementation of MapReduce. Through a case study on the source control repositories of the Eclipse, BIRT and Datatools projects, we demonstrate that the migration effort to MapReduce is minimal and that the benefits are significant, as running time of the migrated J-REX is only 30% to 50% of the original J-REX's. This paper documents our experience with the migration, and highlights the benefits and challenges of the MapReduce framework in the MSR community.","2160-1860","978-1-4244-3493-0","10.1109/MSR.2009.5069477","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5069477","","Linux;Workstations;Software performance;Software systems;Data mining;Programming;Debugging;Distributed computing;Kernel;Scalability","data mining;distributed algorithms;distributed programming;evolutionary computation;public domain software;software engineering","mining software repository;MapReduce framework;software development;software debugging;distributed computing;J-REX optimized evolutionary code extractor;Hadoop open source platform","","14","","24","IEEE","5 Jun 2009","","","IEEE","IEEE Conferences"
"Self modifying Cartesian Genetic Programming: Parity","S. Harding; J. F. Miller; W. Banzhaf","Department of Computer Science, Memorial University, NEW, Canada; Department of Electronics, University of York, UK; Department of Computer Science, Memorial University, NEW, Canada","2009 IEEE Congress on Evolutionary Computation","29 May 2009","2009","","","285","292","Self modifying CGP (SMCGP) is a developmental form of Cartesian genetic programming(CGP). It differs from CGP by including primitive functions which modify the program. Beginning with the evolved genotype the self-modifying functions produce a new program (phenotype) at each iteration. In this paper we have applied it to a well known digital circuit building problem: even-parity. We show that it is easier to solve difficult parity problems with SMCGP than either with CGP or modular CGP, and that the increase in efficiency grows with problem size. More importantly, we prove that SMCGP can evolve general solutions to arbitrary-sized even parity problems.","1941-0026","978-1-4244-2958-5","10.1109/CEC.2009.4982960","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4982960","","Genetic programming;Cells (biology);Evolution (biology);Biology computing;Digital circuits;Machinery;Iterative decoding;Evolutionary computation;Computer science;Scalability","digital circuits;genetic algorithms;logic circuits","Self modifying CGP;Cartesian genetic programming;SMCGP program;phenotype program;digital circuit building problem;arbitrary-sized even parity problem","","16","","19","IEEE","29 May 2009","","","IEEE","IEEE Conferences"
"A Mutation/Injection-Based Automatic Framework for Evaluating Code Clone Detection Tools","C. K. Roy; J. R. Cordy","School of Computing, Queen''s University, Kingston, ONT, Canada; School of Computing, Queen''s University, Kingston, ONT, Canada","2009 International Conference on Software Testing, Verification, and Validation Workshops","26 May 2009","2009","","","157","166","In recent years many methods and tools for software clone detection have been proposed. While some work has been done on assessing and comparing performance of these tools, very little empirical evaluation has been done. In particular, accuracy measures such as precision and recall have only been roughly estimated, due both to problems in creating a validated clone benchmark against which tools can be compared, and to the manual effort required to hand check large numbers of candidate clones. In this paper we propose an automated method for empirically evaluating clone detection tools that leverages mutation-based techniques to overcome these limitations by automatically synthesizing large numbers of known clones based on an editing theory of clone creation. Our framework is effective in measuring recall and precision of clone detection tools for various types of fine-grained clones in real systems without manual intervention.","","978-1-4244-4356-7","10.1109/ICSTW.2009.18","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4976382","clone detection;empirical evaluation;mutation","Genetic mutations;Cloning;Humans;Software systems;Software testing;Conferences;Software tools;Particle measurements;Infrared detectors;Time measurement","software tools","mutation-injection-based automatic framework;code clone detection tools;software clone detection;mutation-based techniques;fine-grained clones","","107","","43","IEEE","26 May 2009","","","IEEE","IEEE Conferences"
"Serialized TID numbers - A headache or a blessing for RFID crackers?","M. Lehtonen; A. Ruhanen; F. Michahelles; E. Fleisch","Information Management, ETH Zürich, Zurich, Switzerland; Confidex Oy, Tampere, Finland; Information Management, ETH Zürich, Zurich, Switzerland; Information Management, ETH Zürich, Zurich, Switzerland","2009 IEEE International Conference on RFID","8 May 2009","2009","","","233","240","Though transponder ID (TID) numbers of RFID tags were originally introduced to identify the chip model, serialized TID numbers are currently advertised as security features of UHF chips. Serialized TID numbers do not provide any cryptographic protection, but they do introduce a practical hurdle against adversaries who want to clone RFID tags today. Furthermore, serialized TID numbers are important for end-users who want to protect their current UHF tags from cloning since cryptographic tags are not yet commercially available in that frequency range. In this overview paper, we analyze the suitability of serialized TID numbers for security applications by evaluating the effort to bypass the TID check based on known vulnerabilities and we compare this effort to the needed level of protection in an example of anti-counterfeiting in the tobacco industry. The analysis illustrates that the practical hurdle of TID checks is not high enough for industrial-scale security applications and that it can completely diminish due to commodification of the RFID technology. However, end-users of security applications can still benefit from the increased tag cloning resistance that serialized TID numbers provide before migrating to more secure solutions.","2374-0221","978-1-4244-3337-7","10.1109/RFID.2009.4911183","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4911183","","Radiofrequency identification;Cryptography;Microcontrollers;Hardware;Security;Counterfeiting;Cryptographic protocols;Voltage;Frequency;Business","radiofrequency identification;transponders","RFID crackers;TID numbers;transponder ID;chip model;cryptographic protection;radio frequency identification","","12","4","30","IEEE","8 May 2009","","","IEEE","IEEE Conferences"
"Workload Reduction for Multi-input Feedback-Directed Optimization","P. Berube; J. N. Amaral; R. Ho; R. Silvera","Department of Computing Science, University of Alberta, Edmonton, Canada; Department of Computing Science, University of Alberta, Edmonton, Canada; Software Laboratory, IBM, Toronto, Canada; Software Laboratory, IBM, Toronto, Canada","2009 International Symposium on Code Generation and Optimization","5 May 2009","2009","","","59","69","Feedback-directed optimization is an effective technique to improve program performance, but it may result in program performance and compiler behavior that is sensitive to both the selection of inputs used for training and the actual input in each run of the program. Cross-validation over a workload of inputs can address the input-sensitivity problem, but introduces the need to select a representative workload of minimal size from the population of available inputs. We present a compiler-centric clustering methodology to group similar inputs so that redundant inputs can be eliminated from the training workload. Input similarity is determined based on the compile-time code transformations made by the compiler after training separately on each input. Differences between inputs are weighted by a performance metric based on cross-validation in order to account for code transformation differences that have little impact on performance. We introduce the CrossError metric that allows the exploration of correlations between transformations based on the results of clustering. The methodology is applied to several SPEC benchmark programs, and illustrated using selected case studies.","","978-0-7695-3576-0","10.1109/CGO.2009.23","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4907651","compilers;workload reduction;clustering;feedback-directed optimization","Program processors;Optimizing compilers;Software performance;Instruments;Frequency measurement;Radio spectrum management;Frequency conversion;Testing;Time measurement;Humans","optimising compilers;software metrics;software performance evaluation","multi input feedback-directed optimization;program performance;compiler behavior;workload reduction;cross-validation;input-sensitivity problem;compiler-centric clustering methodology;compile-time code transformations;CrossError metric;SPEC benchmark programs;performance evaluation","","3","","16","IEEE","5 May 2009","","","IEEE","IEEE Conferences"
"OptiScope: Performance Accountability for Optimizing Compilers","T. Moseley; D. Grunwald; R. Peri","Department of Computer Science, University of Colorado, Boulder, CO, USA; Department of Computer Science, University of Colorado, Boulder, CO, USA; Intel Corporation, Hillsboro, OR, USA","2009 International Symposium on Code Generation and Optimization","5 May 2009","2009","","","254","264","Compilers employ many aggressive code transformations to achieve highly optimized code. However, because of complex target architectures and unpredictable optimization interactions, these transformations may not always be beneficial. Current analysis methods measure performance at the application level and ignore optimization effects at the function and loop level. To better measure and understand these effects, we present OptiScope, a compiler independent tool to identify performance opportunities by comparing programs built with different compilers or optimization flags. The analysis includes hundreds of different metrics and uses a novel loop correlation technique for binary programs (produced from the same source by different compilers) to isolate measurements to specific regions. We present several case studies using OptiScope to identify key differences between different compiler suites, versions, and target architectures. The examples demonstrate performance improvement opportunities between 32.5% to 893% on select regions of SPEC 2006 benchmarks.","","978-0-7695-3576-0","10.1109/CGO.2009.26","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4907669","","Optimizing compilers;Program processors;Testing;Hardware;Computer science;Computer architecture;Performance analysis;Current measurement;Optimization methods;Out of order","program compilers","OptiScope;compilers;code transformations;loop correlation technique;binary programs;SPEC 2006 benchmarks","","8","","21","IEEE","5 May 2009","","","IEEE","IEEE Conferences"
"Procedural Abstraction with Reverse Prefix Trees","S. Schaeckeler; W. Shang","Department of Computer Engineering, Santa Clara University, Santa Clara, CA, USA; Department of Computer Engineering, Santa Clara University, Santa Clara, CA, USA","2009 International Symposium on Code Generation and Optimization","5 May 2009","2009","","","243","253","For memory constrained environments like embedded systems, optimization for size is often as important as, if not more important than, optimization for execution speed. A common technique for compacting code is procedural abstraction. Equivalent code fragments are identified and abstracted into a procedure. The standard algorithm for identifying these fragments is based on suffix trees. We propose in this paper the calculation of suffix trees over the program text not in the common top-down fashion, but reversed, i.e. bottom-up. With this simple modification, not only equivalent fragments can be identified, but also fragments equivalent to (possibly often differently long) suffixes of the longest fragments. A longest fragment is then abstracted, and all fragments are replaced by procedure calls to their corresponding start instruction somewhere in the abstracted procedure. This allows us to harvest more and longer fragments than with standard suffix trees, improving code size reductions on average by 8.277% over standard suffix trees.","","978-0-7695-3576-0","10.1109/CGO.2009.25","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4907668","embedded systems;code compaction;code size reduction;post-pass optimization;procedural abstraction;suffix tree;reverse prefix tree;program visualization","Constraint optimization;Code standards;Embedded system;Embedded computing;Random access memory;Costs;Personal digital assistants;Assembly;Compaction;Visualization","embedded systems;optimising compilers;tree data structures","procedural abstraction;reverse prefix tree;memory constrained environment;embedded system;code size optimization;code execution speed optimization;suffix tree;procedure call;code compaction;post-pass optimization","","2","","15","IEEE","5 May 2009","","","IEEE","IEEE Conferences"
"A Flexible Framework for Quality Assurance of Software Artefacts with Applications to Java, UML, and TTCN-3 Test Specifications","J. Nödler; H. Neukirchen; J. Grabowski","Software Engineering for Distributed Systems Group, Institute for Computer Science, Faculty for Mathematics and Computer Science, University of Göttingen, Gottingen, Germany; Faculty of Industrial Engineering, Mechanical Engineering and Computer Science, University of Iceland, Reykjavik, Iceland; Software Engineering for Distributed Systems Group, Institute for Computer Science, Faculty for Mathematics and Computer Science, University of Göttingen, Gottingen, Germany","2009 International Conference on Software Testing Verification and Validation","17 Apr 2009","2009","","","101","110","Manual reviews and inspections of software artefacts are time consuming and thus, automated analysis tools have been developed to support the quality assurance of software artefacts. Usually, software analysis tools are implemented for analysing only one specific language as target and for performing only one class of analyses. Furthermore, most  software analysis tools support only common programming languages, but not those domain-specific languages that are used in a test  process. As a solution, a framework for software analysis is  presented that is based on a flexible, yet high-level facade layer that mediates between analysis rules and the underlying target software artefact; the analysis rules are specified using high-level XQuery expressions. Hence, further rules can be quickly added and new types of software artefacts can be analysed without needing to adapt the existing analysis rules. The applicability of this approach is demonstrated by examples from using this framework to calculate metrics and detect bad smells in Java source code, in UML models, and in test specifications written using the Testing and Test Control Notations (TTCN-3).","2159-4848","978-1-4244-3775-7","10.1109/ICST.2009.34","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4815342","","Quality assurance;Software quality;Application software;Java;Unified modeling language;Software testing;Software tools;Performance analysis;Inspection;Software performance","Java;program diagnostics;program testing;software metrics;software quality;software tools;Unified Modeling Language","quality assurance;UML;TTCN-3 test specifications;software artefact inspections;automated analysis tools;software analysis tools;domain-specific languages;XQuery expressions;metrics calculation;bad smell detection;Java source code;test control notations","","5","","36","IEEE","17 Apr 2009","","","IEEE","IEEE Conferences"
"Incremental Clone Detection","N. Göde; R. Koschke","University of Bremen, Germany; University of Bremen, Germany","2009 13th European Conference on Software Maintenance and Reengineering","10 Apr 2009","2009","","","219","228","Finding, understanding and managing software clones - passages of duplicated source code - is of large interest in research and practice. There is an abundance of techniques to detect clones. However, all these techniques are limited to a single revision of a program. When the code changes, the analysis must be run again from scratch even though only small parts may have changed. In this paper, we present an incremental clone detection algorithm, which detects clones based on the results of the previous revision's analysis. Moreover, it creates a mapping between clones of one revision to the next, supplying information about the addition and deletion of clones. Our empirical results demonstrate that the incremental technique requires considerably less time than a non-incremental approach if the changes do not exceed a certain fraction of the source code. An incremental analysis is useful for on-the-fly detection and evolutionary clone analysis. On-the-fly detection may be integrated in an IDE and allows to re-run clone detection immediately when a programmer saves his changes or even while he/she is typing. In evolutionary clone analysis, many revisions of a system need to be analyzed in order to understand how clones evolve.","1534-5351","978-0-7695-3589-0","10.1109/CSMR.2009.20","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4812755","","Cloning;Software maintenance;Tree graphs;Conference management;Detection algorithms;Algorithm design and analysis;Programming profession;Information analysis;Detectors;Tree data structures","program diagnostics;software maintenance;software management","managing software clones;duplicated source code;program analysis;incremental clone detection algorithm;incremental analysis;on-the-fly detection;evolutionary clone analysis;IDE","","118","","30","IEEE","10 Apr 2009","","","IEEE","IEEE Conferences"
"Third International Workshop on Software Clones (IWSC)","R. Koschke; S. Jarzabek; J. Cordy; K. Inoue","University of Brethemen, Germany; National University of Singapore, Singapore; Queen's University, Canada; Osaka University, Japan","2009 13th European Conference on Software Maintenance and Reengineering","10 Apr 2009","2009","","","269","270","Software clones are identical or similar pieces of code. They are often a result of copying and pasting as an act of ad-hoc reuse by programmers. Software clones research is of high relevance for industry. Many researchers have reported high rates of cloning in both industrial as well as open-source systems.Many techniques exist that try to detect clones. There are also lines of research in clone detection that evaluate these approaches, reason about ways to remove clones, assess the effect of clones on maintainability, track their evolution, and investigate root causes of clones. Today, research in software clones is an established field with more than 100 publications in various conferences and journals.The purpose of the workshop is, essentially, to solidify and give shape to this research area and community.","1534-5351","978-0-7695-3589-0","10.1109/CSMR.2009.45","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4812766","Software clones;code redundancy;clone detection;redundancy removal;software refactoring;software reengineering;plagiarism detection;copyright infringement;source differencing.","Cloning;Software;Conferences;Redundancy;Evolution (biology);Data mining;Chapters","","","","1","","6","IEEE","10 Apr 2009","","","IEEE","IEEE Conferences"
"Identification of Extract Method Refactoring Opportunities","N. Tsantalis; A. Chatzigeorgiou","Department of Applied Informatics, University of Macedonia, Thessaloniki, Greece; Department of Applied Informatics, University of Macedonia, Thessaloniki, Greece","2009 13th European Conference on Software Maintenance and Reengineering","10 Apr 2009","2009","","","119","128","Extract method has been recognized as one of the most important refactorings, since it decomposes large methods and can be used in combination with other refactorings for fixing a variety of design problems. However, existing tools and methodologies support extraction of methods based on a set of statements selected by the user in the original method. The goal of the proposed methodology is to automatically identify extract method refactoring opportunities and present them as suggestions to the designer of an object-oriented system. The suggested refactorings adhere to three principles: the extracted code should contain the complete computation of a given variable declared in the original method, the behavior of the program should be preserved after the application of the refactoring, and the extracted code should not be excessively duplicated in the original method. The proposed approach is based on the union of static slices that result from the application of a block-based slicing technique. The soundness of the identified refactoring opportunities has been evaluated by an independent designer on the system that he developed.","1534-5351","978-0-7695-3589-0","10.1109/CSMR.2009.23","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4812745","Extract Method Refactoring;Long Method Bad Smell;Program Slicing;Object-Oriented Design","Software maintenance;Informatics;Employment;Runtime;Amorphous materials;Application software;Software engineering;Debugging;Software testing;Software measurement","object-oriented methods","refactoring extract method;object-oriented system;code extraction;static slices","","31","2","23","IEEE","10 Apr 2009","","","IEEE","IEEE Conferences"
"Improving Guidance when Restructuring Variabilities in Software Product Lines","M. Ribeiro; P. Borba","Informatics Center, Federal University of Pernambuco (UFPE), Recife, Pernambuco, Brazil; Informatics Center, Federal University of Pernambuco (UFPE), Recife, Pernambuco, Brazil","2009 13th European Conference on Software Maintenance and Reengineering","10 Apr 2009","2009","","","79","88","Software product lines (SPLs) encompass a family of software systems developed from reusable assets. One issue during SPL maintenance is the decision about which mechanism should be used to restructure variabilities aiming at improving the modularity of the SPL artifacts. Due to the great variety of mechanisms (inheritance, configuration files, aspect-oriented programming), selecting the incorrect ones may produce negative effects on the cost to evolve the SPL. To reduce this problem, we propose a decision model to help developers to choose mechanisms to restructure variabilities in SPLs. The domain analyzed by this work consists of test scripts. We also developed a prototype tool to support developers by recommending mechanisms according to the decision model. Using our model and tool may improve the tests variabilitiespsila modularity and remove bad smells such as cloned code.","1534-5351","978-0-7695-3589-0","10.1109/CSMR.2009.49","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4812741","Software Product Lines;Software Modularity;Metrics","Software maintenance;Software reusability;Prototypes;Productivity;Costs;Informatics;Software systems;Software prototyping;Software testing;System testing","software maintenance;software reusability","software product lines;software systems;reusable assets;SPL maintenance","","6","","18","IEEE","10 Apr 2009","","","IEEE","IEEE Conferences"
"Identifying Architectural Bad Smells","J. Garcia; D. Popescu; G. Edwards; N. Medvidovic","Computer Science Department, University of Southern California, Los Angeles, CA, USA; Computer Science Department, University of Southern California, Los Angeles, CA, USA; Computer Science Department, University of Southern California, Los Angeles, CA, USA; Computer Science Department, University of Southern California, Los Angeles, CA, USA","2009 13th European Conference on Software Maintenance and Reengineering","10 Apr 2009","2009","","","255","258","Certain design fragments in software architectures can have a negative impact on system maintainability. In this paper, we introduce the concept of architectural ""bad smells,"" which are frequently recurring software designs that can have non-obvious and significant detrimental effects on system lifecycle properties. We define architectural smells and differentiate them from related concepts, such as architectural antipatterns and code smells. We also describe four representative architectural smells we encountered in the context of reverse-engineering eighteen grid technologies and refactoring one large industrial system.","1534-5351","978-0-7695-3589-0","10.1109/CSMR.2009.59","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4812762","Software Maintenance;Software Architecture;Architectural Bad Smells;Architectural Refactoring","Computer architecture;Software maintenance;Software design;Software systems;Design engineering;Computer science;Software architecture;Computer industry;Application software;Technology management","grid computing;reverse engineering;software architecture;software maintenance","architectural bad smell identification;design fragments;software architectures;system maintainability;system lifecycle properties;reverse engineering;grid technologies;industrial system refactoring","","114","","7","IEEE","10 Apr 2009","","","IEEE","IEEE Conferences"
"Improving the Dataflow-Based Concern Identification Approach","M. Trifu","FZI Forschungszentrum Informatik, Karlsruhe, Germany","2009 13th European Conference on Software Maintenance and Reengineering","10 Apr 2009","2009","","","109","118","Concern identification aims to identify the implementation of a functional concern in existing source code. The dataflow-based concern identification approach starts from a set of concern seeds and uses static dataflow information to extract the data skeleton of a functional concern. This paper builds upon previous work on dataflow-based concern identification and presents three improvements to the identification approach: the reduction of the search space for manual identification of concern seeds, the introduction of information sources as a mechanism to explicitly define concern boundaries and the separation of superimposed class roles. The paper also shows the impact of these improvements by comparing the results of the improved identification approach with previously published results on the JHotDraw open-source case-study.","1534-5351","978-0-7695-3589-0","10.1109/CSMR.2009.34","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4812744","concern identification;dataflow information;concern seed","Skeleton;Software maintenance;Data mining;Open source software;Humans;Software systems;Information retrieval;Java;Computer languages","data flow computing;program diagnostics","dataflow-based concern identification approach;static dataflow information;data skeleton extraction;dataflow-based concern identification;search space reduction;superimposed class roles;JHotDraw open-source case study","","7","","25","IEEE","10 Apr 2009","","","IEEE","IEEE Conferences"
"Configuration management at massive scale: system design and experience","W. Enck; T. Moyer; P. McDaniel; S. Sen; P. Sebos; S. Spoerel; A. Greenberg; Y. -W. E. Sung; S. Rao; W. Aiello","Pennsylvania State University, USA; Pennsylvania State University, USA; Pennsylvania State University, USA; AT and T Research, USA; AT and T Research, USA; AT and T Research, USA; Microsoft Research Limited, USA; Purdue University, USA; Purdue University, USA; University of British Columbia, Canada","IEEE Journal on Selected Areas in Communications","3 Apr 2009","2009","27","3","323","335","The development and maintenance of network device configurations is one of the central challenges faced by large network providers. Current network management systems fail to meet this challenge primarily because of their inability to adapt to rapidly evolving customer and provider-network needs, and because of mismatches between the conceptual models of the tools and the services they must support. In this paper, we present the Presto configuration management system that attempts to address these failings in a comprehensive and flexible way. Developed for and used during the last 5 years within a large ISP network, Presto constructs device-native configurations based on the composition of configlets representing different services or service options. Configlets are compiled by extracting and manipulating data from external systems as directed by the Presto configuration scripting and template language. We outline the configuration management needs of large-scale network providers, introduce the PRESTO system and configuration language, and reflect upon our experiences developing PRESTO configured VPN and VoIP services. In doing so, we describe how PRESTO promotes healthy configuration management practices.","1558-0008","","10.1109/JSAC.2009.090408","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4808476","Computer network management","Data mining;Delay;Large-scale systems;Virtual private networks;Costs;Maintenance;Microprogramming;Time to market;Profitability;Databases","computer network management","computer network management;network provider;Presto configuration management system;ISP network;configlets;data manipulation;data extraction;template language","","34","3","32","IEEE","3 Apr 2009","","","IEEE","IEEE Journals"
"Optimizing communication and capacity in a 3D stacked reconfigurable cache hierarchy","N. Madan; L. Zhao; N. Muralimanohar; A. Udipi; R. Balasubramonian; R. Iyer; S. Makineni; D. Newell","School of Computing, University of Utah, USA; System Technology Laboratory, Intel Corporation, India; School of Computing, University of Utah, USA; School of Computing, University of Utah, USA; School of Computing, University of Utah, USA; System Technology Laboratory, Intel Corporation, India; System Technology Laboratory, Intel Corporation, India; System Technology Laboratory, Intel Corporation, India","2009 IEEE 15th International Symposium on High Performance Computer Architecture","6 Mar 2009","2009","","","262","274","Cache hierarchies in future many-core processors are expected to grow in size and contribute a large fraction of overall processor power and performance. In this paper, we postulate a 3D chip design that stacks SRAM and DRAM upon processing cores and employs OS-based page coloring to minimize horizontal communication of cache data. We then propose a heterogeneous reconfigurable cache design that takes advantage of the high density of DRAM and the superior power/delay characteristics of SRAM to efficiently meet the working set demands of each individual core. Finally, we analyze the communication patterns for such a processor and show that a tree topology is an ideal fit that significantly reduces the power and latency requirements of the on-chip network. The above proposals are synergistic: each proposal is made more compelling because of its combination with the other innovations described in this paper. The proposed reconfigurable cache model improves performance by up to 19% along with 48% savings in network power.","2378-203X","978-1-4244-2932-5","10.1109/HPCA.2009.4798261","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4798261","multi-core processors;cache and memory hierarchy;non-uniform cache architecture (NUCA);page coloring;on-chip networks;SRAM/DRAM cache reconfiguration","Random access memory;Network-on-a-chip;Delay;Network topology;Proposals;Technological innovation;Space technology;Stacking;Bandwidth;Chip scale packaging","cache storage;DRAM chips;integrated circuit design;multiprocessing systems;network topology;network-on-chip;reconfigurable architectures;SRAM chips;trees (mathematics)","3D stacked reconfigurable cache hierarchy;multicore processor;chip design;SRAM chip;DRAM chip;OS-based page coloring;horizontal communication;tree topology;network-on-chip","","55","4","49","IEEE","6 Mar 2009","","","IEEE","IEEE Conferences"
"A Data Mining Approach for Detecting Higher-Level Clones in Software","H. A. Basit; S. Jarzabek","Lahore University of Management Sciences, Pakistan; National University of Singapore, Singapore, Singapore","IEEE Transactions on Software Engineering","31 Jul 2009","2009","35","4","497","514","Code clones are similar program structures recurring in variant forms in software system(s). Several techniques have been proposed to detect similar code fragments in software, so-called simple clones. Identification and subsequent unification of simple clones is beneficial in software maintenance. Even further gains can be obtained by elevating the level of code clone analysis. We observed that recurring patterns of simple clones often indicate the presence of interesting higher-level similarities that we call structural clones. Structural clones show a bigger picture of similarity situation than simple clones alone. Being logical groups of simple clones, structural clones alleviate the problem of huge number of clones typically reported by simple clone detection tools, a problem that is often dealt with postdetection visualization techniques. Detection of structural clones can help in understanding the design of the system for better maintenance and in reengineering for reuse, among other uses. In this paper, we propose a technique to detect some useful types of structural clones. The novelty of our approach includes the formulation of the structural clone concept and the application of data mining techniques to detect these higher-level similarities. We describe a tool called clone miner that implements our proposed technique. We assess the usefulness and scalability of the proposed techniques via several case studies. We discuss various usage scenarios to demonstrate in what ways the knowledge of structural clones adds value to the analysis based on simple clones alone.","1939-3520","","10.1109/TSE.2009.16","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4796208","Design concepts;maintainability;restructuring;reverse engineering;reengineering;reusable software.","Data mining;Cloning;Software systems;Software maintenance;Collaboration;Portals;Computer Society;Visualization;Scalability;Reverse engineering","data mining;software maintenance;software reusability","data mining approach;higher-level clone detection;program structures;software system;software maintenance;code clone analysis;postdetection visualization techniques;software reusability","","70","1","53","IEEE","27 Feb 2009","","","IEEE","IEEE Journals"
"Identification of Move Method Refactoring Opportunities","N. Tsantalis; A. Chatzigeorgiou","Department of Applied Informatics, University of Macedonia, Thessaloniki, Greece; Department of Applied Informatics, University of Macedonia, Thessaloniki, Greece","IEEE Transactions on Software Engineering","2 Jun 2009","2009","35","3","347","367","Placement of attributes/methods within classes in an object-oriented system is usually guided by conceptual criteria and aided by appropriate metrics. Moving state and behavior between classes can help reduce coupling and increase cohesion, but it is nontrivial to identify where such refactorings should be applied. In this paper, we propose a methodology for the identification of Move Method refactoring opportunities that constitute a way for solving many common feature envy bad smells. An algorithm that employs the notion of distance between system entities (attributes/methods) and classes extracts a list of behavior-preserving refactorings based on the examination of a set of preconditions. In practice, a software system may exhibit such problems in many different places. Therefore, our approach measures the effect of all refactoring suggestions based on a novel entity placement metric that quantifies how well entities have been placed in system classes. The proposed methodology can be regarded as a semi-automatic approach since the designer will eventually decide whether a suggested refactoring should be applied or not based on conceptual or other design quality criteria. The evaluation of the proposed approach has been performed considering qualitative, metric, conceptual, and efficiency aspects of the suggested refactorings in a number of open-source projects.","1939-3520","","10.1109/TSE.2009.1","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4752842","Move Method refactoring;Feature Envy;object-oriented design;Jaccard distance;design quality.","Software systems;Performance evaluation;Open source software;Runtime;Productivity;Data mining","object-oriented programming;software maintenance;software metrics","Move Method refactoring opportunity identification;object-oriented system;conceptual criteria;software metrics;feature envy","","239","","33","IEEE","19 Jan 2009","","","IEEE","IEEE Journals"
"What Types of Defects Are Really Discovered in Code Reviews?","M. V. Mäntylä; C. Lassenius","Helsinki University of Technology, Finland; Helsinki University of Technology, Finland","IEEE Transactions on Software Engineering","2 Jun 2009","2009","35","3","430","448","Research on code reviews has often focused on defect counts instead of defect types, which offers an imperfect view of code review benefits. In this paper, we classified the defects of nine industrial (C/C++) and 23 student (Java) code reviews, detecting 388 and 371 defects, respectively. First, we discovered that 75 percent of defects found during the review do not affect the visible functionality of the software. Instead, these defects improved software evolvability by making it easier to understand and modify. Second, we created a defect classification consisting of functional and evolvability defects. The evolvability defect classification is based on the defect types found in this study, but, for the functional defects, we studied and compared existing functional defect classifications. The classification can be useful for assigning code review roles, creating checklists, assessing software evolvability, and building software engineering tools. We conclude that, in addition to functional defects, code reviews find many evolvability defects and, thus, offer additional benefits over execution-based quality assurance methods that cannot detect evolvability defects. We suggest that code reviews may be most valuable for software products with long life cycles as the value of discovering evolvability defects in them is greater than for short life cycle systems.","1939-3520","","10.1109/TSE.2008.71","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4604671","Code inspections and walkthroughs;enhancement;extensibility;maintainability;restructuring.;Source code organization;Code documentation;Construction QA;Methods for SQA and V&V;Measurement applied to SQA and V&V;Code inspections and walkthroughs;Maintainability","Quality assurance;Inspection;Runtime;Java;Software tools;Software engineering;Software measurement;Software quality;Guidelines;Timing","pattern classification;software maintenance;software reviews","software functionality;software evolvability;defect classification;software engineering tools;execution-based quality assurance methods;software products","","105","","73","IEEE","22 Aug 2008","","","IEEE","IEEE Journals"
"Improving the Precision of Fowler's Definitions of Bad Smells","M. Zhang; N. Baddoo; P. Wernick; T. Hall","School of Computer Science, University of Herfordshire, Hatfield, Hertfordshire, UK; School of Computer Science, University of Herfordshire, Hatfield, Hertfordshire, UK; School of Computer Science, University of Herfordshire, Hatfield, Hertfordshire, UK; School of Information Systems, Computing & Mathematics, Brunei University, Uxbridge, Middlesex, UK","2008 32nd Annual IEEE Software Engineering Workshop","17 Nov 2009","2008","","","161","166","Current approaches to detecting bad smells in code are mainly based on software metrics. We suggest that these methods lack precision in detecting bad smells, and we propose a code pattern-based approach to detecting bad smells. However before such a pattern-based approach can be implemented, Fowler's original definitions of bad smells need to be made more precise. Currently Fowler's definitions are too informal to implement in a pattern-searching tool. In this paper we use an expert panel to evaluate our enhanced definitions for five of Fowler's bad smells. We use a questionnaire to survey four experts' opinions of our bad smell definitions. Our results show that the experts basically agree with our enhanced definitions of the message chains, middle man and speculative generality bad smells. However, there are strong disagreements on our definitions of the data clumps and switch statements bad smells. We present enhanced definitions on the basis of these expert opinions.","1550-6215","978-0-7695-3617-0","10.1109/SEW.2008.26","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5328371","Coding tools and technique;programming environments/construction tools;restructuring;reverse engineering;reengineering","Switches;Software metrics;Conferences;Computer science;Programming environments;Reverse engineering;Information systems;Mathematics;Software measurement;Logic programming","object-oriented programming;reverse engineering;software maintenance;software metrics;systems re-engineering","Fowler's definition;code bad smell detection;software metrics;code pattern-based approach;pattern-searching tool;questionnaire survey;message chain;middle man;speculative generality bad smell;data clump;switch statement bad smell;software refactoring;software reengineering;reverse engineering","","8","","14","IEEE","17 Nov 2009","","","IEEE","IEEE Conferences"
"Clustering Based Automatic Refactorings Identification","I. G. Czibula; G. Czibula","Department of Computer Science, Babes Bolyai University, Cluj-Napoca, Romania; Department of Computer Science, Babes Bolyai University, Cluj-Napoca, Romania","2008 10th International Symposium on Symbolic and Numeric Algorithms for Scientific Computing","18 Aug 2009","2008","","","253","256","The aim of this paper is to approach the problem of improving the design of an object oriented software system, by identifying the appropriate refactorings. It is well known that improving the quality of software systems design is an important issue during the evolution of object oriented software systems. This improvement can be achieved by refactoring the software system in order to improve its internal structure, but without altering the external behavior of the code. In this paper we introduce a hierarchical divisive clustering algorithm for automatic identification of refactorings that improve the internal structure of a software system. We evaluate our approach using JHotDraw case study and a real software system, emphasizing its advantages in comparison with existing similar approaches.","","978-0-7695-3523-4","10.1109/SYNASC.2008.17","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5204820","software design;refactoring;clustering","Software systems;Clustering algorithms;Software algorithms;Algorithm design and analysis;Data mining;Application software;Software quality;Software maintenance;Scientific computing;Computer science","object-oriented programming;pattern clustering;software maintenance;software quality","automatic refactoring identification;object oriented software system design quality;hierarchical divisive clustering algorithm;software system evolution","","2","","21","IEEE","18 Aug 2009","","","IEEE","IEEE Conferences"
