"Document Title",Authors,"Author Affiliations","Publication Title",Date Added To Xplore,"Publication Year","Volume","Issue","Start Page","End Page","Abstract","ISSN",ISBNs,"DOI",Funding Information,PDF Link,"Author Keywords","IEEE Terms","INSPEC Controlled Terms","INSPEC Non-Controlled Terms","Mesh_Terms",Article Citation Count,Patent Citation Count,"Reference Count","License",Online Date,Issue Date,"Meeting Date","Publisher",Document Identifier
"DMS/spl reg/: program transformations for practical scalable software evolution","I. D. Baxter; C. Pidgeon; M. Mehlich","Semantic Designs, Inc., USA; Semantic Designs, Inc., USA; Semantic Designs, Inc., USA","Proceedings. 26th International Conference on Software Engineering","26 Jul 2004","2004","","","625","634","While a number of research systems have demonstrated the potential value of program transformations, very few of these systems have made it into practice. The core technology for such systems is well understood; what remains is integration and more importantly, the problem of handling the scale of the applications to be processed. This paper describes DMS, a practical, commercial program analysis and transformation system, and sketches a variety of tasks to which it has been applied, from redocumenting to large-scale system migration. Its success derives partly from a vision of design maintenance and the construction of infrastructure that appears necessary to support that vision. DMS handles program scale by careful space management, computational scale via parallelism and knowledge acquisition scale via domains.","0270-5257","0-7695-2163-0","10.1109/ICSE.2004.1317484","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1317484","","Software tools;Java;Space technology;Large-scale systems;Knowledge management;Concurrent computing;Parallel processing;Knowledge acquisition;Software maintenance;Paper technology","software maintenance;program diagnostics;knowledge acquisition;software prototyping;systems re-engineering","DMS/spl reg/;program transformations;software evolution;program analysis;space management;knowledge acquisition;software reengineering;design maintenance","","80","1","22","IEEE","26 Jul 2004","","","IEEE","IEEE Conferences"
"Finding latent code errors via machine learning over program executions","Y. Brun; M. D. Ernst","Laboratory for Molecular Science, University of Southern California, Los Angeles, CA, USA; Computer Science & Artificial Intelligence Laboratory, Massachusetts Institute of Technology, Cambridge, MA, USA","Proceedings. 26th International Conference on Software Engineering","26 Jul 2004","2004","","","480","490","This paper proposes a technique for identifying program properties that indicate errors. The technique generates machine learning models of program properties known to result from errors, and applies these models to program properties of user-written code to classify and rank properties that may lead the user to errors. Given a set of properties produced by the program analysis, the technique selects a subset of properties that are most likely to reveal an error. An implementation, the fault invariant classifier, demonstrates the efficacy of the technique. The implementation uses dynamic invariant detection to generate program properties. It uses support vector machine and decision tree learning tools to classify those properties. In our experimental evaluation, the technique increases the relevance (the concentration of fault-revealing properties) by a factor of 50 on average for the C programs, and 4.8 for the Java programs. Preliminary experience suggests that most of the fault-revealing properties do lead a programmer to an error.","0270-5257","0-7695-2163-0","10.1109/ICSE.2004.1317470","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1317470","","Machine learning;Testing;Programming profession;Computer errors;Support vector machines;Support vector machine classification;Decision trees;Classification tree analysis;Laboratories;Computer science","program diagnostics;learning (artificial intelligence);support vector machines;decision trees;C language;Java;fault diagnosis","machine learning models;program properties;user-written code;program analysis;fault invariant classifier;dynamic invariant detection;support vector machine;decision tree learning tools;C programs;Java programs;fault-revealing properties;latent code errors;program executions","","68","2","26","IEEE","26 Jul 2004","","","IEEE","IEEE Conferences"
"Reengineering Web applications based on cloned pattern analysis","A. De Lucia; R. Francese; G. Scanniello; G. Tortora","Dipartimento di Matematica e Informatica, Università di Salerno, Salerno, Italy; Dipartimento di Matematica e Informatica, Universita di Salemo, Salerno, Italy; Dipartimento di Matematica e Informatica, Universita di Salemo, Salerno, Italy; Dipartimento di Matematica e Informatica, Universita di Salemo, Salerno, Italy","Proceedings. 12th IEEE International Workshop on Program Comprehension, 2004.","12 Jul 2004","2004","","","132","141","Web applications are subject to continuous and rapid evolution. Often it happens that programmers indiscriminately duplicate Web pages without considering systematic development and maintenance methods. This practice creates code clones that make Web applications hard to maintain and reuse. This paper presents an approach for reengineering Web applications based on clone analysis that aims at identifying and generalizing static and dynamic pages and navigational patterns of a Web application. Clone analysis is also helpful for identifying literals that can be generated from a database. A case study is described which shows how the proposed approach can be used for restructuring the navigational structure of a Web application by removing redundant code.","1092-8138","0-7695-2149-5","10.1109/WPC.2004.1311055","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1311055","","Pattern analysis;Cloning;Navigation;Web pages;Databases;Production;Software systems;Application software;Testing;US Department of Transportation","Internet;systems re-engineering;software maintenance","Web applications;applications reengineering;cloned pattern analysis;clone analysis;navigational patterns;literals identification","","12","","31","IEEE","12 Jul 2004","","","IEEE","IEEE Conferences"
"Field-testing IMPACT EPIC research results in Itanium 2","J. W. Sias; Sain-zee Ueng; G. A. Kent; I. M. Steiner; E. M. Nystrom; W. . -M. W. Hwu","Center for Reliable and High-Performance Computing, Department of Electrical and Computer Engineering, University of Illinois, Urbana-Champaign, USA; Center for Reliable and High-Performance Computing, Department of Electrical and Computer Engineering, University of Illinois, Urbana-Champaign, USA; Center for Reliable and High-Performance Computing, Department of Electrical and Computer Engineering, University of Illinois, Urbana-Champaign, USA; Center for Reliable and High-Performance Computing, Department of Electrical and Computer Engineering, University of Illinois, Urbana-Champaign, USA; Center for Reliable and High-Performance Computing, Department of Electrical and Computer Engineering, University of Illinois, Urbana-Champaign, USA; Center for Reliable and High-Performance Computing, Department of Electrical and Computer Engineering, University of Illinois, Urbana-Champaign, USA","Proceedings. 31st Annual International Symposium on Computer Architecture, 2004.","12 Jul 2004","2004","","","26","37","Explicitly-Parallel Instruction Computing (EPIC) provides architectural features, including predication and explicit control speculation, intended to enhance the compiler's ability to expose instruction-level parallelism (ILP) in control-intensive programs. Aggressive structural transformations using these features, though described in the literature, have not yet been fully characterized in complete systems. Using the Intel Itanium 2 microprocessor, the SPECint2000 benchmarks and the IMPACT Compiler for IA-64, a research compiler competitive with the best commercial compilers on the platform, we provide an in situ evaluation of code generated using aggressive, EPIC-enabled techniques in a reality-constrained microarchitecture. Our work shows a 1.13 average speedup (up to 1.50) due to these compilation techniques, relative to traditionally-optimized code at the same inlining and pointer analysis levels, and a 1.55 speedup (up to 2.30) relative to GNU GCC, a solid traditional compiler. Detailed results show that the structural compilation approach provides benefits far beyond a decrease in branch misprediction penalties and that it both positively and negatively impacts instruction cache performance. We also demonstrate the increasing significance of runtime effects, such as data cache and TLB, in determining end performance and the interaction of these effects with control speculation.","1063-6897","0-7695-2143-6","10.1109/ISCA.2004.1310761","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1310761","","Parallel processing;Microarchitecture;Computer aided instruction;Concurrent computing;Program processors;Clocks;Pipelines;Microprocessors;Solids;Runtime","parallel architectures;instruction sets;microprocessor chips;optimising compilers;data flow analysis;performance evaluation","IMPACT EPIC research results;Itanium 2 field-testing;explicitly-parallel instruction computing;computer architecture;instruction-level parallelism;control-intensive programs;structural transformations;Intel Itanium 2 microprocessor;SPECint2000 benchmarks;IMPACT compiler;IA-64;research compiler;EPIC-enabled techniques;reality-constrained microarchitecture;code optimization;inlining analysis;pointer analysis;GNU GCC;branch misprediction penalties;instruction cache performance;data cache","","7","","29","IEEE","12 Jul 2004","","","IEEE","IEEE Conferences"
"A survey of software refactoring","T. Mens; T. Tourwe","Université de Mons-Hainaut, Mons, Belgium; Centrum voor Wiskunde en Informatica, Amsterdam, Netherlands","IEEE Transactions on Software Engineering","28 Jun 2004","2004","30","2","126","139","We provide an extensive overview of existing research in the field of software refactoring. This research is compared and discussed based on a number of different criteria: the refactoring activities that are supported, the specific techniques and formalisms that are used for supporting these activities, the types of software artifacts that are being refactored, the important issues that need to be taken into account when building refactoring tool support, and the effect of refactoring on the software process. A running example is used to explain and illustrate the main concepts.","1939-3520","","10.1109/TSE.2004.1265817","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1265817","","Software quality;Software tools;Software maintenance;Software reusability;Buildings;Programming environments;Reverse engineering;Costs;Spirals;Taxonomy","software reusability;object-oriented programming;bibliographies;software maintenance;programming environments;reverse engineering;software quality","software refactoring;programming environment;reverse engineering;coding tools;coding technique;construction tool","","667","8","111","IEEE","28 Jun 2004","","","IEEE","IEEE Journals"
"Link-time optimization techniques for eliminating conditional branch redundancies","M. Fernandez; R. Espasa","Computer Architecture Department, Universitat Poliltècnica de Catalunya, Barcelona, Spain; Computer Architecture Department, Universitat Poliltècnica de Catalunya, Barcelona, Spain","Eighth Workshop on Interaction between Compilers and Computer Architectures, 2004. INTERACT-8 2004.","24 May 2004","2004","","","87","96","Optimizations performed at link time or directly applied to final program executables have received increased attention in recent years. This work discusses the discovery and elimination of redundant conditional branches in the context of a link-time optimizer, an optimization that we call conditional branch redundancy elimination (CBRE). Our experiments show that around 20% of conditional branches in a program can be considered redundant because their outcomes can be determined from a previous short dynamic execution frame. Then, we present several CBRE algorithms targeted at optimizing away these redundancies. Our results show that around 5% of the conditional branch redundancy detected can indeed be eliminated, which translates into execution time reductions of around 4%. We also give accurate measures of the impact of applying CBRE in code growth.","","0-7695-2061-8","10.1109/INTERA.2004.1299513","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1299513","","Computer architecture;Performance evaluation;Instruments;Electronic mail;Time measurement;Program processors;Optimizing compilers;Performance analysis;Production;Force feedback","optimising compilers;program debugging;redundancy","link-time optimization;program execution;link-time optimizer;conditional branch redundancy elimination;dynamic execution frame;branch redundancy detection;execution time reductions;code growth","","1","1","27","IEEE","24 May 2004","","","IEEE","IEEE Conferences"
"User defined data in the new analysis model of the BaBar experiment","G. De Nardo; L. Lista","Istituto Nazionale di Fisica Nucleare and Universita’ di Napoli, Napoli, Italy; Istituto Nazionale di Fisca Nucleare, Napoli, Italy","2003 IEEE Nuclear Science Symposium. Conference Record (IEEE Cat. No.03CH37515)","22 Nov 2004","2003","1","","165","168 Vol.1","The BaBar experiment has recently revised its Analysis Model. One of the key ingredient of BaBar new Analysis Model is the support of the capability to add to the Event Store user defined data, which can be the output of complex computations performed at an advanced stage of a physics analysis, and are associated to analysis objects. In order to provide flexibility and extensibility with respect to object types, template generic programming has been adopted. In this way the model is non-intrusive with respect to reconstruction and analysis objects it manages, not requiring changes in their interfaces and implementations. Technological details are hidden as much as possible to the user, providing a simple interface. In this paper we present some of the limitations of the old model and how they are addressed by the new Analysis Model.","1082-3654","0-7803-8257-9","10.1109/NSSMIC.2003.1352022","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1352022","","Object oriented modeling;Performance analysis;Detectors;Mesons;Resonance;Telephony;Shape measurement;Software performance;Physics computing;Collaboration","particle detectors;synchrotrons","user defined data;analysis model;BaBar experiment;Analysis Model;Event Store user defined data;complex computations","","2","","6","IEEE","22 Nov 2004","","","IEEE","IEEE Conferences"
"Second international workshop on detection of software clones","A. Lakhotia; A. Walenstein; R. Koschke","Center for Advanced Computer Science, University of Louisiana, Lafayette, USA; Center for Advanced Computer Science, University of Louisiana, Lafayette, USA; Institute for Software Technology, University of Stuttgart, Germany","10th Working Conference on Reverse Engineering, 2003. WCRE 2003. Proceedings.","19 Apr 2004","2003","","","368","368","","1095-1350","0-7695-2027-8","10.1109/WCRE.2003.1287269","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1287269","","","","","","","","","IEEE","19 Apr 2004","","","IEEE","IEEE Conferences"
"Problems creating task-relevant clone detection reference data","A. Walenstein; N. Jyoti; Junwei Li; Yun Yang; A. Lakhotia","Software Research Laboratory Center for Advanced Computer Science, University of Louisiana, Lafayette, USA; Software Research Laboratory Center for Advanced Computer Science, University of Louisiana, Lafayette, USA; Software Research Laboratory Center for Advanced Computer Science, University of Louisiana, Lafayette, USA; Software Research Laboratory Center for Advanced Computer Science, University of Louisiana, Lafayette, USA; Software Research Laboratory Center for Advanced Computer Science, University of Louisiana, Lafayette, USA","10th Working Conference on Reverse Engineering, 2003. WCRE 2003. Proceedings.","19 Apr 2004","2003","","","285","294","","1095-1350","0-7695-2027-8","10.1109/WCRE.2003.1287259","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1287259","","Cloning;Humans;Detectors;Software tools;Software systems;Reverse engineering;Laboratories;Computer science;Uncertainty;Software engineering","","","","29","","16","IEEE","19 Apr 2004","","","IEEE","IEEE Conferences"
"Simple and efficient relational querying of software structures","D. Beyer; A. Noack; C. Lewerentz","Software Systems Engineering Research Group, Brandenburg University of Technology, Germany; Software Systems Engineering Research Group, Brandenburg University of Technology, Germany; Software Systems Engineering Research Group, Brandenburg University of Technology, Germany","10th Working Conference on Reverse Engineering, 2003. WCRE 2003. Proceedings.","19 Apr 2004","2003","","","216","225","","1095-1350","0-7695-2027-8","10.1109/WCRE.2003.1287252","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1287252","","Software systems;Computer architecture;Data structures;Reverse engineering;Cloning;Calculus;Boolean functions;Design engineering;Systems engineering and theory;Pattern analysis","","","","14","","39","IEEE","19 Apr 2004","","","IEEE","IEEE Conferences"
"Detecting merging and splitting using origin analysis","Lijie Zou; M. W. Godfrey","Software Architecture Group (SWAG) School of Computer Science, University of Waterloo, Canada; Software Architecture Group (SWAG) School of Computer Science, University of Waterloo, Canada","10th Working Conference on Reverse Engineering, 2003. WCRE 2003. Proceedings.","19 Apr 2004","2003","","","146","154","","1095-1350","0-7695-2027-8","10.1109/WCRE.2003.1287245","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1287245","","Merging;Software systems;Software maintenance;History;Software architecture;Computer science;Information analysis;Databases;Environmental management;Software tools","","","","3","","12","IEEE","19 Apr 2004","","","IEEE","IEEE Conferences"
"Automatic grading of student's programming assignments: an interactive process and suite of programs","D. S. Morris","Division ofComputer and Information Science, State University of New Jersey, Rutgers, Piscataway, NJ, USA","33rd Annual Frontiers in Education, 2003. FIE 2003.","26 Feb 2004","2003","3","","S3F","1","A system for automatic grading of programming assignments is described here. This grading system consists of a suite of Perl and Java programs, linked by a database, and driven by an interactive, user-grader controlled grading process. The rationale for the process, the process itself-and the process's interaction-with the programs, the database, and the user himself are discussed. This grading system has the ability to discover and accommodate unanticipated solutions by means of a grading process that is highly interactive with its user-the grader. It also has the ability to automatically accommodate a wide range of simple student errors, which can easily befuddle a more naive grading system. This system has been used since the Spring 2000 semester at Rutgers University, as a core part of the students' performance evaluation activities, in the Introduction to computer science course, where it routinely grades some 300-600 weekly assignments.","0190-5848","0-7803-7961-6","10.1109/FIE.2003.1265998","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1265998","","Automatic programming;Java;Databases;Education;Automatic control;Process control;Control systems;Computer errors;Computer science;Error analysis","computer science education;Java;Perl;educational courses;educational institutions","automatic homework grading;programming assignment;Perl program;Java program;user-grader controlled grading process;process interaction;naive grading system;Rutgers University;student performance evaluation;computer science course","","20","","8","IEEE","26 Feb 2004","","","IEEE","IEEE Conferences"
"Enhancing learning success in the introductory programming course","A. Greca; V. Jovanovic; J. Harris","Department of Computer Science, Georgia Southern University, Statesboro, GA, USA; Department of Computer Science, Georgia Southern University, Statesboro, GA, USA; Department of Computer Science, Georgia Southern University, Statesboro, GA, USA","33rd Annual Frontiers in Education, 2003. FIE 2003.","19 Feb 2004","2003","1","","T4C","15","This paper is the follow up of a work-in-progress presented at FIE 2002. The goal of the work is to implement those XP practices that contribute to rapid feedback and learning. Grading is based on student achievement. However, it is very important to ensure that a student's grade is directly related to course content and the amount they have learned. In this paper we present a detailed analysis of the method used along with the assessment of the final method. We also discuss our evaluation criteria and present the results of evaluation.","0190-5848","0-7803-7961-6","10.1109/FIE.2003.1263371","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1263371","","Programming profession;Education;Feedback;Information science;Writing;Formal languages;Ethics;Computer languages;Mathematics;Computer science","educational courses;computer science education;programming;teaching;C++ language","learning success;introductory programming course;work-in-progress;FIE 2002;feedback;student grading method;teaching method","","1","","13","IEEE","19 Feb 2004","","","IEEE","IEEE Conferences"
"A software methodology for detecting hardware faults in VLIW data paths","C. Bolchini","Dipartimento di Elettronica e Informazione, Politecnico di Milano, Milan, Italy","IEEE Transactions on Reliability","21 Jan 2004","2003","52","4","458","468","The proposed methodology aims to achieve processor data paths for VLIW architectures able to autonomously detect transient and permanent hardware faults while executing their applications. The approach, carried out on the compiled application software, provides the introduction of additional instructions for controlling the correctness of the computation with respect to failures in one of the data path functional units. The advantage of a software approach to hardware fault detection is interesting because it allows one to apply it only to the critical applications executed on the VLIW architecture, thus not causing a delay in the execution of noncritical tasks. Furthermore, by exploiting the intrinsic redundancy of this class of architectures no hardware modification is required on the data path so that no processor customization is necessary.","1558-1721","","10.1109/TR.2003.821935","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1260596","","Fault detection;Hardware;VLIW;Computer architecture;Application software;Delay;Computer aided instruction;Redundancy;Fault tolerance;Built-in self-test","parallel architectures;parallel machines;instruction sets;multiprocessing systems;redundancy;fault diagnosis;data flow computing;fault tolerant computing;error detection","hardware fault detection;VLIW data path;compiled application software;processor customization;noncritical task execution delay;software duplication;VLIW processor architecture","","35","","28","IEEE","21 Jan 2004","","","IEEE","IEEE Journals"
"Detection of redundant code using R/sup 2/D/sup 2/","A. M. Leitao","INESC-ID/Technical University of Lisbon, Lisboa, Portugal","Proceedings Third IEEE International Workshop on Source Code Analysis and Manipulation","20 Oct 2003","2003","","","183","192","We present the R/sup 2/D/sup 2/ redundancy detector. R/sup 2/D/sup 2/ identifies redundant code fragments on large software systems. For each pair of code fragments, R/sup 2/D/sup 2/ uses a combination of techniques ranging from syntax-based analysis to semantics-based analysis, that detect positive and negative evidences regarding the redundancy of the analyzed code fragments. These evidences are combined according to a well-defined model and fragments sufficiently redundant are reported to the user. R/sup 2/D/sup 2/ explores several techniques and heuristics to operate within reasonable time and space bounds and is designed to be extensible.","","0-7695-2005-7","10.1109/SCAM.2003.1238044","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1238044","","Programming profession;Computer languages;Software systems;Writing;Detectors;Cloning;Productivity;Force measurement;Software measurement;Time measurement","program diagnostics;redundancy;programming language semantics;computational linguistics","redundant code detection;R/sup 2/D/sup 2/;retargetable redundancy;deceit detector;large software systems;syntax based analysis;semantics based analysis","","4","","20","IEEE","20 Oct 2003","","","IEEE","IEEE Conferences"
"A taxonomy and an initial empirical study of bad smells in code","M. Mantyla; J. Vanhanen; C. Lassenius","Software Business and Engineering Institute, Helsinki University of Technology, Finland; Software Business and Engineering Institute, Helsinki University of Technology, Finland; Software Business and Engineering Institute, Helsinki University of Technology, Finland","International Conference on Software Maintenance, 2003. ICSM 2003. Proceedings.","7 Oct 2003","2003","","","381","384","This paper presents research in progress, as well as tentative findings related to the empirical study of so called bad code smells. We present a taxonomy that categorizes similar bad smells. We believe that taxonomy makes the smells more understandable and recognizes the relationships between smells. Additionally, we present our initial findings from an empirical study of the use of the smells for evaluating code quality in a small Finnish software product company. Our findings indicate that the taxonomy for the smells could help explain the identified correlations between the subjective evaluations of the existence of the smells.","1063-6773","0-7695-1905-9","10.1109/ICSM.2003.1235447","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1235447","","Taxonomy;Software maintenance;Software systems;Software quality;Programming;Internet;Software measurement;Cloning;Visualization;Logic","program compilers;object-oriented programming;software quality;software performance evaluation;software maintenance","taxonomy;empirical study;bad code smells;code quality;software quality;object-oriented context;correlations","","67","","17","IEEE","7 Oct 2003","","","IEEE","IEEE Conferences"
"Source-based software risk assessment","A. van Deursen; T. Kuipers","CWI, Delft University슠of슠Technology, Netherlands; Software Improvement Group, Netherlands","International Conference on Software Maintenance, 2003. ICSM 2003. Proceedings.","7 Oct 2003","2003","","","385","388","The paper reports on a method for software risk assessments that take into account ""primary facts"" and ""secondary facts"". Primary facts are those obtained through automatically analyzing the source code of a system, and secondary facts are those facts obtained from people working with or on the system, and available documentation. We describe how both types of facts are retrieved, and how we are bridging the interpretation gap from the raw facts (either primary or secondary) to a concise risk assessment, which includes recommendations to minimize the risk. This method has been developed while performing numerous risk assessments, and is continuously being fine-tuned.","1063-6773","0-7695-1905-9","10.1109/ICSM.2003.1235448","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1235448","","Risk management;Packaging;Software maintenance;Software systems;Documentation;Information retrieval;Paper technology;Security;Inspection;Feedback","software reliability;software maintenance;risk management;system documentation","source based software risk assessment;system source code;documentation","","22","","9","IEEE","7 Oct 2003","","","IEEE","IEEE Conferences"
"Exploring software systems","L. Moonen","CWI, Amsterdam, Netherlands","International Conference on Software Maintenance, 2003. ICSM 2003. Proceedings.","7 Oct 2003","2003","","","276","280","Software evolution is required to keep a software system in sync with the ever-changing needs of the system's users and environment. An unfortunate side-effect of evolution is that it often causes the knowledge about a system to degrade, which in turn impedes further evolution. In the dissertation, we investigate techniques and tools that help remedy this situation by supporting the exploration of a software system and improving its legibility (Moonen, 2002). We examine the analogy with urban exploration and present innovative techniques for the extraction, abstraction, and presentation of information needed for understanding software.","1063-6773","0-7695-1905-9","10.1109/ICSM.2003.1235430","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1235430","","Software systems;Software maintenance;Software tools;Degradation;Software performance;Costs;Information technology;Impedance;Data mining;Birds","software maintenance;software process improvement;software quality;reverse engineering","software systems;software evolution;evolution side-effects;urban exploration;information extraction;information abstraction;information presentation;software understanding;software exploration","","8","","22","IEEE","7 Oct 2003","","","IEEE","IEEE Conferences"
"Populating a Release History Database from version control and bug tracking systems","M. Fischer; M. Pinzger; H. Gall","Distributed Systems Group, University of Technology, Vienna, Austria; Distributed Systems Group, University of Technology, Vienna, Austria; Distributed Systems Group, University of Technology, Vienna, Austria","International Conference on Software Maintenance, 2003. ICSM 2003. Proceedings.","7 Oct 2003","2003","","","23","32","Version control and bug tracking systems contain large amounts of historical information that can give deep insight into the evolution of a software project. Unfortunately, these systems provide only insufficient support for a detailed analysis of software evolution aspects. We address this problem and introduce an approach for populating a release history database that combines version data with bug tracking data and adds missing data not covered by version control systems such as merge points. Then simple queries can be applied to the structured data to obtain meaningful views showing the evolution of a software project. Such views enable more accurate reasoning of evolutionary aspects and facilitate the anticipation of software evolution. We demonstrate our approach on the large open source project Mozilla that offers great opportunities to compare results and validate our approach.","1063-6773","0-7695-1905-9","10.1109/ICSM.2003.1235403","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1235403","","History;Databases;Control systems;Open source software;Computer errors;Application software;Information analysis;Technological innovation;Data engineering;Systems engineering and theory","database management systems;configuration management;project management;system monitoring;software maintenance;program debugging;query processing","Release History Database;version control;bug tracking systems;historical information;software evolution;merge points;large open source project;Mozilla;database population","","231","18","23","IEEE","7 Oct 2003","","","IEEE","IEEE Conferences"
"Development and maintenance of a Web site for a Bachelor program","H. M. Kienle; A. Weber; J. Martin; H. A. Muller","Computer Science Department, University of Victoria, Victoria, Canada; ExperEdge, Victoria, Canada; Psychologisches Institut, Universität Mainz, Mainz, Germany; Computer Science Department, University of Victoria, Victoria, Canada","Fifth IEEE International Workshop on Web Site Evolution, 2003. Theme: Architecture. Proceedings.","29 Sep 2003","2003","","","20","29","This paper describes our experiences with the development and maintenance of the BSENG Web site, which provides information about a new Bachelor program for software engineering at the University of Victoria. The site's requirements lead to a design that emphasizes simplicity to ease maintenance. We used Macromedia Dreamweaver to develop the site. During development, we identified two important maintenance tasks: detection of dead links and preservation of the site's navigational structure, that are not well supported by Dreamweaver. We discuss how we use the Rigi reverse engineering environment to aid the Web site developer with these maintenance tasks.","","0-7695-2016-2","10.1109/WSE.2003.1234005","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1234005","","Reverse engineering;Software engineering;Navigation;Documentation;Maintenance;Visualization;Computer science;Psychology;Software systems;Buildings","software maintenance;reverse engineering;Web design;computer science education;educational courses;educational computing;programming environments","Web development;Bachelor program;BSENG Web site;software engineering course;Macromedia Dreamweaver;Rigi;reverse engineering environment","","4","","29","IEEE","29 Sep 2003","","","IEEE","IEEE Conferences"
"Resolution of static clones in dynamic Web pages","N. Synytskyy; J. R. Cordy; T. Dean","School of Computing, Queen's University, Kingston, ONT, Canada; School of Computing, Queen's University, Kingston, ONT, Canada; School of Computing, Queen's University, Kingston, ONT, Canada","Fifth IEEE International Workshop on Web Site Evolution, 2003. Theme: Architecture. Proceedings.","29 Sep 2003","2003","","","49","56","Cloning is extremely likely to occur in Web sites, much more so than in other software. While some clones exist for valid reasons, or are too small to eliminate, cloning percentages of 30% or higher-not uncommon in Web sites-suggest that some improvements can be made. Finding and resolving the clones in Web documents is rather challenging, however: syntax errors and routine use of multiple languages complicate parsing the documents and finding clones, while lack of native code reuse tools forces the analyst to rely on other technologies for resolution. Here we present a way to find clones in Multilanguage Web documents, and resolve them using one of several code reuse techniques that are available in a dynamic Web site. Rather than picking a single resolution technique and relying on it exclusively, we pick it based on the clone in question, to minimize disruption to the structure of original documents.","","0-7695-2016-2","10.1109/WSE.2003.1234008","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1234008","","Cloning;Web pages;HTML;Encapsulation;Cascading style sheets;Software maintenance;Application software;Computer languages;Libraries;Algorithms","software maintenance;Web sites;hypermedia markup languages;software tools","Web pages;static clones;multilanguage Web documents;hypertext markup language","","13","1","13","IEEE","29 Sep 2003","","","IEEE","IEEE Conferences"
"Lessons learned in Web site architectures for public utilities","D. Sun; K. Wong; D. Moise","Department of Computing Science, University of Alberta, Canada; Department of Computing Science, University of Alberta, Canada; Department of Computing Science, University of Alberta, Canada","Fifth IEEE International Workshop on Web Site Evolution, 2003. Theme: Architecture. Proceedings.","29 Sep 2003","2003","","","93","100","Web sites are complex systems. They evolve all the time and are hard to understand and be maintained. This paper discusses some issues and challenges related to Web site development and maintenance. An evolutionary three-tier Web site architecture is presented based on our experiences in building and maintaining Web-based public utility management systems. In the current public utility domain, the coexistence of regulated and deregulated markets and diverse business rules bring many challenges to software engineers to build extensible and maintainable Web-based systems. New technologies provide opportunities to meet these requirements. However, how to adopt new technologies appropriately becomes another issue. Some design and implementation tradeoffs, as well as some lessons learned are considered in this paper.","","0-7695-2016-2","10.1109/WSE.2003.1234013","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1234013","","Service oriented architecture;Java;Computer architecture;Software systems;HTML;Buildings;Software maintenance;Maintenance engineering;Application software;Software architecture","software architecture;software maintenance;Web design;public utilities","Web site architecture;Web-based public utility management system;Web site maintenance;Web site development;deregulated markets;regulated markets;diverse business rules","","4","6","23","IEEE","29 Sep 2003","","","IEEE","IEEE Conferences"
"A tool-supported method to extract data and schema from Web sites","F. Estievenart; A. Francois; J. Henrard; J. . -L. Hainaut","CETIC research Center, Gosselies, Belgium; CETIC research Center, Gosselies, Belgium; Institut dInformatique, University of Namur, Namur, Belgium; Institut dInformatique, University of Namur, Namur, Belgium","Fifth IEEE International Workshop on Web Site Evolution, 2003. Theme: Architecture. Proceedings.","29 Sep 2003","2003","","","3","11","This paper presents a tool-supported method to reengineer Web sites, that is, to extract the page contents as XML documents structured by expressive DTDs or XML Schemas. All the pages that are recognized to express the same application (sub)domain are analyzed in order to derive their common structure. This structure is formalized by an XML document, called META, which is then used to extract an XML document that contains the data of the pages and a XML Schema validating these data. The META document can describe various structures such as alternative layout and data structure for the same concept, structure multiplicity and separation between layout and informational content. XML Schemas extracted from different page types are integrated and conceptualized into a unique schema describing the domain covered by the whole Web site. Finally, this conceptual schema is used to build the database of a renovated Web site. These principles are illustrated through a case study using the tools that create the META document, extract the data and the XML Schema.","","0-7695-2016-2","10.1109/WSE.2003.1234003","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1234003","","Data mining;Web pages;HTML;Reverse engineering;Information retrieval;Databases;XML;Cleaning;Conferences;Design methodology","data handling;Web sites;systems re-engineering;reverse engineering;XML","Web site reengineering;eXtensible Markup Language;data extraction;META document;reverse engineering","","11","8","19","IEEE","29 Sep 2003","","","IEEE","IEEE Conferences"
"Assessing the maintainability benefits of design restructuring using dependency analysis","R. Leitch; E. Stroulia","MacDonald Dettwiler and Associates Limited, Richmond, BC, Canada; Computing Science Department, University of Alberta, Edmonton, AB, Canada","Proceedings. 5th International Workshop on Enterprise Networking and Computing in Healthcare Industry (IEEE Cat. No.03EX717)","23 Sep 2003","2003","","","309","322","Software developers and project managers often have to assess the quality of software design. A commonly adopted hypothesis is that a good design should cost less to maintain than a poor design. We propose a model for quantifying the quality of a design from a maintainability perspective. Based on this model, we propose a novel strategy for predicting the ""return on investment"" (ROI) for possible design restructurings using procedure level dependency analysis. We demonstrate this approach with two exploratory Java case studies. Our results show that common low level source code transformations change the system dependency structure in a beneficial way, allowing recovery of the initial refactoring investment over a number of maintenance activities.","1530-1435","0-7695-1987-3","10.1109/METRIC.2003.1232477","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1232477","","Costs;Predictive models;Investments;Software design;Regression analysis;Business;Software quality;Quality management;Project management;Software development management","software maintenance;software quality;software cost estimation;systems re-engineering;cost-benefit analysis;software metrics","software design restructuring;procedure level dependency analysis;software quality;software maintenance;software cost estimation","","10","","14","IEEE","23 Sep 2003","","","IEEE","IEEE Conferences"
"Polymetric views - a lightweight visual approach to reverse engineering","M. Lanza; S. Ducasse","Software Composition Group, Institut für Informatik und angewandte Mathematik, University of Bern, Bern, Switzerland; Software Composition Group, Institut für Informatik und angewandte Mathematik, University of Bern, Bern, Switzerland","IEEE Transactions on Software Engineering","23 Sep 2003","2003","29","9","782","795","Reverse engineering software systems has become a major concern in software industry because of their sheer size and complexity. This problem needs to be tackled since the systems in question are of considerable worth to their owners and maintainers. In this article, we present the concept of a polymetric view, a lightweight software visualization technique enriched with software metrics information. Polymetric views help to understand the structure and detect problems of a software system in the initial phases of a reverse engineering process. We discuss the benefits and limits of several predefined polymetric views we have implemented in our tool CodeCrawler. Moreover, based on clusters of different polymetric views, we have developed a methodology which supports and guides a software engineer in the first phases of a reverse engineering of a large software system. We have refined this methodology by repeatedly applying it on industrial systems and illustrate it by applying a selection of polymetric views to a case study.","1939-3520","","10.1109/TSE.2003.1232284","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1232284","","Reverse engineering;Software systems;Visualization;Software metrics;Systems engineering and theory;Investments;Costs;Humans;Maintenance engineering;Computer industry","reverse engineering;object-oriented programming;software metrics;program visualisation;bibliographies","reverse engineering;software industry;polymetric view;lightweight software visualization technique;software metrics information;CodeCrawler;software engineer;large software system;object-oriented programming;software visualization","","216","3","55","IEEE","23 Sep 2003","","","IEEE","IEEE Journals"
"Reconstruction of successful software evolution using clone detection","F. Van Rysselberghe; S. Demeyer","Laboratory On Re-Engineering, Universiteit Antwerpen, Antwerp, Belgium; Laboratory On Re-Engineering, Universiteit Antwerpen, Antwerp, Belgium","Sixth International Workshop on Principles of Software Evolution, 2003. Proceedings.","15 Sep 2003","2003","","","126","130","In modern software engineering, researchers regard a software system as an organic life form that must continue to evolve to remain successful. Unfortunately, little is known about how successful software systems have evolved, and consequently little has been learned from previous experience. We demonstrate a heuristic to reconstruct evolution processes of existing software systems by exploiting techniques to detect duplication in large amounts of data. A case study, evaluating various versions of Tomcat using this heuristic, revealed that the removal of duplicated code is a much smaller concern than grouping functionality in classes with one clear responsibility.","","0-7695-1903-2","10.1109/IWPSE.2003.1231219","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1231219","","Cloning;Software systems;Software maintenance;Software engineering;Costs;Entropy;Earth;Data visualization;Conferences","software maintenance;software prototyping;software metrics;pattern recognition","software evolution reconstruction;clone detection;software engineering;software system;organic life form;Tomcat versions;duplicated code detection;software palaeontology heuristic;software maintenance","","26","","15","IEEE","15 Sep 2003","","","IEEE","IEEE Conferences"
"Automatic categorization algorithm for evolvable software archive","S. Kawaguchi; P. K. Garg; M. Matsushita; K. Inoue","Graduate School of Information Science and Technology, Osaka University, Toyonaka, Osaka, Japan; Zee Source, CA, USA; Graduate School of Information Science and Technology, Osaka University, Toyonaka, Osaka, Japan; Graduate School of Information Science and Technology, Osaka University, Toyonaka, Osaka, Japan","Sixth International Workshop on Principles of Software Evolution, 2003. Proceedings.","15 Sep 2003","2003","","","195","200","The number of software systems is increasing at a rapid rate. For example, SourceForge currently has about sixty thousand software systems registered, twenty-two thousand of which were added in the past twelve months. It is important for software evolution to search and use existing similar software systems from software archive. An evolution history of an existing similar software system is useful. We may even evolve a software system based on an existing one instead of creating it from scratch. We propose automatic software categorization algorithm to help finding similar software systems in software archive. At present, we leave open the issue about the nature of the categorization, and explore several known approaches including code clones-based similarity metric, decision trees, and latent semantic analysis. The results from applying each of the approaches gives us some insights into the problem space, and sets some directions for further work.","","0-7695-1903-2","10.1109/IWPSE.2003.1231227","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1231227","","Software algorithms;Software systems;Open source software;Information science;History;Decision trees;Databases;Foundries;Global communication;Software engineering","system documentation;software prototyping;decision trees;automatic programming;software metrics","automatic software categorization algorithm;evolvable software archive;software systems;SourceForge;code clones-based similarity metric;decision trees;latent semantic analysis","","17","","14","IEEE","15 Sep 2003","","","IEEE","IEEE Conferences"
"Proceedings. Sixth International Workshop on Principles of Software Evolution","",,"Sixth International Workshop on Principles of Software Evolution, 2003. Proceedings.","15 Sep 2003","2003","","","","","The following topics are dealt with: software development; formal specification; software evolution; COTS integration; software architecture; formal verification; requirements engineering; software reusability; program visualisation; software process improvement; object-oriented programming; public domain software; software engineering; software metrics; program diagnostics.","","0-7695-1903-2","10.1109/IWPSE.2003.1231203","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1231203","","Software packages;Software requirements and specifications;Object oriented programming;Software metrics;Software reusability;Software tools;Software fault diagnosis","software architecture;software packages;formal verification;formal specification;object-oriented programming;software metrics;software reusability;software process improvement;software tools;program diagnostics","software development;formal specification;software evolution;COTS integration;software architecture;formal verification;requirements engineering;software reusability;program visualisation;software process improvement;object-oriented programming;public domain software;software engineering;software metrics;program diagnostics","","","","","IEEE","15 Sep 2003","","","IEEE","IEEE Conferences"
"Beyond the refactoring browser: advanced tool support for software refactoring","T. Mens; T. Tourwe; F. Munoz","Programming Technology Laboratory, Vrije Universiteit Brussel, Brussels, Belgium; Programming Technology Laboratory, Vrije Universiteit Brussel, Brussels, Belgium; Programming Technology Laboratory, Vrije Universiteit Brussel, Brussels, Belgium","Sixth International Workshop on Principles of Software Evolution, 2003. Proceedings.","15 Sep 2003","2003","","","39","44","Current refactoring tools only provide support for performing selected refactorings. We show how tool support can be provided for the preparatory phases of refactoring as well, by determining when a software application should be refactored and which refactoring(s) in particular should be applied. We implemented a tool to detect bad smells and to propose adequate refactorings based on these smells, and validated this tool by carrying out experiments in three concrete case studies: the Soul application, the Smalltalk collection hierarchy, and the HotDraw application framework. We also show how our tool complements the Smalltalk refactoring browser.","","0-7695-1903-2","10.1109/IWPSE.2003.1231207","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1231207","","Software tools;Conferences","software tools;systems re-engineering;software maintenance;object-oriented programming;Smalltalk;program verification","software refactoring;advanced tool support;software application;Soul application;Smalltalk collection hierarchy;HotDraw application framework;Smalltalk refactoring browser","","11","","14","IEEE","15 Sep 2003","","","IEEE","IEEE Conferences"
"Decreasing distortion using low delay codes for bursty packet loss channels","E. Martinian; C. E. W. Sundberg","Massachusetts Institute of Technology, Cambridge, MA, USA; IBiquity Digital Corporation, Warren, NJ, USA","IEEE Transactions on Multimedia","26 Aug 2003","2003","5","3","285","292","The strict delay constraints of real-time communication applications in packet networks limit the use of automatic repeat request (ARQ) (retransmission systems) and error correction codes with extensive interleaving and decoding over long intervals. Since packet losses can introduce significant impairments, we study the effectiveness of low delay channel coding techniques to increase transmission quality across links with bursty losses. Specifically, we consider the benefits of the newly discovered class of low delay convolutional codes known as maximally short codes. By analyzing a Gaussian source transmitted over a Gilbert-Elliott channel, we demonstrate that these codes can achieve significant gains in comparison to uncoded transmission schemes or traditional coded schemes employing Reed-Solomon block codes. To complement and validate the theoretical analysis we also present results from informal listening tests with a voice-over-IP application.","1941-0077","","10.1109/TMM.2003.814794","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1223556","","Automatic repeat request;Propagation losses;Real time systems;Error correction codes;Interleaved codes;Decoding;Delay effects;Channel coding;Convolutional codes;Reed-Solomon codes","packet switching;delays;channel coding;convolutional codes;error correction codes;Internet telephony;forward error correction;rate distortion theory","distortion decrease;low delay codes;bursty packet loss channels;strict delay constraints;real-time communication applications;packet networks;ARQ;retransmission systems;automatic repeat request;error correction codes;extensive interleaving;decoding;packet losses;low-delay channel coding techniques;low-delay convolutional codes;maximally short codes;Gaussian source;Gilbert-Elliott channel;Reed-Solomon block codes;informal listening tests;voice-over-IP application;VoIP;FEC scheme","","9","","27","IEEE","26 Aug 2003","","","IEEE","IEEE Journals"
"Comments on ""Formal methods application: an empirical tale of software development""","D. M. Berry; W. F. Tichy","School of Computer Science, University of Waterloo, Waterloo, ONT, Canada; Department of Informatics, University of Karlsruhe, Karlsruhe, Germany","IEEE Transactions on Software Engineering","20 Jun 2003","2003","29","6","567","571","We comment on the experimental design and the result of the paper mentioned in the title. Our purpose is to show interested readers examples of what can go wrong with experiments in software research and how to avoid the attending problems.","1939-3520","","10.1109/TSE.2003.1205183","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1205183","","Application software;Design for experiments;Software tools;Books;Psychology;Data structures;Software engineering;Programming profession;Veins;Problem-solving","software engineering","experimental design;software development;software engineering;formal methods;software research","","22","","5","IEEE","20 Jun 2003","","","IEEE","IEEE Journals"
"Component rank: relative significance rank for software component search","K. Inoue; R. Yokomori; H. Fujiwara; T. Yamamoto; M. Matsushita; S. Kusumoto","Graduate School of Information Science and Technology, Osaka University, Toyonaka, Osaka, Japan; Graduate School of Information Science and Technology, Osaka University, Toyonaka, Osaka, Japan; Graduate School of Information Science and Technology, Osaka University, Toyonaka, Osaka, Japan; Japan Science and Technology Corporation, Kawaguchi, Saitama, Japan; Graduate School of Information Science and Technology, Osaka University, Toyonaka, Osaka, Japan; Graduate School of Information Science and Technology, Osaka University, Toyonaka, Osaka, Japan","25th International Conference on Software Engineering, 2003. Proceedings.","28 May 2003","2003","","","14","24","Collections of already developed programs are important resources for efficient development of reliable software systems. In this paper, we propose a novel method of ranking software components, called Component Rank, based on analyzing actual use relations among the components and propagating the significance through the use relations. We have developed a component-rank computation system, and applied it to various Java programs. The result is promising such that non-specific and generic components are ranked high. Using the Component Rank system as a core part, we are currently developing Software Product Archiving, analyzing, and Retrieving System named SPARS.","0270-5257","0-7695-1877-X","10.1109/ICSE.2003.1201184","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1201184","","Software systems;Java","software reliability;Java;object-oriented programming;directed graphs","reliable software systems;software component search;component-rank computation system;Java programs;software product archiving","","53","","25","IEEE","28 May 2003","","","IEEE","IEEE Conferences"
"Using replication and partitioning to build secure distributed systems","Lantian Zheng; S. Chong; A. C. Myers; S. Zdancewic","Computer Science Department, Cornell University, USA; Computer Science Department, Cornell University, USA; Computer Science Department, Cornell University, USA; Department of Computer and Information Science, University of Pennsylvania, USA","2003 Symposium on Security and Privacy, 2003.","21 May 2003","2003","","","236","250","A challenging unsolved security problem is how to specify and enforce system-wide security policies; this problem is even more acute in distributed systems with mutual distrust. This paper describes a way to enforce policies for data confidentiality and integrity in such an environment. Programs annotated with security specifications are statically checked and then transformed by the compiler to run securely on a distributed system with untrusted hosts. The code and data of the computation are partitioned across the available hosts in accordance with the security specification. The key contribution is automatic replication of code and data to increase assurance of integrity, without harming confidentiality, and without placing undue trust in any host. The compiler automatically generates secure run-time protocols for communication among the replicated code partitions. Results are given from a prototype implementation applied to various distributed programs.","1081-6011","0-7695-1940-7","10.1109/SECPRI.2003.1199340","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1199340","","Data security;Information security;Distributed computing;Computer security;Government;Military computing;Communication system security;Information systems;Computer science;Information science","data privacy;data integrity;protocols;program diagnostics;compiler generators;distributed processing","partitioning;confidentiality;automatic generation;secure run-time protocols;secure distributed systems;system-wide security policies;mutual distrust;data confidentiality;data integrity;static checking;compiler;security specifications;automatic code replication","","13","2","61","IEEE","21 May 2003","","","IEEE","IEEE Conferences"
"Towards a clone detection benchmark suite and results archive","A. Lakhotia; Junwei Li; A. Walenstein; Yun Yang","Software Research Laboratory, Center for Advanced Computer Science, University of Louisiana, Lafayette, USA; Software Research Laboratory, Center for Advanced Computer Science, University of Louisiana, Lafayette, USA; Software Research Laboratory, Center for Advanced Computer Science, University of Louisiana, Lafayette, USA; Software Research Laboratory, Center for Advanced Computer Science, University of Louisiana, Lafayette, USA","11th IEEE International Workshop on Program Comprehension, 2003.","21 May 2003","2003","","","285","286","Source code clones are copies or near-copies of other portions of code, often created by copying and pasting portions of source code. This working session is concerned with building a communal research infrastructure for clone detection. The intention of this working session is to try to build a consensus on how to continue to build a benchmark suite and results archive for clone- and source comparison-related research and development. The working session is structured to foster discussion and debates over what should be collected in the archive, and how best to do it.","1092-8138","0-7695-1883-4","10.1109/WPC.2003.1199215","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1199215","","Cloning;Benchmark testing;Infrared detectors;Software testing;System testing;Software systems;Laboratories;Computer science;Buildings;Research and development","software performance evaluation;program diagnostics;reverse engineering","clone detection benchmark suite;source code clones;results archive;communal research infrastructure","","9","","10","IEEE","21 May 2003","","","IEEE","IEEE Conferences"
"Are decomposition slices clones?","K. Gallagher; L. Layman","Computer Science Department, Loyola College, Baltimore, MD, USA; Computer Science Department, North Carolina State University, Raleigh, NC, USA","11th IEEE International Workshop on Program Comprehension, 2003.","21 May 2003","2003","","","251","256","When computing program slices on all variables in a system, we observed that many of these slices are the same. This leads to the question: Are we looking at software clones? We discuss the genesis of this phenomena and present some of the data observations that led to the question. The answer to our query is not immediately clear. We end by presenting arguments both pro and con. Supporting the affirmative, we observed that some slice-clones are evidently the result of the usual genesis of software clones: failure to note appropriate abstractions. Also, slice-clones assist in program comprehension by coalescing into one program fragment the computations on many different variables. Opposing the proposition, we note that slice-clones do not arise due to programmer intent or the copying of existing idioms.","1092-8138","0-7695-1883-4","10.1109/WPC.2003.1199209","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1199209","","Cloning;Computer science;Software maintenance;Displays;Educational institutions;Programming profession;Accidents;Reverse engineering;Data analysis;Automatic control","reverse engineering;software maintenance;program slicing","program slices;software clones;program comprehension;program fragment;software maintenance","","3","1","13","IEEE","21 May 2003","","","IEEE","IEEE Conferences"
"Comprehending reality - practical barriers to industrial adoption of software maintenance automation","J. R. Cordy","School of Computing, Queen''s University, Kingston, ONT, Canada","11th IEEE International Workshop on Program Comprehension, 2003.","21 May 2003","2003","","","196","205","Recent years have seen many significant advances in program comprehension and software maintenance automation technology. In spite of the enormous potential savings in software maintenance costs, for the most part adoption of these ideas in industry remains at the experimental prototype stage. In this paper the author explores some of the practical reasons for industrial resistance to adoption of software maintenance automation. Based on the experience of six years of software maintenance automation services to the financial industry involving more than 4.5 Gloc of code at Legasys Corporation, the author discusses some of the social, technical and business realities that lie at the root of this resistance, outlines various Legasys attempts overcome these barriers, and suggests some approaches to software maintenance automation that may lead to higher levels of industrial acceptance in the future.","1092-8138","0-7695-1883-4","10.1109/WPC.2003.1199203","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1199203","","Computer industry;Software maintenance;Automation;Software systems;Application software;Conferences;Data processing;Banking;Councils;Layout","software maintenance;reverse engineering;financial data processing;social aspects of automation;automatic programming;computer aided software engineering","software maintenance automation;program comprehension;financial industry;Legasys Corporation;industrial acceptance;social realities","","59","","42","IEEE","21 May 2003","","","IEEE","IEEE Conferences"
"YAAB (Yet another AST browser): using OCL to navigate ASTs","G. Antoniol; M. Di Penta; E. Merlo","RCOST-Research Centre on Software Technology, Department of Engineering, University of Sannio, Benevento, Italy; RCOST-Research Centre on Software Technology, Department of Engineering, University of Sannio, Benevento, Italy; Ecole Polytechnique de Montrèal, Montreal, Canada","11th IEEE International Workshop on Program Comprehension, 2003.","21 May 2003","2003","","","13","22","In the last decades several tools and environments defined and introduced languages for querying, navigating and transforming abstract syntax trees. These environments were meant to support software maintenance, reengineering and program comprehension activities. Instead of introducing a new language, this paper proposes to adopt the Object Constraint Language (OCL) to express queries over an object model representing the abstract syntax tree of the code to be analyzed. OCL is part of the UML lingua franca and thus several advantages can be readily obtained. Central to the idea is to shift the analysis paradigm from a tree-based to an object-oriented paradigm, and to provide a meta-model decoupling the query language from the target language. This paper presents the current status in implementing an OCL interpreter with the ability of querying an object model representing the abstract syntax tree, as well as some interesting applications, such as extracting software metrics or computing clones.","1092-8138","0-7695-1883-4","10.1109/WPC.2003.1199185","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1199185","","Navigation;Software maintenance;Unified modeling language;Documentation;Software systems;Object oriented modeling;Reverse engineering;Computer languages;Software tools;Database languages","software maintenance;computational linguistics;object-oriented programming;software metrics","abstract syntax trees;software maintenance;software reengineering;program comprehension;object constraint language;UML lingua franca;object-oriented paradigm;query language;OCL interpreter;software metrics;computing clones","","8","1","29","IEEE","21 May 2003","","","IEEE","IEEE Conferences"
"Effective, automatic procedure extraction","R. Komondoor; S. Horwitz","University of Wisconsin, Madison, WI, USA; University of Wisconsin, Madison, WI, USA","11th IEEE International Workshop on Program Comprehension, 2003.","21 May 2003","2003","","","33","42","Legacy code can often be made more understandable and maintainable by extracting out selected sets of statements to form procedures and replacing the extracted code with procedure calls. Sets of statements that are noncontiguous and/or include non-local jumps (caused by go-tos, breaks, continues, etc.) can be difficult to extract, and usually cause previous automatic-extraction algorithms to fail or to produce poor results. The chief contributions of this paper are a semantics-preserving algorithm for extracting ""difficult"" sets of statements, and a study that compares the algorithm both to an ideal extractor (a human) and to previously reported automatic approaches. We found that ""difficult"" examples do arise frequently in practice, and that our algorithm is a significant improvement over previous work, achieving ideal results on over 70% of the difficult cases.","1092-8138","0-7695-1883-4","10.1109/WPC.2003.1199187","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1199187","","Humans;Programming profession;Performance analysis;Conferences","programming language semantics;software maintenance;reverse engineering","legacy code;procedure calls;automatic-extraction algorithms;semantics preserving algorithm","","28","1","24","IEEE","21 May 2003","","","IEEE","IEEE Conferences"
"Design and implementation of the Trusted BSD MAC framework","R. Watson; B. Feldman; A. Migus; C. Vance","Network Associates Laboratories, Rockville, MD, USA; Network Associates Laboratories, Rockville, MD, USA; Network Associates Laboratories, Rockville, MD, USA; Network Associates Laboratories, Rockville, MD, USA","Proceedings DARPA Information Survivability Conference and Exposition","22 Apr 2003","2003","1","","38","49 vol.1","Developing access control extensions for operating systems is an expensive and time-consuming task. Mechanisms available for access control extension lag behind industry standard extension solutions for file systems, process schedulers, and device drivers, and suffer from a number of serious flaws in modem multi-processor, multi-threaded kernels. In this paper we explore the limitations of current technologies for security extension. We describe the Trusted BSD MAC Framework, a flexible and modular environment for operating system access control extensions on the open source Free BSD platform. The TrustedBSD MAC Framework permits extensions to be introduced at compile-time, boot-time, or at run-time, and provides a number of services to support dynamically introduced policies, including policy-agnostic object labeling services and application interfaces. We discuss the design and implementation of the framework, as well as the an implementation of a fixed-label Biba integrity policy based on the framework.","","0-7695-1897-4","10.1109/DISCEX.2003.1194871","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1194871","","Access control;Operating systems;Electrical equipment industry;Industrial control;File systems;Job shop scheduling;Modems;Kernel;Security;Runtime","operating system kernels;authorisation;public domain software","multi-processor multi-threaded kernels;TrustedBSD MAC Framework;operating system access control extensions;open source FreeBSD platform;run time;compile time extension;boot time extension;policy-agnostic object labeling services;application interfaces;fixed-label Biba integrity policy","","5","15","20","IEEE","22 Apr 2003","","","IEEE","IEEE Conferences"
"Procedure cloning and integration for converting parallelism from coarse to fine grain","Won So; A. Dean","Department of Electrical and Computer Engineering, NC State University, Raleigh, NC, USA; Department of Electrical and Computer Engineering, NC State University, Raleigh, NC, USA","Seventh Workshop on Interaction Between Compilers and Computer Architectures, 2003. INTERACT-7 2003. Proceedings.","8 Apr 2003","2003","","","27","36","This paper introduces a method for improving program run-time performance by gathering work in an application and executing it efficiently in an integrated thread. Our methods extend whole-program optimization by expanding the scope of the compiler through a combination of software thread integration and procedure cloning. In each experiment we integrate a frequently executed procedure with itself twice or thrice, creating two clones. Then, based on profile data we select at compile time the fastest version (original or clone) and modify call sites as needed. We demonstrate our technique by cloning and integrating three procedures from cjpeg and djpeg at the C source code level, compiling with four compilers for the Itanium EPIC architecture and measuring the performance with the on-chip performance measurement units. For cjpeg, which is not significantly constrained by the i-cache, we find integration consistently improves code generated by all compilers but one, with a mean program speedup of 11.99%.","","0-7695-1889-3","10.1109/INTERA.2003.1192353","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1192353","","Cloning;Yarn;Embedded system;Data analysis;Parallel processing;Program processors;Runtime;Application software;Optimizing compilers;Measurement","parallelising compilers;multi-threading;software performance evaluation;optimising compilers;cache storage;embedded systems;parallel architectures","procedure cloning;program run-time performance;integrated thread;whole-program optimization;software thread integration;profile data;cjpeg;djpeg;C source code level;Itanium EPIC architecture;on-chip performance measurement;i-cache;code generation;program speedup","","1","2","27","IEEE","8 Apr 2003","","","IEEE","IEEE Conferences"
"Finding function clones in Web applications","F. Lanubile; T. Mallardo","Dipartimento di Informatica, University of Bari, Bari, Italy; RCOST-Research Center on Software Technology, University of Sannio, Benevento, Italy","Seventh European Conference onSoftware Maintenance and Reengineering, 2003. Proceedings.","8 Apr 2003","2003","","","379","386","Many Web applications use a mixture of HTML and scripting language code as the front-end to business services. Analogously to traditional applications, redundant code is introduced by copy-and-paste practices. Code duplication is a pathological form of software reuse because of its effects on the maintenance of large software systems. This paper describes how a simple semi-automated approach can be used to identity cloned functions within scripting code of Web applications. The results obtained from applying our approach to three Web applications show that the approach is useful for a fast selection of script function clones, and can be applied to prevent clone spreading or to remove redundant scripting code.","1534-5351","0-7695-1902-4","10.1109/CSMR.2003.1192447","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1192447","","Cloning;Application software;HTML;Software maintenance;Web server;Software systems;Pathology;Java;Programming profession;Writing","Web sites;Internet;hypermedia markup languages;authoring languages;business data processing;software reusability;software maintenance","function clones;Web applications;HTML;scripting language code;business services;copy-and-paste practices;code duplication;software reuse;software maintenance;script function clones;redundant scripting code removal","","29","2","19","IEEE","8 Apr 2003","","","IEEE","IEEE Conferences"
"A metric-based approach to enhance design quality through meta-pattern transformations","L. Tahvildari; K. Kontogiannis","Department of Electrical and Computer Engineering, University of Waterloo, Waterloo, ONT, Canada; Department of Electrical and Computer Engineering, University of Waterloo, Waterloo, ONT, Canada","Seventh European Conference onSoftware Maintenance and Reengineering, 2003. Proceedings.","8 Apr 2003","2003","","","183","192","During the evolution of object-oriented legacy systems, improving the design quality is. most often a highly demanded objective. For such systems which have a large number of classes and are subject to frequent modifications, detection and correction of design defects is a complex task. The use of automatic detection and correction tools can be helpful for this task. Various research approaches have proposed transformations that improve the quality of an object-oriented systems while preserving its behavior This paper proposes a framework where a catalogue of object-oriented metrics can be used-as indicators for automatically detecting situations where a particular transformation can be applied to improve the quality of an object-oriented legacy system. The correction process is based on analyzing the impact of various meta-pattern transformations on these object-oriented metrics.","1534-5351","0-7695-1902-4","10.1109/CSMR.2003.1192426","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1192426","","Face detection;Programming;Software quality;Laboratories;Scholarships;Software metrics;Design methodology;Software maintenance;Encapsulation;Sorting","object-oriented programming;software metrics;software quality;systems re-engineering;software maintenance","object-oriented legacy systems;design quality;design defects;automatic detection and correction tools;object-oriented systems;meta-pattern transformations;object-oriented metrics","","40","","36","IEEE","8 Apr 2003","","","IEEE","IEEE Conferences"
"Identifying refactoring opportunities using logic meta programming","T. Tourwe; T. Mens","Programming Technology Laboratory, Vrije Universiteit Brussel, Brussels, Belgium; Programming Technology Laboratory, Vrije Universiteit Brussel, Brussels, Belgium","Seventh European Conference onSoftware Maintenance and Reengineering, 2003. Proceedings.","8 Apr 2003","2003","","","91","100","We show how automated support can be provided for identifying refactoring opportunities, e.g., when an application's design should be refactored and which refactoring(s) in particular should be applied. Such support is achieved by using the technique of logic meta programming to detect so-called bad smells and by defining a framework that uses this information to propose adequate refactorings. We report on some initial but promising experiments that were applied using the proposed techniques.","1534-5351","0-7695-1902-4","10.1109/CSMR.2003.1192416","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1192416","","Logic programming;Guidelines;Degradation;Automatic programming;Aging;Computer languages;Phase detection;Software performance;Application software;Inspection","logic programming;systems re-engineering;software tools;computer aided software engineering;object-oriented programming","refactoring;logic meta programming;experiments;object oriented programming;software tools;application design;system reengineering","","58","","31","IEEE","8 Apr 2003","","","IEEE","IEEE Conferences"
"Automated Cobol to Java recycling","M. Mossienko","LANIT-TERCOM, Saint Petersburg State University, Saint Petersburg, Russia","Seventh European Conference onSoftware Maintenance and Reengineering, 2003. Proceedings.","8 Apr 2003","2003","","","40","50","In this paper an approach for automated source-to-source translation from Cobol to Java is presented. The primary goal of this approach is to ensure that the generated code will be maintainable. In some cases this is achieved even by sacrificing complete functional equivalence of the generated code with the original program. We also intensively use encapsulation to hide away difficulties of language conversion process from the maintenance engineer. We discuss results of practical application of this approach on examples taken from the real-life programs.","1534-5351","0-7695-1902-4","10.1109/CSMR.2003.1192409","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1192409","","Java;Recycling;Encapsulation;Software systems;Hardware;Maintenance engineering;Operating systems;Computer languages;TCPIP;XML","COBOL;Java;object-oriented programming;program interpreters;software maintenance;data encapsulation;software tools","automated Cobol to Java recycling;automated source-to-source translation;software maintenance;legacy applications;encapsulation;language conversion process","","17","3","31","IEEE","8 Apr 2003","","","IEEE","IEEE Conferences"
"The role of constructors in the context of refactoring object-oriented systems","R. Najjar; S. Counsell; G. Loizou; K. Mannock","Department of Computer Science, Brirbeck College, University of London, London, UK; Department of Computer Science, Brirbeck College, University of London, London, UK; Department of Computer Science, Brirbeck College, University of London, London, UK; Department of Computer Science, Brirbeck College, University of London, London, UK","Seventh European Conference onSoftware Maintenance and Reengineering, 2003. Proceedings.","8 Apr 2003","2003","","","111","120","Constructors play an essential role in object-oriented (OO) languages as a means of object creation. Yet, very little empirical evidence exists on constructors, trends in their composition and how they impact comprehension and encapsulation of OO classes. In this paper, we empirically investigate the opportunities, benefits and problems of refactoring class constructors across a sample of classes from five Java systems. The refactoring used, namely, replacing multiple constructors with creation methods, was applied to each of a set of classes containing three or more constructors. Empirical results showed benefits in terms of removed (duplicated) lines of code across the majority of systems. They also showed the potential for improved class comprehension by the creation of non-constructor methods (as a replacement for constructors) and improved encapsulation of class elements through use of a private catch-all constructor. We also provide evidence from five C++ systems which suggests similar trends in constructors to those found for Java. In terms of problems encountered, frequent and inconsistent use of the super construct made refactoring prohibitively difficult in some cases; the existence of Java interfaces also means a lack of scope for constructor refactoring. The results indicate clear and tangible benefits to be gained from investigation and implementation of refactoring techniques in Java, but with caution being exercised in certain cases; refactoring in practice is not as straightforward as the theory suggests.","1534-5351","0-7695-1902-4","10.1109/CSMR.2003.1192418","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1192418","","Software maintenance","C++ language;Java;object-oriented programming;encapsulation;software maintenance","refactoring;object-oriented systems;Java systems;multiple constructors;creation methods;private catch-all constructor;C++ systems;Java;object-oriented languages;object creation;encapsulation;comprehension;class constructors","","15","1","23","IEEE","8 Apr 2003","","","IEEE","IEEE Conferences"
"Multiprocessor mapping of process networks: a JPEG decoding case study","E. A. de Kock","Philips Research, Eindhoven, Netherlands","15th International Symposium on System Synthesis, 2002.","23 May 2005","2002","","","68","73","We present a system-level design and programming method for embedded multiprocessor systems. The aim of the method is to improve the design time and design quality by providing a structured approach for implementing process networks. We use process networks as re-usable and architecture-independent functional specifications. The method facilitates the cost-driven and constraint-driven source code transformation of process networks into architecture-specific implementations in the form of communicating tasks. We apply the method to implement a JPEG decoding process network in software on a set of MIPS processors. We apply three transformations to optimize synchronization rates and data transfers and to exploit data parallelism for this target architecture. We evaluate the impact of the source code transformations and the performance of the resulting implementations in terms of design time, execution time, and code size. The results show that process networks can be implemented quickly and efficiently on embedded multiprocessor systems.","","1-58113-576-9","10.1145/581199.581216 ","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1227154","","Decoding;Computer aided software engineering;Computer architecture;Parallel processing;Parallel programming;System-level design;Multiprocessing systems;Embedded system;Signal processing algorithms;Permission","embedded systems;multiprocessing systems;parallel architectures;high level synthesis","embedded multiprocessor;system-level design;process network;JPEG decoding;task-level parallelism;embedded multimedia systems;MIPS processors","","25","","","","23 May 2005","","","IEEE","IEEE Conferences"
"Constructing reusable testbenches","A. Wakefield; B. J. Mohd","Synopsys Professional Services, MA, USA; Synopsys Professional Services, MA, USA","Seventh IEEE International High-Level Design Validation and Test Workshop, 2002.","26 Aug 2003","2002","","","151","155","This paper explores a novel approach to classifying, enabling and measuring testbench reuse. Six levels of testbench reusability are presented ranging from utility (lowest), to communication, transactor, generate/check, configuration and tests (highest). The layers provide a template for implementation and enable reuse on a layer-by-layer basis. A qualitative measure of reuse is available directly from the layered model while a quantitative measure is available by examining the effort required to build the layers.","","0-7803-7655-2","10.1109/HLDVT.2002.1224445","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1224445","","Object oriented modeling;Vehicle driving;Costs;Computer architecture;Software testing;Process design;Performance evaluation;ISO;Open systems;Communication system control","formal verification;object-oriented methods;software reusability;design for testability","reusable testbenches;testbench reusability;layered model;communication;transactor;generation/checking;configuration;tests","","","","4","IEEE","26 Aug 2003","","","IEEE","IEEE Conferences"
"Finite-state modeling in software design: some fundamental techniques","S. Kundu","Computer Science Department, Louisiana State University, Baton Rouge, LA, USA","Ninth Asia-Pacific Software Engineering Conference, 2002.","28 Feb 2003","2002","","","317","324","Although finite-state models have been used in software modeling for some time, a general method for building and manipulating such models which directly relates to a program's structure is not readily available. We fill this gap by constructing a canonical finite-state model M(P) from the flowchart of a program P. We then present several methods for simplifying M(P) which correspond to creating higher level models for P and to improving P by eliminating its design flaws. Finally, we show that states based on data-values and their abstractions give us greater flexibility in creating finite-state models that can be used in practice to build the models from requirements.","1530-1362","0-7695-1850-8","10.1109/APSEC.2002.1183001","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1183001","","Software design;Buildings;Software testing;Computer science;Flowcharts;Application software;Formal verification;Concrete;Automata;Programming","software engineering","software design;software modeling;program structure;canonical finite-state model;flowchart;design flaws;data values;data abstractions;requirements","","2","","14","IEEE","28 Feb 2003","","","IEEE","IEEE Conferences"
"On detection of gapped code clones using gap locations","Y. Ueda; T. Kamiya; S. Kusumoto; K. Inoue","Graduate School of Information Science and Technology, Osaka University, Osaka, Japan; Graduate School of Information Science and Technology, Osaka University, Osaka, Japan; Graduate School of Information Science and Technology, Osaka University, Osaka, Japan; Graduate School of Information Science and Technology, Osaka University, Osaka, Japan","Ninth Asia-Pacific Software Engineering Conference, 2002.","28 Feb 2003","2002","","","327","336","It is generally accepted that a code clone is one factor making software maintenance difficult. A code clone is a code portion in source files that is identical or similar to another. Clones are introduced because of various reasons such as reusing code by 'copy-and-paste' and so on. Since developers usually modify the copied-and-pasted code portions, there are gaps between them and the original code portion. We call such code portions including gaps gapped code clones. Several code clone detection methods, which consider such gaps, have been proposed. However, it is costly to detect all gapped code clones. This paper proposes a new method to visualize gapped code clones as if they were actually detected, based on the detection results of conventional code clones. Using the proposed method, the developer can specify target clones efficiently. Moreover, we implement the proposed method in the maintenance support environment and conduct an experimental evaluation.","1530-1362","0-7695-1850-8","10.1109/APSEC.2002.1183002","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1183002","","Cloning;Software engineering","software maintenance;program visualisation;software reusability","gapped code clone detection;visualization;maintenance support environment;software maintenance;source files;gap locations;code reuse","","19","2","20","IEEE","28 Feb 2003","","","IEEE","IEEE Conferences"
"Compiling for fine-grain concurrency: planning and performing software thread integration","A. G. Dean","Center for Embedded Systems Research, Department of Electrical and Computer Engineering, North Carolina State University, Raleigh, NC, USA","23rd IEEE Real-Time Systems Symposium, 2002. RTSS 2002.","25 Feb 2003","2002","","","103","113","Embedded systems require control of many concurrent real-time activities, leading to system designs which feature multiple hardware peripherals with each providing a specific, dedicated service. These peripherals increase system size, cost, weight, power and design time. Software thread integration (STI) provides low-cost thread concurrency on general-purpose processors by automatically interleaving multiple (potentially real-time) threads of control into one. This simplifies hardware to software migration (which eliminates dedicated hardware) and can help embedded system designers meet design constraints. This paper introduces automated methods for planning and performing the code transformations needed for integration of functions with more sophisticated control flows than in previous work. We demonstrate the methods by using Thrint, our post-pass thread-integrating compiler, to automatically integrate multiple threads for a sample real-time embedded system with fine-grain concurrency. The sample application generates an NTSC monochrome video signal (sending out a stream of pixels to a video DAC) with STI to replace a video refresh controller IC Using Thrint reduces integration time from days to minutes and, by reclaiming idle time, speeds up graphics rendering by 3.2/spl times/ to 3.8/spl times/ in the three functions examined.","1052-8725","0-7695-1851-6","10.1109/REAL.2002.1181566","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1181566","","Concurrent computing;Software performance;Yarn;Embedded system;Automatic control;Hardware;Real time systems;Power system planning;Control systems;Costs","concurrency control;embedded systems;program compilers;planning;rendering (computer graphics);video signal processing","embedded systems;concurrent real-time activities;fine-grain concurrency;compiling;software thread integration planning;multiple hardware peripherals;low-cost thread concurrency;general-purpose processors;automatic multiple control thread interleaving;hardware to software migration;automated methods;code transformations;Thrint;post-pass thread-integrating compiler;NTSC monochrome video signal;graphics rendering","","2","2","22","IEEE","25 Feb 2003","","","IEEE","IEEE Conferences"
"Knowledge-based library re-factoring for an open source project","M. Di Penta; M. Neteler; G. Antoniol; E. Merlo","Department of Engineering,RCOST Research Centre on Software Technology, University of Sannio, Benevento, Italy; ITC IRST, Italy; Department of Engineering,RCOST Research Centre on Software Technology, University of Sannio, Benevento, Italy; École Polytechnique de Montréal, Montreal, Canada","Ninth Working Conference on Reverse Engineering, 2002. Proceedings.","29 Jan 2003","2002","","","319","328","Software miniaturization is a form of software re-factoring focused on reducing an application to its bare bones. Porting an application on a hand-held device is likely to require a preliminary step of software miniaturization, plus the development of device drivers dedicated to the new environment and hardware architecture. This paper presents the process and lessons learned in re-factoring a large open source application to remove any excess, introduce shared libraries, remove circular dependencies among libraries and, more generally, to minimize inter-library dependencies. While the final goal was to fully exploit shared library capabilities, among the various possibilities we defined a process based on existing knowledge about the application, and aimed to minimize the maintenance effort required by miniaturization activities.","1095-1350","0-7695-1799-4","10.1109/WCRE.2002.1173089","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1173089","","Open source software;Software libraries;Application software;Computer industry;Personal digital assistants;Ground penetrating radar;Bones;Bandwidth;Multimedia databases;Linux","software libraries;software maintenance;mobile computing;systems re-engineering","knowledge-based library re-factoring;software miniaturization;device drivers;open source project;hand-held device;shared libraries;inter-library dependencies;maintenance","","4","1","31","IEEE","29 Jan 2003","","","IEEE","IEEE Conferences"
"Java quality assurance by detecting code smells","E. van Emden; L. Moonen","CWI, Netherlands; CWI, Netherlands","Ninth Working Conference on Reverse Engineering, 2002. Proceedings.","29 Jan 2003","2002","","","97","106","Software inspection is a known technique for improving software quality. It involves carefully examining the code, the design, and the documentation of software and checking these for aspects that are known to be potentially problematic based on past experience. Code smells are a metaphor to describe patterns that are generally associated with bad design and bad programming practices. Originally, code smells are used to find the places in software that could benefit from refactoring. In this paper we investigate how the quality of code can be automatically assessed by checking for the presence of code smells and how this approach can contribute to automatic code inspection. We present an approach for the automatic detection and visualization of code smells and discuss how this approach can be used in the design of a software inspection tool. We illustrate the feasibility of our approach with the development of jCOSMO, a prototype code smell browser that detects and visualizes code smells in JAVA source code. Finally, we show how this tool was applied in a case study.","1095-1350","0-7695-1799-4","10.1109/WCRE.2002.1173068","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1173068","","Java;Quality assurance;Inspection;Software quality;Visualization;Documentation;Software design;Software tools;Software prototyping;Prototypes","Java;software quality;program visualisation","software quality;code smells;Java;refactoring;software inspection;quality assurance;automatic code inspection","","149","","25","IEEE","29 Jan 2003","","","IEEE","IEEE Conferences"
"Maintenance of object oriented systems through re-engineering: a case study","M. Satpathy; N. T. Siebel; D. Rodriguez","Applied Software Engineering Group; Department of Computer Science, The University of Reading, Reading, England; Applied Software Engineering Group","International Conference on Software Maintenance, 2002. Proceedings.","29 Jan 2003","2002","","","540","549","Unregulated evolution of software often leads to software ageing which not only makes the product difficult to maintain but also breaks the consistency between design and implementation. In such a case, it may become necessary to re-engineer the software so that it becomes maintainable again. In this paper we present the case study of the reengineering of the People Tracking subsystem of a surveillance system written in C++. We discuss the problems, the challenges and the approaches taken, and we show how the re-engineered product is now better maintainable. We also discuss the generation of the relevant artefacts - from requirement document through to design document.","1063-6773","0-7695-1819-2","10.1109/ICSM.2002.1167815","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1167815","","Computer aided software engineering;Software maintenance;Reverse engineering;Software engineering;Surveillance;Computer vision;Computer science;Aging;Hardware;Preventive maintenance","software maintenance;systems re-engineering;reverse engineering;object-oriented programming;surveillance","object oriented systems maintenance;re-engineering;People Tracking subsystem;surveillance system;C++ software;artefacts;requirement document;design document","","2","","21","IEEE","29 Jan 2003","","","IEEE","IEEE Conferences"
"A quantitative evaluation of maintainability enhancement by refactoring","Y. Kataoka; T. Imai; H. Andou; T. Fukaya","System Engineering Laboratory, Toshiba Corporation, Kawasaki, Kanagawa, Japan; System Engineering Laboratory, Toshiba Corporation, Kawasaki, Kanagawa, Japan; System Engineering Laboratory, Toshiba Corporation, Kawasaki, Kanagawa, Japan; System Engineering Laboratory, Toshiba Corporation, Kawasaki, Kanagawa, Japan","International Conference on Software Maintenance, 2002. Proceedings.","29 Jan 2003","2002","","","576","585","Program refactoring is a technique to enhance the maintainability of a program. Although the concept itself is considered to be effective, there are few quantitative evaluation of its impact to the software maintainability. It is sometimes difficult to judge whether the refactoring in question should be applied or not without knowing the effect accurately. We propose a quantitative evaluation method to measure the maintainability enhancement effect of program refactoring. We focused on the coupling metrics to evaluate the refactoring effect. By comparing the coupling before and after the refactoring, we could evaluate the degree of maintainability enhancement. We applied our method to a certain program and showed that our method was really effective to quantify the refactoring effect and helped us to choose appropriate refactorings.","1063-6773","0-7695-1819-2","10.1109/ICSM.2002.1167822","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1167822","","Software maintenance;Programming profession;Process planning;Maintenance engineering;Systems engineering and theory;Laboratories;Software design;Computer bugs;Performance analysis;Project management","software maintenance;software metrics","program refactoring;maintainability enhancement;quantitative evaluation;coupling metrics","","72","1","14","IEEE","29 Jan 2003","","","IEEE","IEEE Conferences"
"Evaluating clone detection tools for use during preventative maintenance","E. Burd; J. Bailey","The Research Institute in Software Evolution, University of Durham, Durham, UK; The Research Institute in Software Evolution, University of Durham, Durham, UK","Proceedings. Second IEEE International Workshop on Source Code Analysis and Manipulation","6 Jan 2003","2002","","","36","43","This paper describes the results of a process whereby the detection capability of 5 code replication detection tools for large software application are evaluated. Specifically this work focuses on the benefits of identification for preventative maintenance that is with the aim to remove some of the identified clones from the source code. A number of requirements are therefore identified upon which the tools are evaluated. The results of the analysis processes show that each tool has its own strengths and weaknesses and no single tool is able to identify all clones within the code. The paper proposes that it may be possible to use a combination of tools to perform the analysis process providing that adequate means of efficiently identifying false matches is found.","","0-7695-1793-5","10.1109/SCAM.2002.1134103","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1134103","","Cloning;Preventive maintenance;Software maintenance;Software tools;Application software;Performance analysis;Software systems;Logic;Programming profession;Writing","software maintenance","clone detection tools evaluation;preventative maintenance;detection capability;code replication detection tools;source code","","55","","13","IEEE","6 Jan 2003","","","IEEE","IEEE Conferences"
"Handling preprocessor-conditioned declarations","L. Aversano; M. Di Penta; I. D. Baxter","Department of Engineering, Research Centre on Software Technology, University of Sannio, Rome, Italy; Department of Engineering, Research Centre on Software Technology, University of Sannio, Rome, Italy; Semantic Designs, Inc., Austin, TX, USA","Proceedings. Second IEEE International Workshop on Source Code Analysis and Manipulation","6 Jan 2003","2002","","","83","92","Many software systems are developed with configurable functionality, and for multiple hardware platforms and operating systems. This can lead to thousands of possible configurations, requiring each configuration-dependent programming entity or variable to have different types. Such configuration-dependent variables are often declared inside preprocessor conditionals (e.g., C language). Preprocessor-conditioned declarations may be a source of problems. Commonly used configurations are type-checked by repeated compilation. Rarely used configurations are unlikely to be recently type checked, and in such configurations a variable may have a type not compatible to its use or it may contains uses of variables never defined. This paper proposes an approach to identify all possible types each variable declared in a software system can assume, and under which conditions. Inconsistent variable usages can then be detected for all possible configurations. Impacts of preprocessor-conditioned declaration in 17 different open source software systems are also reported.","","0-7695-1793-5","10.1109/SCAM.2002.1134108","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1134108","","Data preprocessing;Software systems;Open source software;Hardware;Design engineering;Operating systems;Programming profession;Testing;Fault detection;Computer architecture","program processors;software tools","preprocessor-conditioned declaration handling;software systems;configurable functionality;multiple hardware platforms;multiple operating systems;configuration-dependent programming entities;configuration-dependent programming variables;type checking;repeated compilation;inconsistent variable usages;open source software systems","","12","2","11","IEEE","6 Jan 2003","","","IEEE","IEEE Conferences"
"Parallel support for source code analysis and modification","I. D. Baxter","Semantic Designs, Inc., USA","Proceedings. Second IEEE International Workshop on Source Code Analysis and Manipulation","6 Jan 2003","2002","","","3","14","Tools that analyze and enhance large-scale software systems using symbolic reasoning are computationally expensive, and yet processors are cheap. We believe that enabling tools with parallel foundations will lead to qualitatively more useful tools. We have implemented a large-scale industrial-strength program transformation system, the DMS Software Reengineering Toolkit, entirely in PARLANSE, a new parallel language. PARLANSE provides support for irregular fine-grain parallelism with zero-cost exception handling. This paper sketches the motivation for PARLANSE, its parallelism support and how it is used in a number of DMS-based applications, including parallel rewriting and attribute evaluation.","","0-7695-1793-5","10.1109/SCAM.2002.1134100","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1134100","","Parallel processing;Concurrent computing;Application software;Software systems;Yarn;Packaging;Large-scale systems;Computer industry;Software tools;Software engineering","systems re-engineering;parallel languages;parallel programming;exception handling;software tools;system monitoring;symbol manipulation","parallel support;source code analysis;source code modification;large-scale software systems;symbolic reasoning;large-scale program transformation system;DMS Software Reengineering Toolkit;PARLANSE;parallel language;irregular fine-grain parallelism;zero-cost exception handling;parallel rewriting;attribute evaluation","","4","1","18","IEEE","6 Jan 2003","","","IEEE","IEEE Conferences"
"Experimental checking of fault susceptibility in a parallel algorithm","A. Derezinska; J. Sosnowski","Institute of Computer Sciene, Warsaw University of Technology, Warsaw, Poland; Institute of Computer Sciene, Warsaw University of Technology, Warsaw, Poland","Proceedings. International Conference on Parallel Computing in Electrical Engineering","6 Jan 2003","2002","","","33","38","We deal with the problem of analyzing fault susceptibility of a parallel algorithm designed for a multiprocessor array (MIMD structure). This algorithm realizes quite a complex communication protocol in the system. We present an original methodology of the analysis based on the use of a software implemented fault injector. The considered algorithm is modeled as a multithreaded application. The experiment set up and results are presented and commented. The performed experiments proved relatively high natural robustness of the analyzed algorithm and showed further possibilities of its improvement.","","0-7695-1730-7","10.1109/PCEE.2002.1115193","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1115193","","Parallel algorithms;Parallel processing","software fault tolerance;parallel algorithms;multiprocessing systems;multi-threading;program verification","fault susceptibility checking;parallel algorithm;experimental checking;multiprocessor array;MIMD structure;communication protocol;software implemented fault injector;multithreaded application;robustness","","","","12","IEEE","6 Jan 2003","","","IEEE","IEEE Conferences"
"An approach to identify duplicated web pages","G. A. Di Lucca; M. Di Penta; A. R. Fasolino","Dipartimento di Informatica e Sistemistica, Università di Napoli Federico II, Napoli, Italy; RCOST-Research Centre on Software Technology, Dipartimento di Ingegneria, Università del Sannio, Benevento, Italy; Dipartimento di Informatica e Sistemistica, Università di Napoli Federico II, Napoli, Italy","Proceedings 26th Annual International Computer Software and Applications","10 Dec 2002","2002","","","481","486","A relevant consequence of the expansion of the web and e-commerce is the growth of the demand of new web sites and web applications. As a result, web sites and applications are usually developed without a formalized process, and web pages are directly coded in an incremental way, where new pages are obtained by duplicating existing ones. Duplicated web pages, having the same structure and just differing for the data they include, can be considered as clones. The identification of clones may reduce the effort devoted to test, maintain and evolve web sites and applications. Moreover, clone detection among different web sites aims to detect cases of possible plagiarism. In this paper we propose an approach. based on similarity metrics, to detect duplicated pages in web sites and applications, implemented with HTML language and ASP technology. The proposed approach has been assessed by analyzing several web sites and Web applications. The obtained results are reported in the paper with respect to some case studies.","0730-3157","0-7695-1727-7","10.1109/CMPSAC.2002.1045051","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1045051","","Web pages;Cloning;Application software;Plagiarism;HTML;Application specific processors;Time to market;Software testing;US Department of Transportation;Software metrics","information resources;electronic commerce;Internet;software metrics","web engineering;duplication;clone detection;web site analysis;web page metrics;source code clones;software metrics","","51","7","21","IEEE","10 Dec 2002","","","IEEE","IEEE Conferences"
"Evaluating software maintenance cost using functional redundancy metrics","T. Imai; Y. Kataoka; T. Fukaya","System Engineering Laboratory, Toshiba Corp.; System Engineering Laboratory, Toshiba Corp., Japan; System Engineering Laboratory, Toshiba Corp., Japan","Proceedings 26th Annual International Computer Software and Applications","10 Dec 2002","2002","","","299","306","Source code copying for reuse (code cloning) is often observed in software implementations. Such code cloning causes difficulty when software functionalities are modified: i.e, cloned codes increase the maintenance cost of software. We aim to estimate the maintenance cost caused by clones. We propose a novel approach, which evaluates influence of cloned codes over the maintenance cost. The basic idea is to measure functional redundancy (FR): a degree of propagation of clone-potential functions. FR is measured as follows: first, we cluster functions in the software according to similarities between them. Second, we make an n-ary weighted tree(FR tree) based on the cluster. Finally, we measure FR by weight of each node in FR-tree. In this paper, we describe the details of our proposal. We also apply the approach to 17K-ELOC C code to demonstrate its effectiveness.","0730-3157","0-7695-1727-7","10.1109/CMPSAC.2002.1045018","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1045018","","Software maintenance;Cost function;Cloning;Software debugging;Systems engineering and theory;Laboratories;Software measurement;Weight measurement;Proposals;Scattering","software reusability;software maintenance;software cost estimation;redundancy;software metrics","source code copying for reuse;code cloning;functional redundancy metrics;software maintenance cost evaluation;functional redundancy;clone-potential functions;function clustering;n-ary weighted tree;17K-ELOC C code","","4","","13","IEEE","10 Dec 2002","","","IEEE","IEEE Conferences"
"Investigating large software system evolution: the Linux kernel","E. Merlo; M. Dagenais; P. Bachand; J. S. Sormani; S. Gradara; G. Antoniol","École Polytechnique de Montréal, Montreal, Canada; École Polytechnique de Montréal, Montreal, Canada; École Polytechnique de Montréal, Montreal, Canada; École Polytechnique de Montréal, Montreal, Canada; RCOST-Research Centre on Software Technology, Faculty of Engineering, University of Sannio, Italy; RCOST-Research Centre on Software Technology, Faculty of Engineering, University of Sannio, Italy","Proceedings 26th Annual International Computer Software and Applications","10 Dec 2002","2002","","","421","426","Large multi-platform, multi-million lines of codes software systems evolve to cope with new platform or to meet user ever changing needs. While there has been several studies focused on the similarity of code fragments or modules, few studies addressed the need to monitor the overall system evolution. Meanwhile, the decision to evolve or to re-factor a large software system needs to be supported by high level information, representing the system overall picture, abstracting from unnecessary details. This paper proposes to extend the concept of similarity of code fragments to quantify similarities at the release/system level. Similarities are captured by four software metrics representative of the commonalities and differences within and among software artifacts. To show the feasibility of characterizing large software system with the new metrics, 365 releases of the Linux kernel were analyzed. The metrics, the experimental results as well as the lessons learned are presented in the paper.","0730-3157","0-7695-1727-7","10.1109/CMPSAC.2002.1045038","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1045038","","Software systems;Linux;Kernel;Software metrics;Software quality;Software performance;Monitoring;Cloning;Project management;System performance","software metrics;software maintenance;project management;software development management","software evolution;software metrics;clone analysis;project management;Linux kernel;large software system;code fragments","","5","","14","IEEE","10 Dec 2002","","","IEEE","IEEE Conferences"
"Reviving Pacbase COBOL-generated code","J. . -P. Bernardy","RainCode SPRL, Brussels, Belgium","Proceedings 26th Annual International Computer Software and Applications","10 Dec 2002","2002","","","741","743","We have migrated a large scale application from Pacbase to COBOL. The technique applies, in an iterative fashion, a set of small transformation patterns on Pacbase COBOL-output. Thus, equivalence with the Pacbase code is easily verified.","0730-3157","0-7695-1727-7","10.1109/CMPSAC.2002.1045091","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1045091","","Pattern recognition;Performance analysis;Performance evaluation;Pattern analysis;Application software;Large-scale systems;Assembly;Pattern matching;Humans;Computer applications","COBOL;program compilers","Pacbase-COBOL migration;transformation patterns;Pacbase COBOL output","","","","3","IEEE","10 Dec 2002","","","IEEE","IEEE Conferences"
"Optimizing automated testing for high throughput","J. C. Connell; L. Wheelwright","Agilent Technologies, Inc., USA; Agilent Technologies, Inc., USA","Proceedings, IEEE AUTOTESTCON","10 Dec 2002","2002","","","134","139","Throughput in automated testing is a critical issue, especially at the maintenance level. Some general rules and approaches, when used with an analysis of the total test requirement, can often substantially reduce test time. New programming environments and new (to test equipment) interface standards such as Ethernet, when available, may provide significant throughput improvement in a test system. Agilent's recent work with manufacturers in the wireless industry has helped validate a variety of approaches to optimize test throughput for transceiver manufacturing. We have found that very significant gains can be realized from only a modest investment. This paper describes successful practices and techniques for optimizing test throughput, and gives specific quantitative examples of the improvements that have been achieved.","1080-7725","0-7803-7441-X","10.1109/AUTEST.2002.1047883","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1047883","","Automatic testing;Temperature;Throughput;System testing;Frequency locked loops;Instruments;Low voltage;Lifting equipment;Manufacturing industries;Transceivers","automatic test equipment;optimisation;maintenance engineering;transceivers;telecommunication equipment testing;peripheral interfaces;local area networks;automatic test software","automated testing optimization;test throughput;maintenance level test;test time;programming environments;interface standards;Ethernet;wireless industry;transceiver manufacturing","","2","","","IEEE","10 Dec 2002","","","IEEE","IEEE Conferences"
"An integrated approach for studying architectural evolution","Qiang Tu; M. W. Godfrey","Department of Computer Science, University of Waterloo, Canada; Department of Computer Science, University of Waterloo, Canada","Proceedings 10th International Workshop on Program Comprehension","10 Dec 2002","2002","","","127","136","Studying how a software system has evolved over time is difficult, time consuming, and costly; existing techniques are often limited in their applicability, are hard to extend, and provide little support for coping with architectural change. The paper introduces an approach to studying software evolution that integrates the use of metrics, software visualization, and origin analysis, which is a set of techniques for reasoning about structural and architectural change. Our approach incorporates data from various statistical and metrics tools, and provides a query engine as well as a Web-based visualization and navigation interface. It aims to provide an extensible, integrated environment for aiding software maintainers in understanding the evolution of long-lived systems that have undergone significant architectural change. We use the evolution of GCC as an example to demonstrate the uses of various functionalities of BEAGLE, a prototype implementation of the proposed environment.","1092-8138","0-7695-1495-2","10.1109/WPC.2002.1021334","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1021334","","Software systems;Software maintenance;History;Software architecture;Navigation;Software tools;Data visualization;Computer science;Engines;Software prototyping","software architecture;software metrics;software maintenance;program visualisation;program compilers;Internet;search engines;user interfaces","architectural evolution;software system;metrics;software visualization;origin analysis;structural change;architectural change;query engine;Web-based visualization interface;Web-based navigation interface;software maintenance;BEAGLE","","19","1","17","IEEE","10 Dec 2002","","","IEEE","IEEE Conferences"
"A mobile agent clone detection system with itinerary privacy","T. C. Lam; V. K. Wei","Department of Information Engineering, Chinese University of Hong Kong, New Territories, Hong Kong, China; Department of Information Engineering, Chinese University of Hong Kong, New Territories, Hong Kong, China","Proceedings. Eleventh IEEE International Workshops on Enabling Technologies: Infrastructure for Collaborative Enterprises","7 Nov 2002","2002","","","68","73","We propose a system for the detection of unauthorized cloning of mobile agents by malicious hosts. The system can detect clones after the fact, identify the culprit, and then seek penalties. The agent migration protocol is offline (non-centralized). The itinerary of an agent is privacy-protected. Our scheme is based on H.Y. Wong's (2001) transferable extension of N. Ferguson's (1993) single-term offline untraceable e-cash. The main technique is to map the clone detection problem to the double-spending problem in transferable e-cash, and then adopt and adapt existing solutions from the latter field.","1080-1383","0-7695-1748-X","10.1109/ENABL.2002.1029991","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1029991","","Mobile agents;Cloning;Privacy;Computer networks;Information security;Cryptography;Protocols;Resumes;Electronic commerce;Information retrieval","mobile agents;computer crime;data privacy;electronic money","mobile agent clone detection system;itinerary privacy;unauthorized cloning detection;malicious hosts;agent migration protocol;privacy-protected agent itinerary;transferable extension;single-term offline untraceable e-cash;double-spending problem;transferable e-cash","","","","15","IEEE","7 Nov 2002","","","IEEE","IEEE Conferences"
"Summary report on enterprise security workshop","D. Gilliam","Jet Propulsion Laboratory, California Institute of Technology, USA","Proceedings. Eleventh IEEE International Workshops on Enabling Technologies: Infrastructure for Collaborative Enterprises","7 Nov 2002","2002","","","43","46","","1080-1383","0-7695-1748-X","10.1109/ENABL.2002.1029986","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1029986","","","","","","","","","IEEE","7 Nov 2002","","","IEEE","IEEE Conferences"
"CCFinder: a multilinguistic token-based code clone detection system for large scale source code","T. Kamiya; S. Kusumoto; K. Inoue","Functions and Configuration Group, RPESTO, JST. Graduate School of Engineering Science, Osaka University, Toyonaka, Osaka, Japan; Graduate School of Engineering Science, Osaka University, Toyonaka, Osaka, Japan; Graduate School of Engineering Science, Osaka University, Toyonaka, Osaka, Japan","IEEE Transactions on Software Engineering","7 Aug 2002","2002","28","7","654","670","A code clone is a code portion in source files that is identical or similar to another. Since code clones are believed to reduce the maintainability of software, several code clone detection techniques and tools have been proposed. This paper proposes a new clone detection technique, which consists of the transformation of input source text and a token-by-token comparison. For its implementation with several useful optimization techniques, we have developed a tool, named CCFinder (Code Clone Finder), which extracts code clones in C, C++, Java, COBOL and other source files. In addition, metrics for the code clones have been developed. In order to evaluate the usefulness of CCFinder and metrics, we conducted several case studies where we applied the new tool to the source code of JDK, FreeBSD, NetBSD, Linux, and many other systems. As a result, CCFinder has effectively found clones and the metrics have been able to effectively identify the characteristics of the systems. In addition, we have compared the proposed technique with other clone detection techniques.","1939-3520","","10.1109/TSE.2002.1019480","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1019480","","Cloning;Large-scale systems;Software systems;Maintenance engineering;Software maintenance;Software tools;Java;Linux;Computer aided software engineering;Programming profession","high level languages;large-scale systems;software maintenance;software metrics;computer aided software engineering;software tools;optimising compilers","CCFinder;multi-linguistic token-based code clone detection system;large-scale source code;software maintainability;input source text transformation;token-by-token comparison;optimization techniques;C language;C++ language;Java;COBOL;software metrics;case studies;JDK;Java Development Kit;FreeBSD;NetBSD;Linux;system characteristics identification;duplicated code;CASE tool","","980","6","22","IEEE","7 Aug 2002","","","IEEE","IEEE Journals"
"Software quality analysis by code clones in industrial legacy software","A. Monden; D. Nakae; T. Kamiya; S. Sato; K. Matsumoto","Nara Institute of Science and Technology, Ikoma, Nara, Japan; Nara Institute of Science and Technology, Ikoma, Nara, Japan; PRESTO, Japan Science and Technology Corporation, Kawaguchi, Saitama, Japan; Nara Institute of Science and Technology, Ikoma, Nara, Japan; Nara Institute of Science and Technology, Ikoma, Nara, Japan","Proceedings Eighth IEEE Symposium on Software Metrics","7 Aug 2002","2002","","","87","94","Existing research suggests that the code clone (duplicated code) is one of the factors that degrades the design and the structure of software and lowers the software quality such as readability and changeability. However, the influence of code clones on software quality has not been quantitatively clarified yet. We have tried to quantitatively clarify the relation between code clones and the software reliability and maintainability of twenty year old software. As a result, we found that modules having code clones (clone-included modules) are more reliable than modules having no code clone (non-clone modules) on average. Nevertheless, the modules having very large code clones (more than 200 SLOC) are less reliable than non-clone modules. We also found that clone-included modules are less maintainable (having greater revision number on average) than non-clone modules; and, modules having larger code clone are less maintainable than modules having smaller code clone.","1530-1435","0-7695-1339-5","10.1109/METRIC.2002.1011328","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1011328","","Software quality;Cloning;Computer industry;Software maintenance;Electronic switching systems;Degradation;Aging;Costs","software quality;software reliability;software maintenance;software metrics","software quality analysis;code clones;industrial legacy software;duplicated code;software readability;software changeability;software reliability;software maintainability;software metrics;large software","","70","1","26","IEEE","7 Aug 2002","","","IEEE","IEEE Conferences"
"Gemini: maintenance support environment based on code clone analysis","Y. Ueda; T. Kamiya; S. Kusumoto; K. Inoue","Graduate School of Engineering Science, Osaka University, Toyonaka, Osaka, Japan; PRESTO, Japan Science and Technology Corporation, Japan; Graduate School of Engineering Science, Osaka University, Toyonaka, Osaka, Japan; Graduate School of Engineering Science, Osaka University, Toyonaka, Osaka, Japan","Proceedings Eighth IEEE Symposium on Software Metrics","7 Aug 2002","2002","","","67","76","Maintaining software systems is becoming a more complex and difficult task, as the scale becomes larger. It is generally said that code cloning is one of the factors that make software maintenance difficult. A code clone is a code portion in source files that is identical or similar to another. If some faults are found in a code clone, it is necessary to correct the faults in its all code clones. However for large scale software, it is very difficult to correct them completely. We develop a maintenance support environment, called Gemini, which visualizes the code clone information from a code clone detection tool, CCFinder. Using Gemini, we can specify a set of distinctive code clones through the GUI (scatter plot and metrics graph about code clones), and refer the fragments of source code corresponding to the clone on the plot or graph.","1530-1435","0-7695-1339-5","10.1109/METRIC.2002.1011326","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1011326","","Cloning;Software maintenance;Large-scale systems;Scattering;Maintenance engineering;Software systems;Costs;Visualization;Graphical user interfaces;Software performance","software maintenance;computer aided software engineering;graphical user interfaces;software metrics;program debugging","Gemini;graphical user interface;software maintenance support environment;code clone analysis;source files;software faults;code clone information visualization;code clone detection tool;CCFinder;GUI;scatter plot;metrics graph;software metrics","","35","","16","IEEE","7 Aug 2002","","","IEEE","IEEE Conferences"
"Compiling for fine-grain concurrency: planning and performing software thread integration","A. G. Dean","Center for Embedded Systems Research, Department of Electrical and Computer Engineering, NC State University, Raleigh, NC, USA","Proceedings Sixth Annual Workshop on Interaction between Compilers and Computer Architectures","7 Aug 2002","2002","","","3","14","Embedded systems require control of many concurrent real-time activities, leading to system designs which feature multiple hardware peripherals with each providing a specific, dedicated service. These peripherals increase system size, cost, weight, power and design time. Software thread integration (STI) provides low-cost thread concurrency on general-purpose processors by automatically interleaving multiple (potentially real-time) threads of control into one. This simplifies hardware to software migration (which eliminates dedicated hardware) and can help embedded system designers meet design constraints such as size, weight, power and cost. The paper introduces automated methods for planning and performing the code transformations needed for integration of functions with more sophisticated control flows than in previous work. We demonstrate the methods by using Thrint, our post pass thread-integrating compiler, to automatically integrate multiple threads for a sample real-time embedded system with fine-grain concurrency. Previous work in thread integration required users to manually integrate loops; this is now performed automatically. The sample application generates an NTSC monochrome video signal (sending out a stream of pixels to a video DAC) with STI to replace a video refresh controller IC. Using Thrint reduces integration time from days to minutes and reclaims up to 99% of the system's fine grain idle time.","","0-7695-1534-7","10.1109/INTERA.2002.995838","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=995838","","Concurrent computing;Yarn;Embedded system;Automatic control;Hardware;Power system planning;Control systems;Real time systems;Costs;Interleaved codes","multi-threading;program compilers;automatic programming;embedded systems;program control structures","fine-grain concurrency;software thread integration;embedded systems;concurrent real-time activities;system designs;multiple hardware peripherals;dedicated service;system size;STI;low-cost thread concurrency;general-purpose processors;multiple threads;hardware to software migration;embedded system designers;design constraints;automated methods;code transformations;Thrint;post-pass thread-integrating compiler;sample real-time embedded system;thread integration;NTSC monochrome video signal;video DAC;video refresh controller IC","","2","","33","IEEE","7 Aug 2002","","","IEEE","IEEE Conferences"
"Accuracy of profile maintenance in optimizing compilers","Youfeng Wu","Programming Systems Research Laboratory, Intel Corporation, Santa Clara, CA, USA","Proceedings Sixth Annual Workshop on Interaction between Compilers and Computer Architectures","7 Aug 2002","2002","","","27","38","Modern processors rely heavily on optimizing compilers to deliver their performance potentials. The compilers, in turn, rely greatly on profile information to focus the optimization efforts and better match the generated code with the target machines. Maintaining the profile in an optimizing compiler is important as many optimizations can benefit from profile information and they are often performed one after the other. Maintaining a profile is, however, tedious and error prone. An erroneous profile is not easy to detect as it affects only the performance, not the correctness, of a program. Maintaining a profile also inherently loses accuracy, as the profile update operations often have to use probabilistic approximation. In this paper, we measure the accuracy of maintaining CFG profiles in a high-performance optimizing compiler. Our data indicates that the compiler maintains the profile more accurately within individual functions than globally across functions, and function inlining may be responsible for the loss of profile accuracy globally. We also identify a number of research issues related to profile maintenance.","","0-7695-1534-7","10.1109/INTERA.2002.995840","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=995840","","Optimizing compilers;Frequency;Flow graphs;Educational institutions;Productivity;Programming profession;Automatic control;Conferences;Computer architecture","optimising compilers","profile maintenance accuracy;profile update operations;probabilistic approximation;CFG profiles;high-performance optimizing compiler;function inlining","","1","1","20","IEEE","7 Aug 2002","","","IEEE","IEEE Conferences"
"Converting Web applications to data components: design methodology","J. Pazdziora","Masaryk University, Brno, Czech Republic","25th Annual International Computer Software and Applications Conference. COMPSAC 2001","7 Aug 2002","2001","","","31","36","Most of the current Web applications are closely tied to the client and large parts of their code concern with producing proper output markup. Converting them into components that produce pure data output, independent from presentation specifics, increases maintainability and eliminates duplicated code for different output media, and thus is the key requirement for modem systems. In this paper we explore steps needed to transfer existing applications to data oriented components, and present implementation and performance issues and their solutions.","0730-3157","0-7695-1372-7","10.1109/CMPSAC.2001.960595","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=960595","","Design methodology;HTML;Web server;Logic;Web sites;Spatial databases;Graphics;Cellular phones;Investments;Embedded system","Internet;client-server systems;software maintenance","World Wide Web applications;output markup;pure data output;maintainability;duplicated code elimination;data oriented components","","","1","8","IEEE","7 Aug 2002","","","IEEE","IEEE Conferences"
"Identifying similar code with program dependence graphs","J. Krinke","Lehrstuhl Softwaresysteme, Universität Passau, Passau, Germany","Proceedings Eighth Working Conference on Reverse Engineering","7 Aug 2002","2001","","","301","309","We present an approach to identifying similar code in programs based on finding similar subgraphs in attributed directed graphs. This approach is used on program dependence graphs and therefore considers not only the syntactic structure of programs but also the data flow within (as an abstraction of the semantics). As a result, there is no tradeoff between precision and recall; our approach is very good in both. An evaluation of our prototype implementation shows that the approach is feasible and gives very good results despite the non polynomial complexity of the problem.","1095-1350","0-7695-1303-4","10.1109/WCRE.2001.957835","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=957835","","Software prototyping;Prototypes;Software maintenance;Polynomials;Programming profession;Software systems;Flow graphs","directed graphs;computational complexity;software maintenance;data flow analysis;computational linguistics","similar code identification;program dependence graphs;similar subgraphs;attributed directed graphs;syntactic program structure;data flow;non polynomial complexity","","266","2","16","IEEE","7 Aug 2002","","","IEEE","IEEE Conferences"
"Preprocessor conditional removal by simple partial evaluation","I. D. Baxter; M. Mehlich","Semantic Designs, Inc.; Semantic Designs, Inc.","Proceedings Eighth Working Conference on Reverse Engineering","7 Aug 2002","2001","","","281","290","Preprocessors with conditionals are often used as software configuration management tools, with preprocessor variables naming configuration aspects. The preprocessor conditionals found in large systems often have complex enabling Boolean equations and nesting. Over long periods, some configuration aspects lose all utility. Removal of all traces of a configuration variable and code dependent on that aspect becomes a significant task if performed manually. An industrial-strength transformation system can remove such configuration aspects in a much shorter period of time, by symbolically simplifying away the configuration aspect. The paper sketches the problem and the required transforms, and discusses a case study involving over a million lines of source code.","1095-1350","0-7695-1303-4","10.1109/WCRE.2001.957833","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=957833","","Data preprocessing;Software systems;Costs;Operating systems;Application software;World Wide Web;Equations;Software libraries;Automation;Programming profession","partial evaluation (compilers);symbol manipulation;configuration management","preprocessor conditional removal;simple partial evaluation;symbolic computation;program transformations;software configuration management tools;preprocessor variables;configuration aspects;preprocessor conditionals;large systems;complex enabling Boolean equations;configuration variable;industrial-strength transformation system;configuration aspect;case study;source code","","34","4","11","IEEE","7 Aug 2002","","","IEEE","IEEE Conferences"
"Reverse engineering to achieve maintainable WWW sites","C. Boldyreff; R. Kewish","Department of Computer Science, University of Durham, Durham, UK; Department of Computer Science, University of Durham, Durham, UK","Proceedings Eighth Working Conference on Reverse Engineering","7 Aug 2002","2001","","","249","257","The growth of the World Wide Web and the accelerated development of web sites and associated web technologies has resulted in a variety of maintenance problems. The maintenance problems associated with web sites and the WWW are examined. It is argued that currently web sites and the WWW lack both data abstractions and structures that could facilitate maintenance. A system to analyse existing web sites and extract duplicated content and style is described here. In designing the system, existing reverse engineering techniques have been applied, and a case for further application of these techniques is made in order to prepare sites for their inevitable evolution in future.","1095-1350","0-7695-1303-4","10.1109/WCRE.2001.957829","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=957829","","Reverse engineering;World Wide Web;Software maintenance;Web sites;Application software;Software engineering;Large-scale systems;Design engineering;Computer science;Acceleration","reverse engineering;Internet;information resources;data structures;software maintenance","reverse engineering;maintainable WWW sites;World Wide Web;web sites;web technologies;data abstractions;data structures;site maintenance","","37","","16","IEEE","7 Aug 2002","","","IEEE","IEEE Conferences"
"Program comprehension risks and opportunities in extreme programming","A. van Deursen","CWI, Amsterdam, Netherlands","Proceedings Eighth Working Conference on Reverse Engineering","7 Aug 2002","2001","","","176","185","Investigates the relationship between reverse engineering and program comprehension on the one hand, and the software process on the other. To understand this relationship, we select one particular existing software process, extreme programming (XP), and study the role played in it by program comprehension and reverse engineering. To that end, we analyze five key XP practices in depth: pair programming, unit testing, refactoring, evolutionary design and collaborative planning. The contributions of this paper are: (1) the identification of promising research areas in the field of program comprehension; (2) the identification of new application perspectives for reverse engineering technology; (3) a critical analysis of XP resulting in research questions that could help resolve some of the uncertainties surrounding XP; and (4) a discussion of the role that comprehension and reverse engineering can play in software process design.","1095-1350","0-7695-1303-4","10.1109/WCRE.2001.957822","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=957822","","Reverse engineering;Software testing;System testing;Genetic programming;Costs;Software systems;World Wide Web;Collaboration;Application software;Uncertainty","programming;reverse engineering;program testing;software prototyping","program comprehension;reverse engineering;software process;extreme programming;risks;pair programming;unit testing;refactoring;evolutionary design;collaborative planning;application perspectives identification;uncertainties;collaborative work","","20","","36","IEEE","7 Aug 2002","","","IEEE","IEEE Conferences"
"Towards a standard schema for C/C++","R. Ferenc; S. E. Sim; R. C. Holt; R. Koschke; T. Gyimothy","Research Group on Artificial Intelligence, University of Szeged, Hungary; Department of Computer Science, University of Toronto, Canada; Department of Computer Science, University of Waterloo, Canada; Institut für Informatik, Universität Stuttgart, Germany; Research Group on Artificial Intelligence, University of Szeged, Hungary","Proceedings Eighth Working Conference on Reverse Engineering","7 Aug 2002","2001","","","49","58","Developing a standard schema at the abstract syntax tree (AST) level for C/C++ to be used by reverse engineering and reengineering tools is a complex and difficult problem. In this paper we present a catalogue of issues that need to be considered in order to design a solution. Three categories of issues are discussed. Lexical structure is the first category and pertains to characteristics of the source code, such as spaces and comments. The second category, syntax, includes both the mundane and hard problems in the C++ programming language. The final category is semantics and covers aspects such as naming and reference resolution. Example solutions to these challenges are provided from the Datrix schema from Bell Canada and the Columbus schema from University of Szeged. The paper concludes with a discussion of lessons learnt and plans for future work on a C/C++AST standard schema.","1095-1350","0-7695-1303-4","10.1109/WCRE.2001.957809","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=957809","","Reverse engineering;Artificial intelligence;Computer science;Computer languages;Standards development;Data mining;Spatial databases;Terminology","C language;C++ language;reverse engineering;systems re-engineering;naming services;programming language semantics;software standards","C schema;C++ schema;abstract syntax trees;reverse engineering tools;reengineering tools;lexical structure;source code characteristics;spaces;comments;syntax;C++ programming language;semantics;naming;reference resolution;Datrix schema;Columbus schema;AST standard schema;standard exchange format;GXL;Graph Exchange Language;parser;extractor;front end","","24","","23","IEEE","7 Aug 2002","","","IEEE","IEEE Conferences"
"Dynamic binary translation and optimization","K. Ebcioglu; E. Altman; M. Gschwind; S. Sathaye","IBM Thomas J. Watson Research Center, Yorktown Heights, NY, USA; IBM Thomas J. Watson Research Center, Yorktown Heights, NY, USA; IBM Thomas J. Watson Research Center, Yorktown Heights, NY, USA; IBM Thomas J. Watson Research Center, Yorktown Heights, NY, USA","IEEE Transactions on Computers","7 Aug 2002","2001","50","6","529","548","We describe a VLIW architecture designed specifically as a target for dynamic compilation of an existing instruction set architecture. This design approach offers the simplicity and high performance of statically scheduled architectures, achieves compatibility with an established architecture, and makes use of dynamic adaptation. Thus, the original architecture is implemented using dynamic compilation, a process we refer to as DAISY (Dynamically Architected Instruction Set from Yorktown). The dynamic compiler exploits runtime profile information to optimize translations so as to extract instruction level parallelism. This paper reports different design trade-offs in the DAISY system and their impact on final system performance. The results show high degrees of instruction parallelism with reasonable translation overhead and memory usage.","1557-9956","","10.1109/12.931892","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=931892","","VLIW;Computer architecture;Dynamic scheduling;Parallel processing;Processor scheduling;Hardware;Dynamic compiler;Runtime;Microprocessors;Software performance","parallel architectures;program compilers;instruction sets","dynamic binary translation;optimization;VLIW architecture;dynamic compilation;instruction set architecture;statically scheduled architectures;DAISY;runtime profile;instruction level parallelism;instruction parallelism;memory usage","","92","40","48","IEEE","7 Aug 2002","","","IEEE","IEEE Journals"
"Maintenance support tools for Java programs: CCFinder and JAAT","T. Kamiya; F. Ohata; K. Kondou; S. Kusumoto; K. Inoue","Graduate School of Engineering Science, Osaka University, Toyonaka, Osaka, Japan; Graduate School of Engineering Science, Osaka University, Toyonaka, Osaka, Japan; Graduate School of Engineering Science, Osaka University, Toyonaka, Osaka, Japan; Graduate School of Engineering Science, Osaka University, Toyonaka, Osaka, Japan; Graduate School of Information Science, Nara Institute of Science and Technology, Japan","Proceedings of the 23rd International Conference on Software Engineering. ICSE 2001","7 Aug 2002","2001","","","837","838","This paper describes two software maintenance support tools, CCFinder (Code Clone Finder) and JAAT (Java Alias Analysis Tool), for Java programs. CCFinder identifies code clones in Java programs, while JAAT executes alias analysis for Java programs.","0270-5257","0-7695-1050-7","10.1109/ICSE.2001.919197","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=919197","","Java;Cloning;Software maintenance;Maintenance engineering;Software systems;Information science;Algorithm design and analysis;Large-scale systems;Detection algorithms;Computer industry","Java;software maintenance;software tools","software maintenance support tools;CCFinder;JAAT;Java programs;code clone identification;alias analysis","","7","","8","IEEE","7 Aug 2002","","","IEEE","IEEE Conferences"
"Reengineering analysis of object-oriented systems via duplication analysis","F. Fioravanti; G. Migliarese; P. Nesi","Department of Systems and Informatics, University of Florence, Florence, Italy; Department of Systems and Informatics, University of Florence, Florence, Italy; Department of Systems and Informatics, University of Florence, Florence, Italy","Proceedings of the 23rd International Conference on Software Engineering. ICSE 2001","7 Aug 2002","2001","","","577","586","All software systems, no matter how they are designed, are subject to continuous evolution and maintenance activities to eliminate defects and extend their functionalities. This is particularly true for object-oriented systems, where we may develop different software systems using the same internal library or framework. These systems may evolve in quite different directions in order to cover different functionalities. Typically, there is the need to analyze their evolution in order to redefine the library or framework boundaries. This is a typical problem of software reengineering analysis. In this paper, we describe metrics, based on duplication analysis, that contribute to the process of reengineering analysis of object-oriented systems. These metrics are the basic elements of a reengineering analysis method and tool. Duplication analyses at the file, class and method levels have been performed. A structural analysis using metrics that capture similarities in class structure has been also exploited. In order to identify the best approach for the reengineering analysis of object-oriented systems, a comparison between the two approaches is described. In this paper, a case study based on real cases is presented, in which the results obtained by using a reengineering process with and without the analysis tool are described. The purpose of this study is to discover which method is the most powerful and how much time reduction can be obtained by its use.","0270-5257","0-7695-1050-7","10.1109/ICSE.2001.919132","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=919132","","Cloning;Software systems;Software libraries;Performance analysis;Informatics;Functional programming;Genetic programming;Object oriented programming;Software performance;Application software","object-oriented programming;systems re-engineering;software maintenance;object-oriented methods;software metrics","software reengineering analysis;object-oriented systems;code duplication analysis;software evolution;software maintenance;software defect elimination;software functionality extension;internal libraries;frameworks;software metrics;file-level analysis;class-level analysis;method-level analysis;structural analysis;class structure similarities;case study;time reduction;clone detection","","5","","14","IEEE","7 Aug 2002","","","IEEE","IEEE Conferences"
"Case study: extreme programming in a university environment","M. M. Muller; W. F. Tichy","Computer Science Department, Universitat Karlsruhe, Karlsruhe, Germany; Computer Science Department, Universitat Karlsruhe, Karlsruhe, Germany","Proceedings of the 23rd International Conference on Software Engineering. ICSE 2001","7 Aug 2002","2001","","","537","544","Extreme programming (XP) is a new and controversial software process for small teams. A practical training course at the University of Karlsruhe led to the following observations about the key practices of XP. First, it is unclear how to reap the potential benefits of pair programming, although pair programming produces high-quality code. Second, designing in small increments appears to be problematic but ensures rapid feedback about the code. Third, while automated testing is helpful, writing test cases before coding is a challenge. Last, it is difficult to implement XP without coaching. This paper also provides some guidelines for those starting out with XP.","0270-5257","0-7695-1050-7","10.1109/ICSE.2001.919128","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=919128","","Computer aided software engineering;Writing;Programming;Documentation;Automatic testing;Computer science;Feedback;Guidelines;Software engineering;Inspection","programming;training;computer science education;educational courses;program testing","extreme programming;case study;software process;small teams;training course;Karlsruhe University;pair programming;high-quality code;incremental design;feedback;automated testing;test case writing;coaching","","49","","10","IEEE","7 Aug 2002","","","IEEE","IEEE Conferences"
"Generation of minimal size code for schedule graphs","C. Passerone; Y. Watanabe; L. Lavagno","Politecnico di Turino, Italy; Cadence Design Systems, Inc., USA; Università degli Studi di Udine, Italy","Proceedings Design, Automation and Test in Europe. Conference and Exhibition 2001","7 Aug 2002","2001","","","668","673","This paper proposes a procedure for minimizing the code size of sequential programs for reactive systems. It identifies repeated code segments (a generalization of basic blocks to directed rooted trees) and finds a minimal covering of the input control flow graphs with code segments. The segments are disjunct, i.e. no two segments have the same code in common. The program is minimal in the sense that the number of code segments is minimum under the property of disjunction for the given control flow specification. The procedure makes no assumption on the target processor architecture, and is meant to be used between task synthesis algorithms from a concurrent specification and a standard compiler for the target architecture. It is aimed at optimizing the size of very large, automatically generated flat code, and extends dramatically the scope of classical common sub-expression identification techniques. The potential effectiveness of the proposed approach is demonstrated through preliminary experiments.","1530-1591","0-7695-0993-2","10.1109/DATE.2001.915096","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=915096","","Productivity;Embedded system;Tree graphs;Automatic control;Hardware;Software performance;Software quality;Application software;Design methodology;Programming","data flow graphs;scheduling;software engineering;minimisation","minimal size code;schedule graphs;sequential programs;reactive systems;repeated code segments;directed rooted trees;input control flow graphs;code segments;disjunction;control flow specification;concurrent specification;standard compiler;target architectur;automatically generated flat code","","1","","8","IEEE","7 Aug 2002","","","IEEE","IEEE Conferences"
"Detecting design flaws via metrics in object-oriented systems","R. Marinescu","Department of Computer Science, Politehnica University of Timişoara, Timisoara, Romania","Proceedings 39th International Conference and Exhibition on Technology of Object-Oriented Languages and Systems. TOOLS 39","7 Aug 2002","2001","","","173","182","The industry is nowadays confronted with large-scale monolithic and inflexible object-oriented software. Because of their high business value, these legacy systems must be re-engineered. One of the important issues in re-engineering is the detection and location of design flaws, which prevent the efficient maintenance and further development of the system. In this paper, we present a metrics-based approach for detecting design problems, and we describe two concrete techniques for the detection of two well-known design flaws found in the literature. We apply our technique to an industrial case study and discuss the findings. The proposed technique indeed found real flaws in the system and the experiment suggests that, based on the same approach, further detection techniques for other common design flaws could be defined.","1530-2067","0-7695-1251-8","10.1109/TOOLS.2001.941671","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=941671","","Computer industry;Concrete;Software systems;Computer science;Large-scale systems;Vents;Encapsulation;Power generation economics;Employment;Intelligent systems","object-oriented programming;systems re-engineering;software metrics;program diagnostics","software design flaw detection;software metrics;object-oriented systems;business value;legacy systems reengineering;software maintenance;industrial case study;design problem detection;system development","","39","","12","IEEE","7 Aug 2002","","","IEEE","IEEE Conferences"
"Using design patterns and constraints to automate the detection and correction of inter-class design defects","Y. . -G. Gueheneuc; H. Albin-Amiot","École des Mines de Nantes, Nantes, France; École des Mines de Nantes, Nantes, France","Proceedings 39th International Conference and Exhibition on Technology of Object-Oriented Languages and Systems. TOOLS 39","7 Aug 2002","2001","","","296","305","Developing code free of defects is a major concern for the object oriented software community. The authors classify design defects as those within classes (intra-class), those among classes (inter-classes), and those of semantic nature (behavioral). Then, we introduce guidelines to automate the detection and correction of inter-class design defects. We assume that design patterns embody good architectural solutions and that a group of entities with organization similar, but not equal, to a design pattern represents an inter-class design defect. Thus, the transformation of such a group of entities, such that its organization complies exactly with a design pattern, corresponds to the correction of an inter-class design defect. We use a meta-model to describe design patterns and we exploit the descriptions to infer sets of detection and transformation rules. A constraint solver with explanations uses the descriptions and rules to recognize groups of entities with organizations similar to the described design patterns. A transformation engine modifies the source code to comply with the recognized distorted design patterns. We apply these guidelines on the Composite pattern using PTIDEJ, our prototype tool that integrates the complete guidelines.","1530-2067","0-7695-1251-8","10.1109/TOOLS.2001.941682","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=941682","","Software maintenance;Software quality;Documentation;Software prototyping;Prototypes;Software tools;Application software;Maintenance engineering;Software design;Visualization","object-oriented programming;software reusability;software reliability;automatic programming","design patterns;inter-class design defect detection automation;object oriented software community;semantic nature;inter-class design defects;architectural solutions;meta-model;transformation rules;constraint solver;transformation engine;source code;distorted design patterns;Composite pattern;PTIDEJ;prototype tool;OO design","","29","1","43","IEEE","7 Aug 2002","","","IEEE","IEEE Conferences"
"Knowledge mediation in software quality engineering","B. A. Philp; B. J. Garner","MetaSilicon, Sydney, Australia; Deakin University, Geelong, VIC, Australia","Proceedings 2001 Australian Software Engineering Conference","7 Aug 2002","2001","","","153","159","The risk of failure of the software development process remains high despite many attempts to improve the quality of software engineering. Contemporary approaches to process assurance, such as the capability maturity model have not prevented systemic failures, nor have project management methodologies provided guarantees of software quality. The paper proposes an approach to software quality assurance based on a knowledge mediated concurrent audit, which incorporates essential feedback processes. Through a tightly integrated approach to quality audit, programmers would be empowered to use any chosen methodology to advantage, supported by intelligent monitoring of the essential interactions which occur in the development process. An experimental application implementing some aspects of the proposal is described.","1530-0803","0-7695-1254-2","10.1109/ASWEC.2001.948509","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=948509","","Mediation;Software quality;Knowledge engineering;Software engineering;Capability maturity model;Project management;Feedback;Programming profession;Monitoring;Application software","software quality;software reliability;programming environments;computer aided software engineering;knowledge based systems","software quality engineering;knowledge mediation;software development process;software quality assurance;knowledge mediated concurrent audit;feedback processes;quality audit;intelligent monitoring","","1","","31","IEEE","7 Aug 2002","","","IEEE","IEEE Conferences"
"Home security system and CATV","R. Volner","Department of Telecommunications, University of Zilina, Slovakia","Proceedings IEEE 35th Annual 2001 International Carnahan Conference on Security Technology (Cat. No.01CH37186)","7 Aug 2002","2001","","","293","306","The areas of television, telecommunication, and information technology are converging, new application areas are being arising and new services are being and other multimedia services. established. Aside from the traditional delivery channels, computer networks play an increasing role in providing the new services. An important part of these services is based on video. However, in order to develop and establish such services, the differences between traditional video and multimedia applications as well as the requirements, limitations and possibilities for an integration use of both have to be understood.","","0-7803-6636-0","10.1109/CCST.2001.962848","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=962848","","Multimedia systems;Cable TV;TV broadcasting;Application software;Computer industry;Telecommunications;Multimedia communication;Databases;Communication industry;Satellite broadcasting","cable television;multimedia communication;interactive video;telecommunication security;computer networks","home security system;CATV;computer networks;video;multimedia","","7","","","IEEE","7 Aug 2002","","","IEEE","IEEE Conferences"
"Estimation and prediction metrics for adaptive maintenance effort of object-oriented systems","F. Fioravanti; P. Nesi","Department of Systems and Informatics, University of Florence, Florence, Italy; Department of Systems and Informatics, University of Florence, Florence, Italy","IEEE Transactions on Software Engineering","7 Aug 2002","2001","27","12","1062","1084","Many software systems built in recent years have been developed using object-oriented technology and, in some cases, they already need adaptive maintenance in order to satisfy market and customer needs. In most cases, the estimation and prediction of maintenance effort is performed with difficulty due to the lack of metrics and suitable models. In this paper, a model and metrics for estimation/prediction of adaptive maintenance effort are presented and compared with some other solutions taken from the literature. The model proposed can be used as a general approach for adopting well-known metrics (typically used for the estimation of development effort) for the estimation/prediction of adaptive maintenance effort. The model and metrics proposed have been validated against real data by using multilinear regression analysis. The validation has shown that several well-known metrics can be profitably employed for the estimation/prediction of maintenance effort.","1939-3520","","10.1109/32.988708","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=988708","","Costs;Object oriented modeling;Predictive models;Control systems;Software performance;Performance evaluation;Software systems;Regression analysis;Software maintenance;Tree data structures","statistical analysis;software maintenance;software metrics;object-oriented methods","software systems;object-oriented systems;prediction metrics;estimation metrics;adaptive maintenance effort;multilinear regression analysis","","80","3","44","IEEE","7 Aug 2002","","","IEEE","IEEE Journals"
"A new code-disjoint sum-bit duplicated carry look-ahead adder for parity codes","E. S. Sogomonyan; V. Ocheretnij; M. Gossel","Department of Computer Science, Fault Tolerant Computing Group, University of Potsdam, Potsdam, Germany; Department of Computer Science, Fault Tolerant Computing Group, University of Potsdam, Potsdam, Germany; Department of Computer Science, Fault Tolerant Computing Group, University of Potsdam, Potsdam, Germany","Proceedings 10th Asian Test Symposium","7 Aug 2002","2001","","","365","370","A new code-disjoint self-checking carry look-ahead adder is proposed. To reduce the necessary area and the power dissipation only the sum bits of the adder cells are duplicated. This is possible since the input parity is determined by use of internal nodes of the adder cells. The adder is modeled by a SYNOPSIS CAD tool from the EUROCHIP-Project with a standard library. With respect to duplication and comparison the necessary area and the power dissipation can be reduced up to 38 % and up to 29 % respectively compared to an increase of the maximal delay of only 12 %.","1081-7735","0-7695-1378-6","10.1109/ATS.2001.990310","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=990310","","Equations;Power dissipation;Parity check codes;Computer science;Fault tolerance;Libraries;Delay;Fault detection;Signal design;Computer errors","carry logic;adders;low-power electronics;logic CAD;circuit CAD;software libraries;delays","code-disjoint self-checking carry look-ahead adder;sum-bit duplicated adder;power dissipation;sum bits;internal nodes;SYNOPSIS CAD tool;EUROCHIP-Project;standard library;maximal delay;parity codes","","13","","13","IEEE","7 Aug 2002","","","IEEE","IEEE Conferences"
"Identification of high-level concept clones in source code","A. Marcus; J. I. Maletic","Department of Computer Science, Kent University, Kent, OH, USA; Department of Computer Science, Kent University, Kent, OH, USA","Proceedings 16th Annual International Conference on Automated Software Engineering (ASE 2001)","7 Aug 2002","2001","","","107","114","Source code duplication occurs frequently within large software systems. Pieces of source code, functions, and data types are often duplicated in part or in whole, for a variety of reasons. Programmers may simply be reusing a piece of code via copy and paste or they may be ""re-inventing the wheel"". Previous research on the detection of clones is mainly focused on identifying pieces of code with similar (or nearly similar) structure. Our approach is to examine the source code text (comments and identifiers) and identify implementations of similar high-level concepts (e.g., abstract data types). The approach uses an information retrieval technique (i.e., latent semantic indexing) to statically analyze the software system and determine semantic similarities between source code documents (i.e., functions, files, or code segments). These similarity measures are used to drive the clone detection process. The intention of our approach is to enhance and augment existing clone detection methods that are based on structural analysis. This synergistic use of methods will improve the quality of clone detection. A set of experiments is presented that demonstrate the usage of semantic similarity measure to identify clones within a version of NCSA Mosaic.","1938-4300","0-7695-1426-X","10.1109/ASE.2001.989796","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=989796","","Cloning;Software systems;Programming profession;Computer science;Information retrieval;Indexing;Information analysis;Wheels;Documentation","program diagnostics;software reusability;information retrieval;computational linguistics;abstract data types","high-level concept clone identification;source code duplication;large software systems;data types;source code reuse;clone detection;source code text;high-level concepts;abstract data types;information retrieval technique;latent semantic indexing;static analysis;semantic similarities;source code documents;similarity measures;structural analysis;synergistic methods;semantic similarity. measure;NCSA Mosaic","","118","4","46","IEEE","7 Aug 2002","","","IEEE","IEEE Conferences"
"Automated support for program refactoring using invariants","Y. Kataoka; M. D. Ernst; W. G. Griswold; D. Notkin","Department of Computer Science & Engineering, University of Washington, Seattle, WA, USA; MIT Laboratory for Computer Science, Cambridge, MA, USA; Department of Computer Science & Engineering, University of California, San Diego, La Jolla, CA, USA; Department of Computer Science & Engineering, University of Washington, Seattle, WA, USA","Proceedings IEEE International Conference on Software Maintenance. ICSM 2001","6 Aug 2002","2001","","","736","743","Program refactoring-transforming a program to improve readability, structure, performance, abstraction, maintainability, or other features-is not applied in practice as much as might be desired. One deterrent is the cost of detecting candidates for refactoring and of choosing the appropriate refactoring transformation. This paper demonstrates the feasibility of automatically finding places in the program that are candidates for specific refactorings. The approach uses program invariants: when a particular pattern of invariant relationships appears at a program point, a specific refactoring is applicable. Since most programs lack explicit invariants, an invariant detection tool called Daikon is used to infer the required invariants. We developed an invariant pattern matcher for several common refactorings and applied it to an existing Java code base. Numerous refactorings were detected, and one of the developers of the code base assessed their efficacy.","1063-6773","0-7695-1189-9","10.1109/ICSM.2001.972794","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=972794","","Computer science;DH-HEMTs;Costs;Programming;Automation;Maintenance engineering;Pattern matching;Java;Marine vehicles;Software tools","program processors;software maintenance;software tools","program refactorings;maintainability;invariant relationships;Daikon;invariant detection tool;invariant pattern matcher;Java code base;software engineer;source-level transformations","","71","","23","IEEE","6 Aug 2002","","","IEEE","IEEE Conferences"
"Modeling clones evolution through time series","G. Antoniol; G. Casazza; M. Di Penta; E. Merlo","Faculty of Engineering, University of Sannio, Benevento, Italy; DIS, University of Napoli Federico II, Naples, Italy; Faculty of Engineering, University of Sannio, Benevento, Italy; École Polytechnique de Montréal, Montreal, Canada","Proceedings IEEE International Conference on Software Maintenance. ICSM 2001","6 Aug 2002","2001","","","273","280","The actual effort to evolve and maintain a software system is likely to vary depending on the amount of clones (i.e., duplicated or slightly different code fragments) present in the system. This paper presents a method for monitoring and predicting clones evolution across subsequent versions of a software system. Clones are firstly identified using a metric-based approach, then they are modeled in terms of time series identifying a predictive model. The proposed method has been validated with an experimental activity performed on 27 subsequent versions of mSQL, a medium-size software system written in C. The time span period of the analyzed mSQL releases covers four years, from May 1995 (mSQL 1.0.6) to May 1999 (mSQL 2. 0. 10). For any given software release, the identified models was able to predict the clone percentage of the subsequent release with an average error below 4 %. A higher prediction error was observed only in correspondence of major system redesign.","1063-6773","0-7695-1189-9","10.1109/ICSM.2001.972740","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=972740","","Cloning;Software systems;DH-HEMTs;Monitoring;Predictive models;Software quality;Economic forecasting;Time series analysis;Software performance;Maintenance engineering","software maintenance;time series;software metrics","clones evolution modelling;time series;software system maintenance;code fragments;metric-based approach;mSQL;prediction error;software evolution;medium-size software system","","27","","28","IEEE","6 Aug 2002","","","IEEE","IEEE Conferences"
"Identifying clones in the Linux kernel","G. Casazza; G. Antoniol; U. Villano; E. Merlo; M. Di Penta","Federico II, University of Naples, Naples, Italy; Faculty of Engineering, University of Sannio, Benevento, Italy; Faculty of Engineering, University of Sannio, Benevento, Italy; École Polytechnique de Montréal, Montreal, Canada; Faculty of Engineering, University of Sannio, Benevento, Italy","Proceedings First IEEE International Workshop on Source Code Analysis and Manipulation","6 Aug 2002","2001","","","90","97","Large multi-platform software systems are likely to encompass hardware-dependent code or sub-systems. However, analyzing multi-platform source code is challenging, due to the variety of supported configurations. Often, the system was originally developed for a single platform, and then new target platforms were added. This practice promotes the presence of duplicated code, also called ""cloned"" code. The paper presents the clone percentage of a multi-platform-multi-million lines of code, Linux kernel version 2.4.0, detected with a metric-based approach. After a brief description of the procedure followed for code analysis and clone identification, the obtained results are commented upon.","","0-7695-1387-5","10.1109/SCAM.2001.972670","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=972670","","Cloning;Linux;Kernel;Software systems;Hardware;Software metrics;Writing;Computer industry;Assembly;Operating systems","Unix;operating system kernels;software portability;software metrics","clone identification;Linux kernel;large multi-platform software systems;hardware-dependent code;multi-platform source code;single platform;duplicated code;cloned code;clone percentage;metric-based approach;code analysis","","19","","12","IEEE","6 Aug 2002","","","IEEE","IEEE Conferences"
"Restructuring Web applications via transformation rules","F. Ricca; P. Tonella; I. D. Baxter","ITC IRST, Trento, Italy; ITC IRST, Trento, Italy; Semantic Designs, Inc., Austin, TX, USA","Proceedings First IEEE International Workshop on Source Code Analysis and Manipulation","6 Aug 2002","2001","","","150","160","During the evolution phase, the structure (pages and links) of a Web application tends unavoidably to degrade. A solution to reverse this degradation can be restructuring the Web application, but this work may take a lot of time and effort if conducted without appropriate tools. The theory of rewrite rules has been used with success in many real restructuring works on traditional software. Our idea is trying to apply rewrite rules to Web applications with the aim of restructuring them. The purpose of the paper is threefold: to describe our initial ideas on HTML rewrites to improve the quality of Web applications, to present our approach for implementing a tool, based on transformation rules, that can help designers in Web application restructuring and to define the starting point of the joint project between ITC-irst and Semantic Designs.","","0-7695-1387-5","10.1109/SCAM.2001.972676","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=972676","","HTML;Degradation;Application software;Web pages;Cascading style sheets;Software systems;Web page design;Documentation;Uniform resource locators;File systems","information resources;software prototyping;rewriting systems;hypermedia markup languages","Web application restructuring;transformation rules;Web application evolution;rewrite rules;restructuring works;HTML rewrites;Semantic Designs","","10","3","16","IEEE","6 Aug 2002","","","IEEE","IEEE Conferences"
"Feasibility study with agents on energy trading","L. L. Lai; T. Motshegwa; H. Suasinghe; N. Rajkumar; R. Blach","Energy Systems Group, City University, London, UK; Energy Systems Group, City University, London, UK; Energy Syst. Group, City Univ., London, UK; Energy Systems Group, City University, London, UK; Energy Systems Group, City University, London, UK","2000 International Conference on Advances in Power System Control, Operation and Management, APSCOM-00","6 Aug 2002","2000","2","","505","510 vol.2","The electric power industry is undergoing rapid and significant change with the advent of deregulation. In a networked environment, it is desirable that the agent be mobile. In the envisaged market scenario, the customer's agent (load) attempts to get the best value for money and minimize costs and the seller's (generator) agent attempts to maximize profit and minimize costs. The success of the agent technology depends heavily on inter-agent communication, agent architectures and agreed standards. In this paper, the authors focus more on how these latter issues are addressed theoretically and practically and less on complex agent trading behaviours.","","0-85296-791-8","10.1049/cp:20000452","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=950401","","","electricity supply industry;software agents;power system economics;tariffs;costing","electric power industry;deregulation;networked environment;energy trading;agent technology;feasibility study;market scenario;profit;costs;inter-agent communication;agent architectures","","5","","","","6 Aug 2002","","","IET","IET Conferences"
"Extreme programming and its development practices","R. Juric","South Bank University Business School, London, UK","ITI 2000. Proceedings of the 22nd International Conference on Information Technology Interfaces (Cat. No.00EX411)","6 Aug 2002","2000","","","97","104","Extreme programming (XP) has attracted attention because of its fierce denial of many well-accepted software engineering practices considered as a sound approach to the development of intensive software systems. XP has been declared to be a new way of software development: a lightweight methodology, which is efficient, low-risk, flexible, predictable, scientific, and distinguishable from any other methodology. In the core of XP practices are programming activities, with strong emphasis on oral communications, automated tests, pair programming, storytelling culture and collective code-ownership at any time in the XP project. The paper gives an overview of XP practices and raises some serious concerns regarding their role in conceptual modelling and code generation; which directly affects software architecture solutions. The paper also tackles similarities between rational unified process (RUP) and XP, which have often been juxtaposed by software developers.","1330-1012","953-96769-1-6","","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=915842","","Object oriented modeling;Software systems;Unified modeling language;Software engineering;Automatic programming;Employment;Electronic mail;Oral communication;Automatic testing;Software architecture","programming;software architecture","extreme programming;software engineering practice;intensive software systems;oral communications;automated tests;pair programming;storytelling culture;collective code-ownership;conceptual modelling;code generation;software architecture solutions;rational unified process","","2","","13","","6 Aug 2002","","","IEEE","IEEE Conferences"
"Security and privacy issues in wireless and mobile computing","G. Racherla; D. Saha","SRI International Menlo Park, USA; Jadavpur University, Calcutta, India","2000 IEEE International Conference on Personal Wireless Communications. Conference Proceedings (Cat. No.00TH8488)","6 Aug 2002","2000","","","509","513","Implementing security in wireless systems is a difficult and challenging task owing to the mobility of users and network components and the fact that the wireless medium is susceptible to eavesdropping, espionage and fraud. We study the security issues in wireless systems in this paper. Specifically, we discuss the security problems in wireless systems and the proposed solutions and security measures implemented in several wireless systems.","","0-7803-5893-7","10.1109/ICPWC.2000.905910","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=905910","","Privacy;Communication system security;Mobile computing;Information security;Data security;Computer networks;Application software;Authentication;GSM;Wireless LAN","telecommunication security;computer crime;data privacy;fraud;mobile computing;mobile radio","security issues;privacy issues;wireless computing;mobile computing;eavesdropping;espionage;fraud","","1","4","16","IEEE","6 Aug 2002","","","IEEE","IEEE Conferences"
"Design reuse and scale: keys to practical code generation and large scale software maintenance","I. D. Baxter","Semantic Designs, Inc.","Proceedings 3rd IEEE Symposium on Application-Specific Systems and Software Engineering Technology","6 Aug 2002","2000","","","119","120","We advocate the reuse of design knowledge rather than code as the most effective means for obtaining productivity and quality improvements in software engineering activities. This knowledge comes in several forms; domain analysis, generative knowledge, and knowledge of the structure of a particular system in terms of the domain and how domain concepts are implemented. We are building and using a practical large-scale software (re)engineering tool, the Design Maintenance System (DMS) that implements these ideas. Reusing design knowledge, DMS is able to automate many interesting engineering activities: analysis, reverse engineering, forward synthesis, and eventually software maintenance via design maintenance. Code reuse methods are incapable of providing strong support for these activities. However, many issues involved in DMS construction are driven by the scale of the problem; number of languages, sheer code volume, amount of knowledge involved, and computational energy required.","","0-7695-0559-7","10.1109/ASSET.2000.888063","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=888063","","Software maintenance;Productivity;Software engineering;Buildings;Large-scale systems;Software tools;Design engineering;Knowledge engineering;Reverse engineering;Software design","program compilers;software reusability;software maintenance;software quality;systems re-engineering;software tools","design reuse;code generation;software maintenance;productivity;software quality improvement;software engineering;domain analysis;software reengineering tool;Design Maintenance System;reverse engineering;forward synthesis","","","","5","IEEE","6 Aug 2002","","","IEEE","IEEE Conferences"
"A structured demonstration of program comprehension tools","S. E. Sim; M. A. D. Storey","Department of Computer Science, University of Victoria, Victoria, BC, Canada; Department of Computer Science, University of Toronto, Toronto, ONT, Canada","Proceedings Seventh Working Conference on Reverse Engineering","6 Aug 2002","2000","","","184","193","This paper describes a structured tool demonstration, a hybrid evaluation technique that combines elements from experiments, case studies and technology demonstrations. Developers of program understanding tools were invited to bring their tools to a common location to participate in a scenario with a common subject system. Working simultaneously the tool teams were given reverse engineering tasks and maintenance tasks to complete on an unfamiliar subject system. Observers were assigned to each team to find out how useful the observed program comprehension tool would be in an industrial setting. The demonstration was followed by a workshop panel where the development teams and the observers presented their results and findings from this experience.","1095-1350","0-7695-0881-2","10.1109/WCRE.2000.891465","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=891465","","Reverse engineering;Software systems;Software tools;Computer science;Educational institutions;Technology transfer;Scalability;Nominations and elections;Visualization;Operating systems","reverse engineering;software maintenance;software tools","program comprehension tools;structured tool demonstration;hybrid evaluation technique;experiments;case studies;technology demonstrations;program understanding;reverse engineering;software maintenance","","14","","24","IEEE","6 Aug 2002","","","IEEE","IEEE Conferences"
"Advanced clone-analysis to support object-oriented system refactoring","M. Balazinska; E. Merlo; M. Dagenais; B. Lague; K. Kontogiannis","Quality Engineering and Research Group, Bell Canada Limited, Montreal, QUE, Canada; Department of Electrical a.nd Computer Engineering, Ecole Polytechnique de Montreal, Montreal, QUE, Canada; Department of Electrical and Computer Engineering, University of Waterloo, Waterloo, ONT, Canada; Department of Electrical a.nd Computer Engineering, Ecole Polytechnique de Montreal, Montreal, QUE, Canada; Department of Electrical a.nd Computer Engineering, Ecole Polytechnique de Montreal, Montreal, QUE, Canada","Proceedings Seventh Working Conference on Reverse Engineering","6 Aug 2002","2000","","","98","107","Manual source code copy and modification is often used by programmers as an easy means for functionality reuse. Nevertheless, such practice produces duplicated pieces of code or clones whose consistent maintenance might be difficult to achieve. It also creates implicit links between classes sharing a functionality. Clones are therefore good candidates for system redesign. This paper presents a novel approach for computer-aided clone-based object-oriented system refactoring. The approach is based on an advanced clone analysis which focuses on the extraction of clone differences and their interpretation in terms of programming language entities. It also focuses on the study of contextual dependencies of cloned methods. The clone analysis has been applied to JDK 1.1.5, a large scale system of 150 KLOC.","1095-1350","0-7695-0881-2","10.1109/WCRE.2000.891457","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=891457","","Cloning;Programming profession;Software systems;Electronic mail;Computer languages;Large-scale systems;Software libraries;Information analysis","object-oriented programming;software reusability;software maintenance;reverse engineering","clone analysis;object-oriented system refactoring;source code copy;functionality reuse;software maintenance;system redesign;programming language;JDK;large scale system;reverse engineering","","89","","15","IEEE","6 Aug 2002","","","IEEE","IEEE Conferences"
"Applying traditional Unix tools during maintenance: an experience report","A. Tateishi; A. Walenstein","School of Computer Science, Simon Fraser University, Burnaby, BC, Canada; Ruhtra Consulting Services, Inc., Toronto, ONT, Canada","Proceedings Seventh Working Conference on Reverse Engineering","6 Aug 2002","2000","","","203","206","The Unix programming environment provides a rich and fairly standard set of generic tools for the development and maintenance of software. In an age of advanced software tools and environments, it is useful to see how new tools compare against an old baseline. The exercise involved performing three tasks: (1) producing summary documentation; (2) evaluating program structure; and (3) reconnoitering future maintenance tasks. Our experiences from one small exercise in maintenance suggest that simple Unix tools seem to raise the bar of excellence deceptively high.","1095-1350","0-7695-0881-2","10.1109/WCRE.2000.891469","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=891469","","Programming profession;Software maintenance;Documentation;Programming environments;Software standards;Standards development;Software tools;Reverse engineering;Milling machines;Power system management","Unix;software maintenance;system documentation;reverse engineering","traditional Unix tools;software maintenance;experience report;Unix programming environment;generic tools;advanced software tools;simple Unix tools;summary documentation;program structure evaluation;maintenance tasks","","1","","3","IEEE","6 Aug 2002","","","IEEE","IEEE Conferences"
